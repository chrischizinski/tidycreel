[{"path":[]},{"path":"/CODE_OF_CONDUCT.html","id":"our-pledge","dir":"","previous_headings":"","what":"Our Pledge","title":"Contributor Covenant Code of Conduct","text":"members, contributors, leaders pledge make participation community harassment-free experience everyone, regardless age, body size, visible invisible disability, ethnicity, sex characteristics, gender identity expression, level experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, sexual identity orientation. pledge act interact ways contribute open, welcoming, diverse, inclusive, healthy community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"our-standards","dir":"","previous_headings":"","what":"Our Standards","title":"Contributor Covenant Code of Conduct","text":"Examples behavior contributes positive environment community include: Demonstrating empathy kindness toward people respectful differing opinions, viewpoints, experiences Giving gracefully accepting constructive feedback Accepting responsibility apologizing affected mistakes, learning experience Focusing best just us individuals, overall community Examples unacceptable behavior include: use sexualized language imagery, sexual attention advances kind Trolling, insulting derogatory comments, personal political attacks Public private harassment Publishing others’ private information, physical email address, without explicit permission conduct reasonably considered inappropriate professional setting","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-responsibilities","dir":"","previous_headings":"","what":"Enforcement Responsibilities","title":"Contributor Covenant Code of Conduct","text":"Community leaders responsible clarifying enforcing standards acceptable behavior take appropriate fair corrective action response behavior deem inappropriate, threatening, offensive, harmful. Community leaders right responsibility remove, edit, reject comments, commits, code, wiki edits, issues, contributions aligned Code Conduct, communicate reasons moderation decisions appropriate.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"scope","dir":"","previous_headings":"","what":"Scope","title":"Contributor Covenant Code of Conduct","text":"Code Conduct applies within community spaces, also applies individual officially representing community public spaces. Examples representing community include using official e-mail address, posting via official social media account, acting appointed representative online offline event.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement","dir":"","previous_headings":"","what":"Enforcement","title":"Contributor Covenant Code of Conduct","text":"Instances abusive, harassing, otherwise unacceptable behavior may reported community leaders responsible enforcement maintainer@example.com. complaints reviewed investigated promptly fairly. community leaders obligated respect privacy security reporter incident.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"enforcement-guidelines","dir":"","previous_headings":"","what":"Enforcement Guidelines","title":"Contributor Covenant Code of Conduct","text":"Community leaders follow Community Impact Guidelines determining consequences action deem violation Code Conduct:","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_1-correction","dir":"","previous_headings":"Enforcement Guidelines","what":"1. Correction","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Use inappropriate language behavior deemed unprofessional unwelcome community. Consequence: private, written warning community leaders, providing clarity around nature violation explanation behavior inappropriate. public apology may requested.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_2-warning","dir":"","previous_headings":"Enforcement Guidelines","what":"2. Warning","title":"Contributor Covenant Code of Conduct","text":"Community Impact: violation single incident series actions. Consequence: warning consequences continued behavior. interaction people involved, including unsolicited interaction enforcing Code Conduct, specified period time. includes avoiding interactions community spaces well external channels like social media. Violating terms may lead temporary permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_3-temporary-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"3. Temporary Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: serious violation community standards, including sustained inappropriate behavior. Consequence: temporary ban sort interaction public communication community specified period time. public private interaction people involved, including unsolicited interaction enforcing Code Conduct, allowed period. Violating terms may lead permanent ban.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"id_4-permanent-ban","dir":"","previous_headings":"Enforcement Guidelines","what":"4. Permanent Ban","title":"Contributor Covenant Code of Conduct","text":"Community Impact: Demonstrating pattern violation community standards, including sustained inappropriate behavior, harassment individual, aggression toward disparagement classes individuals. Consequence: permanent ban sort public interaction within community.","code":""},{"path":"/CODE_OF_CONDUCT.html","id":"attribution","dir":"","previous_headings":"","what":"Attribution","title":"Contributor Covenant Code of Conduct","text":"Code Conduct adapted Contributor Covenant, version 2.1, available https://www.contributor-covenant.org/version/2/1/code_of_conduct.html. Community Impact Guidelines inspired [Mozilla’s code conduct enforcement ladder][https://github.com/mozilla/inclusion]. answers common questions code conduct, see FAQ https://www.contributor-covenant.org/faq. Translations available https://www.contributor-covenant.org/translations.","code":""},{"path":"/CONTRIBUTING.html","id":null,"dir":"","previous_headings":"","what":"Contributing to tidycreel","title":"Contributing to tidycreel","text":"welcome contributions tidycreel! document outlines development standards contribution process.","code":""},{"path":"/CONTRIBUTING.html","id":"code-of-conduct","dir":"","previous_headings":"","what":"Code of Conduct","title":"Contributing to tidycreel","text":"Please note project released Contributor Code Conduct. participating project agree abide terms.","code":""},{"path":[]},{"path":"/CONTRIBUTING.html","id":"vectorization-first-policy","dir":"","previous_headings":"Development Principles","what":"Vectorization-First Policy","title":"Contributing to tidycreel","text":"tidycreel follows vectorization-first approach ensure performance scalability: Prefer vectorized operations explicit loops (, ) whenever possible Use grouped operations via dplyr::group_by() stratum-level calculations Leverage vectorized functions base R, tidyverse, survey packages Avoid apply() family vectorized alternatives exist Profile performance functions processing large datasets (>10^5 rows) Examples:","code":"# ✅ Good: Vectorized approach effort_total <- sum(design_data$effort * design_data$weights, na.rm = TRUE)  # ✅ Good: Grouped vectorized approach strata_totals <- design_data %>%   group_by(stratum_id) %>%   summarise(effort = sum(effort * weights, na.rm = TRUE))  # ❌ Avoid: Explicit loops effort_total <- 0 for (i in seq_len(nrow(design_data))) {   effort_total <- effort_total + design_data$effort[i] * design_data$weights[i] }"},{"path":"/CONTRIBUTING.html","id":"statistical-foundations","dir":"","previous_headings":"Development Principles","what":"Statistical Foundations","title":"Contributing to tidycreel","text":"tidycreel builds survey package authoritative engine: Use survey::svydesign() survey::svrepdesign() design objects Provide tidy wrappers around survey functions pipe-friendly interfaces Return tibbles estimates, standard errors, metadata Document statistical assumptions variance estimation methods Favor design-based estimators model-based approaches defaults","code":""},{"path":"/CONTRIBUTING.html","id":"tidyverse-style","dir":"","previous_headings":"Development Principles","what":"Tidyverse Style","title":"Contributing to tidycreel","text":"Follow tidyverse style guide completely: Function names: snake_case descriptive verbs (estimate_effort, effort_est) Variable names: snake_case clear meaning (party_size, ps) File names: kebab-case multi-word concepts (design-constructors.R) Documentation: Complete roxygen2 docs examples Pipes: Use %>% multi-step data transformations","code":""},{"path":[]},{"path":"/CONTRIBUTING.html","id":"code-quality","dir":"","previous_headings":"Technical Standards","what":"Code Quality","title":"Contributing to tidycreel","text":"100% public functions must roxygen2 documentation exported functions must include working examples Target ≥90% test coverage meaningful assertions Use usethis, devtools, testthat workflows development Run devtools::check() submitting pull requests","code":""},{"path":"/CONTRIBUTING.html","id":"testing-requirements","dir":"","previous_headings":"Technical Standards","what":"Testing Requirements","title":"Contributing to tidycreel","text":"Every contribution must include tests: Test edge cases explicitly: - Zero effort/catch scenarios - Empty strata - Missing data patterns - Single-observation groups - Date/time boundary conditions (DST, leap years)","code":"test_that(\"estimate_effort returns proper structure\", {   # Arrange   design <- create_test_design()    # Act   result <- estimate_effort(design)    # Assert   expect_s3_class(result, \"tbl_df\")   expect_true(all(c(\"effort_estimate\", \"se\", \"cv\") %in% names(result)))   expect_true(all(result$effort_estimate >= 0)) })"},{"path":"/CONTRIBUTING.html","id":"performance-expectations","dir":"","previous_headings":"Technical Standards","what":"Performance Expectations","title":"Contributing to tidycreel","text":"Functions must scale efficiently: Benchmark large datasets (10^6+ rows) tests Use profvis profiling computationally intensive functions Consider data.table backends heavy processing Document time/memory complexity key algorithms","code":""},{"path":[]},{"path":"/CONTRIBUTING.html","id":"getting-started","dir":"","previous_headings":"Contribution Workflow","what":"Getting Started","title":"Contributing to tidycreel","text":"Fork clone repository Create feature branch: git checkout -b feature/descriptive-name Set development environment:","code":"renv::restore() devtools::load_all()"},{"path":"/CONTRIBUTING.html","id":"development-process","dir":"","previous_headings":"Contribution Workflow","what":"Development Process","title":"Contributing to tidycreel","text":"Write tests first following TDD principles Implement feature following style guide Update documentation including function docs vignettes needed Run comprehensive checks: Commit clear messages following conventional commits","code":"devtools::document() devtools::test() devtools::check()"},{"path":"/CONTRIBUTING.html","id":"pull-request-guidelines","dir":"","previous_headings":"Contribution Workflow","what":"Pull Request Guidelines","title":"Contributing to tidycreel","text":"submitting: - [ ] tests pass (devtools::test()) - [ ] Package passes R CMD check (devtools::check()) - [ ] Documentation complete accurate - [ ] NEWS.md updated user-facing changes - [ ] Code follows tidyverse style (verified styler::style_pkg()) PR Description include: - Summary changes motivation - Links relevant issues - Breaking changes () - Example usage new features","code":""},{"path":[]},{"path":"/CONTRIBUTING.html","id":"file-organization","dir":"","previous_headings":"Package Architecture","what":"File Organization","title":"Contributing to tidycreel","text":"","code":"R/ ├── data-schemas.R      # Schema definitions and validation ├── design-constructors.R  # Survey design object creation ├── estimators.R        # Core estimation functions ├── legacy-*.R          # Legacy API compatibility └── utils.R             # Internal helper functions"},{"path":"/CONTRIBUTING.html","id":"naming-conventions","dir":"","previous_headings":"Package Architecture","what":"Naming Conventions","title":"Contributing to tidycreel","text":"Design functions: design_*() Estimation functions: estimate_*() Validation functions: validate_*() Utility functions: calculate_*(), create_*()","code":""},{"path":"/CONTRIBUTING.html","id":"dependencies","dir":"","previous_headings":"Package Architecture","what":"Dependencies","title":"Contributing to tidycreel","text":"Core dependencies (keep minimal): - survey - design objects estimation - dplyr, tidyr - data manipulation - rlang, vctrs - programming tools Suggested dependencies (specific features): - cli - user messaging - lifecycle - deprecation management","code":""},{"path":"/CONTRIBUTING.html","id":"getting-help","dir":"","previous_headings":"","what":"Getting Help","title":"Contributing to tidycreel","text":"GitHub Issues: Bug reports feature requests GitHub Discussions: Questions community support Code Review: maintainers provide feedback PRs","code":""},{"path":"/CONTRIBUTING.html","id":"recognition","dir":"","previous_headings":"","what":"Recognition","title":"Contributing to tidycreel","text":"Contributors recognized : - Package DESCRIPTION file - NEWS.md release notes - Annual contributor acknowledgments Thank contributing tidycreel!","code":""},{"path":"/articles/aerial.html","id":"data","dir":"Articles","previous_headings":"","what":"Data","title":"Aerial Effort Estimation with survey","text":"assume day-level sampling calendar aerial counts per-count minutes (optionally) total day minutes represented.","code":"library(tidycreel) library(dplyr)  calendar <- tibble::tibble(   date = as.Date(c(\"2025-08-20\",\"2025-08-21\")),   day_type = c(\"weekday\",\"weekday\"),   month = c(\"August\",\"August\"),   target_sample = c(4,4),   actual_sample = c(2,2) )  counts <- tibble::tibble(   date = as.Date(c(\"2025-08-20\",\"2025-08-20\",\"2025-08-21\",\"2025-08-21\")),   location = c(\"A\",\"B\",\"A\",\"B\"),   count = c(10,12,8,15),   interval_minutes = c(60,60,60,60),   total_day_minutes = c(720,720,720,720),   cloud = c(\"low\",\"low\",\"high\",\"high\") )"},{"path":"/articles/aerial.html","id":"day-level-survey-design","dir":"Articles","previous_headings":"","what":"Day-level survey design","title":"Aerial Effort Estimation with survey","text":"Construct day PSU design calendar. Weights target/actual per stratum.","code":"svy_day <- as_day_svydesign(calendar, day_id = \"date\", strata_vars = c(\"day_type\",\"month\"))"},{"path":"/articles/aerial.html","id":"aerial-effort-estimation","dir":"Articles","previous_headings":"","what":"Aerial effort estimation","title":"Aerial Effort Estimation with survey","text":"Estimate per-location totals design-based SE/CI via survey:","code":"res <- est_effort.aerial(   counts,   by = c(\"location\"),   minutes_col = c(\"interval_minutes\"),   total_minutes_col = c(\"total_day_minutes\"),   day_id = \"date\",   covariates = c(\"cloud\"),   svy = svy_day ) res"},{"path":"/articles/aerial.html","id":"post-stratification-calibration-optional","dir":"Articles","previous_headings":"Aerial effort estimation","what":"Post-stratification / calibration (optional)","title":"Aerial Effort Estimation with survey","text":"known population totals categorical covariate (e.g., cloud classes season), can post-stratify design: calibration known totals across numeric auxiliary variables, supply model totals: Note: Choose post-stratification vs calibration based design available auxiliary information; ensure assumptions met targets defensible.","code":"cloud_pop <- tibble::tibble(cloud = c(\"low\",\"high\"), Freq = c(12, 18)) res_ps <- est_effort.aerial(   counts, by = c(\"location\"), minutes_col = \"interval_minutes\",   total_minutes_col = \"total_day_minutes\", day_id = \"date\", svy = svy_day,   post_strata_var = \"cloud\", post_strata = cloud_pop ) res_ps # Example only; supply meaningful totals in your analysis cal_tot <- c(`(Intercept)` = 30) res_cal <- est_effort.aerial(   counts, by = c(\"location\"), minutes_col = \"interval_minutes\",   total_minutes_col = \"total_day_minutes\", day_id = \"date\", svy = svy_day,   calibrate_formula = ~ 1, calibrate_population = cal_tot, calfun = \"linear\" ) res_cal"},{"path":"/articles/aerial.html","id":"method-choice-post-stratification-vs-calibration","dir":"Articles","previous_headings":"","what":"Method Choice: Post-stratification vs Calibration","title":"Aerial Effort Estimation with survey","text":"Best categorical auxiliary variable defensible population distribution (e.g., proportion days cloud class) sample may /-represent levels. Uses survey::postStratify(design, ~cat, pop), pop columns category Freq known totals. Preserves design weights within post-strata; simple stable categories well-populated. Best adjusting numeric auxiliary totals (e.g., totals multiple covariates) raking across several margins. Uses survey::calibrate() model known totals; supports linear, raking, logit calibration functions. flexible can sensitive targets incompatible design extreme weights result; check diagnostics. Practical tips - Define day-level PSU design first; adjustments (post-stratification, calibration) operate design. - Use replicate-weight designs (svrepdesign) robust SEs complex adjustments. - Ensure auxiliary targets well-justified (e.g., climatology, flight logs) cover population period estimates. - Inspect weight distributions adjustment (e.g., summary(weights(design))).","code":""},{"path":"/articles/aerial.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Aerial Effort Estimation with survey","text":"Pollock, K.H., Jones, C.M., & Brown, T.L. (1994). Angler Survey Methods Applications Fisheries Management. American Fisheries Society Special Publication. Malvestuto, S.P. (1996). Sampling creel survey data. : Murphy, B.R. & Willis, D.W. (eds) Fisheries Techniques, 2nd ed. American Fisheries Society. Lumley, T. (2010). Complex Surveys: Guide Analysis Using R. John Wiley & Sons. (Author survey package.) Related background project-specific guidance: see creel_foundations.md, creel_effort_estimation_methods.md, creel_chapter.md repository.","code":""},{"path":"/articles/aerial.html","id":"weight-diagnostics-and-replicate-designs","dir":"Articles","previous_headings":"","what":"Weight Diagnostics and Replicate Designs","title":"Aerial Effort Estimation with survey","text":"Inspect day-level weights adjustment. Large highly skewed weights can inflate variance indicate mismatches design targets.","code":"# Weights before adjustment summary(stats::weights(svy_day))  # Convert to replicate-weight design (bootstrap) for robust SEs svy_rep <- survey::as.svrepdesign(svy_day, type = \"bootstrap\", replicates = 50) summary(svy_rep)  # Example: estimate with replicate design res_rep <- est_effort.aerial(   counts,   by = c(\"location\"),   minutes_col = c(\"interval_minutes\"),   total_minutes_col = c(\"total_day_minutes\"),   day_id = \"date\",   svy = svy_rep ) res_rep  # Optional: simple weight histogram (requires ggplot2) if (requireNamespace(\"ggplot2\", quietly = TRUE)) {   library(ggplot2)   wdf <- tibble::tibble(w = as.numeric(stats::weights(svy_day)))   ggplot(wdf, aes(w)) + geom_histogram(bins = 30) + theme_minimal() +     labs(title = \"Day-level survey weights\", x = \"Weight\", y = \"Count\") }"},{"path":"/articles/cpue_catch.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"CPUE and Catch Estimation","text":"vignette demonstrates estimate Catch Per Unit Effort (CPUE) total catch/harvest using tidycreel’s survey-first approach. estimators build survey package proper design-based inference.","code":""},{"path":[]},{"path":"/articles/cpue_catch.html","id":"cpue-estimation-modes","dir":"Articles","previous_headings":"Key Concepts","what":"CPUE Estimation Modes","title":"CPUE and Catch Estimation","text":"tidycreel provides two CPUE estimation modes: Preferred incomplete trips trip completion varies Uses survey::svyratio() proper variance robust outliers Appropriate complete trips Uses survey::svymean() pre-computed ratios Can sensitive zero-effort trips","code":""},{"path":"/articles/cpue_catch.html","id":"catchharvest-estimation","dir":"Articles","previous_headings":"Key Concepts","what":"Catch/Harvest Estimation","title":"CPUE and Catch Estimation","text":"Total catch harvest uses survey::svytotal() expand interview data population totals proper variance estimation.","code":""},{"path":"/articles/cpue_catch.html","id":"loading-example-data","dir":"Articles","previous_headings":"","what":"Loading Example Data","title":"CPUE and Catch Estimation","text":"","code":"# Load toy datasets interviews <- readr::read_csv(   system.file(\"extdata/toy_interviews.csv\", package = \"tidycreel\"),   show_col_types = FALSE ) calendar <- readr::read_csv(   system.file(\"extdata/toy_calendar.csv\", package = \"tidycreel\"),   show_col_types = FALSE )  # Preview interview data head(interviews) #> # A tibble: 6 × 17 #>   interview_id date       time_start          time_end            location mode  #>   <chr>        <date>     <dttm>              <dttm>              <chr>    <chr> #> 1 INT001       2024-01-01 2024-01-01 08:30:00 2024-01-01 08:45:00 Lake_A   boat  #> 2 INT001B      2024-01-01 2024-01-01 08:30:00 2024-01-01 08:45:00 Lake_B   boat  #> 3 INT002       2024-01-01 2024-01-01 09:15:00 2024-01-01 09:30:00 Lake_A   bank  #> 4 INT002B      2024-01-01 2024-01-01 09:15:00 2024-01-01 09:30:00 Lake_B   bank  #> 5 INT003       2024-01-01 2024-01-01 10:00:00 2024-01-01 10:20:00 Lake_A   boat  #> 6 INT003B      2024-01-01 2024-01-01 10:00:00 2024-01-01 10:20:00 Lake_B   boat  #> # ℹ 11 more variables: shift_block <chr>, day_type <chr>, party_size <dbl>, #> #   hours_fished <dbl>, target_species <chr>, catch_total <dbl>, #> #   catch_kept <dbl>, catch_released <dbl>, weight_total <dbl>, #> #   trip_complete <lgl>, effort_expansion <dbl>"},{"path":[]},{"path":"/articles/cpue_catch.html","id":"day-level-design","dir":"Articles","previous_headings":"Creating Survey Designs","what":"Day-Level Design","title":"CPUE and Catch Estimation","text":"First, create day-level design sampling calendar:","code":"# Create day-level survey design svy_day <- as_day_svydesign(   calendar,   day_id = \"date\",   strata_vars = c(\"day_type\", \"month\") )  # Check the design summary(weights(svy_day)) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   1.027   1.027   1.064   1.052   1.064   1.064"},{"path":"/articles/cpue_catch.html","id":"interview-level-design","dir":"Articles","previous_headings":"Creating Survey Designs","what":"Interview-Level Design","title":"CPUE and Catch Estimation","text":"CPUE catch estimation, need interview-level design. Join day-level weights interviews:","code":"# Join day weights to interviews interviews_weighted <- interviews %>%   left_join(     svy_day$variables %>% select(date, .w),     by = \"date\"   )  # Create interview-level survey design svy_interview <- survey::svydesign(   ids = ~1,   weights = ~.w,   data = interviews_weighted )  # Check the design summary(weights(svy_interview)) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   1.027   1.064   1.064   1.055   1.064   1.064"},{"path":[]},{"path":"/articles/cpue_catch.html","id":"ratio-of-means-default","dir":"Articles","previous_headings":"CPUE Estimation","what":"Ratio-of-Means (Default)","title":"CPUE and Catch Estimation","text":"ratio--means approach preferred creel surveys: estimates CPUE : CPUE=∑wi⋅catchi∑wi⋅efforti\\text{CPUE} = \\frac{\\sum w_i \\cdot \\text{catch}_i}{\\sum w_i \\cdot \\text{effort}_i} wiw_i survey weights.","code":"# CPUE by target species (ratio-of-means) cpue_species <- est_cpue(   svy_interview,   by = c(\"target_species\"),   response = \"catch_total\",   effort = \"hours_fished\",   mode = \"ratio_of_means\" )  cpue_species #> # A tibble: 4 × 8 #>   target_species estimate     se ci_low ci_high     n method         diagnostics #>   <chr>             <dbl>  <dbl>  <dbl>   <dbl> <int> <chr>          <list>      #> 1 bass               1.19 0.0527   1.08    1.29    60 cpue_ratio_of… <NULL>      #> 2 catfish            1    0        1       1       24 cpue_ratio_of… <NULL>      #> 3 panfish            2    0.164    1.68    2.32    24 cpue_ratio_of… <NULL>      #> 4 walleye            1.74 0.0802   1.58    1.90    48 cpue_ratio_of… <NULL>"},{"path":"/articles/cpue_catch.html","id":"mean-of-ratios","dir":"Articles","previous_headings":"CPUE Estimation","what":"Mean-of-Ratios","title":"CPUE and Catch Estimation","text":"complete trips, can use mean--ratios: estimates CPUE : CPUE=1n∑wi⋅catchiefforti\\text{CPUE} = \\frac{1}{n}\\sum w_i \\cdot \\frac{\\text{catch}_i}{\\text{effort}_i}","code":"# Filter to complete trips only complete_trips <- interviews_weighted %>%   filter(trip_complete == TRUE)  svy_complete <- survey::svydesign(   ids = ~1,   weights = ~.w,   data = complete_trips )  # CPUE by species (mean-of-ratios) cpue_mor <- est_cpue(   svy_complete,   by = c(\"target_species\"),   response = \"catch_total\",   effort = \"hours_fished\",   mode = \"mean_of_ratios\" )  cpue_mor #> # A tibble: 4 × 8 #>   target_species estimate     se ci_low ci_high     n method         diagnostics #>   <chr>             <dbl>  <dbl>  <dbl>   <dbl> <int> <chr>          <list>      #> 1 bass               1.16 0.0443   1.07    1.24    60 cpue_mean_of_… <NULL>      #> 2 catfish            1    0        1       1       24 cpue_mean_of_… <NULL>      #> 3 panfish            1.83 0.171    1.50    2.17    24 cpue_mean_of_… <NULL>      #> 4 walleye            1.77 0.0812   1.61    1.93    48 cpue_mean_of_… <NULL>"},{"path":"/articles/cpue_catch.html","id":"comparing-methods","dir":"Articles","previous_headings":"CPUE Estimation","what":"Comparing Methods","title":"CPUE and Catch Estimation","text":"","code":"# Compare the two methods comparison <- bind_rows(   cpue_species %>% mutate(method = \"ratio_of_means\"),   cpue_mor %>% mutate(method = \"mean_of_ratios\") ) %>%   select(target_species, method, estimate, se, ci_low, ci_high)  comparison #> # A tibble: 8 × 6 #>   target_species method         estimate     se ci_low ci_high #>   <chr>          <chr>             <dbl>  <dbl>  <dbl>   <dbl> #> 1 bass           ratio_of_means     1.19 0.0527   1.08    1.29 #> 2 catfish        ratio_of_means     1    0        1       1    #> 3 panfish        ratio_of_means     2    0.164    1.68    2.32 #> 4 walleye        ratio_of_means     1.74 0.0802   1.58    1.90 #> 5 bass           mean_of_ratios     1.16 0.0443   1.07    1.24 #> 6 catfish        mean_of_ratios     1    0        1       1    #> 7 panfish        mean_of_ratios     1.83 0.171    1.50    2.17 #> 8 walleye        mean_of_ratios     1.77 0.0812   1.61    1.93"},{"path":"/articles/cpue_catch.html","id":"cpue-by-multiple-groups","dir":"Articles","previous_headings":"CPUE Estimation","what":"CPUE by Multiple Groups","title":"CPUE and Catch Estimation","text":"can stratify CPUE multiple variables:","code":"# CPUE by species and mode cpue_mode <- est_cpue(   svy_interview,   by = c(\"target_species\", \"mode\"),   response = \"catch_total\",   effort = \"hours_fished\",   mode = \"ratio_of_means\" )  cpue_mode #> # A tibble: 6 × 9 #>   target_species mode  estimate     se ci_low ci_high     n method   diagnostics #>   <chr>          <chr>    <dbl>  <dbl>  <dbl>   <dbl> <int> <chr>    <list>      #> 1 bass           bank     0.667 0       0.667   0.667    12 cpue_ra… <NULL>      #> 2 catfish        bank     1     0       1       1        12 cpue_ra… <NULL>      #> 3 panfish        bank     2     0.164   1.68    2.32     24 cpue_ra… <NULL>      #> 4 bass           boat     1.34  0.0431  1.25    1.42     48 cpue_ra… <NULL>      #> 5 catfish        boat     1     0       1       1        12 cpue_ra… <NULL>      #> 6 walleye        boat     1.74  0.0802  1.58    1.90     48 cpue_ra… <NULL>"},{"path":[]},{"path":"/articles/cpue_catch.html","id":"total-catch","dir":"Articles","previous_headings":"Catch and Harvest Estimation","what":"Total Catch","title":"CPUE and Catch Estimation","text":"Estimate total catch using est_catch():","code":"# Total catch by species catch_species <- est_catch(   svy_interview,   by = c(\"target_species\"),   response = \"catch_total\" )  catch_species #> # A tibble: 4 × 8 #>   target_species estimate    se ci_low ci_high     n method          diagnostics #>   <chr>             <dbl> <dbl>  <dbl>   <dbl> <int> <chr>           <list>      #> 1 bass              203.  24.0   156.    250.     60 catch_total:ca… <NULL>      #> 2 catfish            37.9  7.63   22.9    52.8    24 catch_total:ca… <NULL>      #> 3 panfish            63.8 14.4    35.7    92.0    24 catch_total:ca… <NULL>      #> 4 walleye           430.  55.0   322.    538.     48 catch_total:ca… <NULL>"},{"path":"/articles/cpue_catch.html","id":"harvest-kept-fish","dir":"Articles","previous_headings":"Catch and Harvest Estimation","what":"Harvest (Kept Fish)","title":"CPUE and Catch Estimation","text":"Estimate harvest (kept fish) separately:","code":"# Harvest by species harvest_species <- est_catch(   svy_interview,   by = c(\"target_species\"),   response = \"catch_kept\" )  harvest_species #> # A tibble: 4 × 8 #>   target_species estimate    se ci_low ci_high     n method          diagnostics #>   <chr>             <dbl> <dbl>  <dbl>   <dbl> <int> <chr>           <list>      #> 1 bass              140.  16.3   108.    172.     60 catch_total:ca… <NULL>      #> 2 catfish            37.9  7.63   22.9    52.8    24 catch_total:ca… <NULL>      #> 3 panfish            63.8 14.4    35.7    92.0    24 catch_total:ca… <NULL>      #> 4 walleye           278.  36.0   208.    349.     48 catch_total:ca… <NULL>"},{"path":"/articles/cpue_catch.html","id":"released-fish","dir":"Articles","previous_headings":"Catch and Harvest Estimation","what":"Released Fish","title":"CPUE and Catch Estimation","text":"Calculate released fish difference total catch kept fish:","code":"# Released fish by species (computed as total - kept) # Since est_catch doesn't support \"catch_released\" directly, # we compute it from total catch and harvest estimates  # We already have catch_species (total) and harvest_species (kept) from above released_species <- dplyr::left_join(   catch_species,   harvest_species,   by = \"target_species\",   suffix = c(\"_total\", \"_kept\") ) %>%   dplyr::mutate(     estimate = estimate_total - estimate_kept,     # Conservative variance assuming independence: Var(total) + Var(kept)     se = sqrt(se_total^2 + se_kept^2),     ci_low = estimate - 1.96 * se,     ci_high = estimate + 1.96 * se,     n = pmax(n_total, n_kept, na.rm = TRUE),     method = \"catch_difference\"   ) %>%   dplyr::select(target_species, estimate, se, ci_low, ci_high, n, method)  released_species #> # A tibble: 4 × 7 #>   target_species estimate    se ci_low ci_high     n method           #>   <chr>             <dbl> <dbl>  <dbl>   <dbl> <int> <chr>            #> 1 bass               63.8  29.1   6.89   121.     60 catch_difference #> 2 catfish             0    10.8 -21.1     21.1    24 catch_difference #> 3 panfish             0    20.3 -39.8     39.8    24 catch_difference #> 4 walleye           152.   65.7  23.0    281.     48 catch_difference"},{"path":"/articles/cpue_catch.html","id":"catch-by-multiple-groups","dir":"Articles","previous_headings":"Catch and Harvest Estimation","what":"Catch by Multiple Groups","title":"CPUE and Catch Estimation","text":"","code":"# Catch by species and location catch_location <- est_catch(   svy_interview,   by = c(\"target_species\", \"location\"),   response = \"catch_total\" )  catch_location #> # A tibble: 8 × 9 #>   target_species location estimate    se ci_low ci_high     n method diagnostics #>   <chr>          <chr>       <dbl> <dbl>  <dbl>   <dbl> <int> <chr>  <list>      #> 1 bass           Lake_A      102.  18.8   64.7    139.     30 catch… <NULL>      #> 2 catfish        Lake_A       18.9  5.60   7.95    29.9    12 catch… <NULL>      #> 3 panfish        Lake_A       31.9 10.5   11.4     52.4    12 catch… <NULL>      #> 4 walleye        Lake_A      215.  42.5  132.     298.     24 catch… <NULL>      #> 5 bass           Lake_B      102.  18.8   64.7    139.     30 catch… <NULL>      #> 6 catfish        Lake_B       18.9  5.60   7.95    29.9    12 catch… <NULL>      #> 7 panfish        Lake_B       31.9 10.5   11.4     52.4    12 catch… <NULL>      #> 8 walleye        Lake_B      215.  42.5  132.     298.     24 catch… <NULL>"},{"path":[]},{"path":"/articles/cpue_catch.html","id":"cpue-by-species","dir":"Articles","previous_headings":"Visualization","what":"CPUE by Species","title":"CPUE and Catch Estimation","text":"","code":"# Plot CPUE with confidence intervals ggplot(cpue_species, aes(x = target_species, y = estimate)) +   geom_col(fill = \"steelblue\", alpha = 0.7) +   geom_errorbar(     aes(ymin = ci_low, ymax = ci_high),     width = 0.2   ) +   labs(     title = \"CPUE by Target Species\",     x = \"Target Species\",     y = \"CPUE (fish per hour)\",     caption = \"Error bars show 95% confidence intervals\"   ) +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"/articles/cpue_catch.html","id":"catch-vs-harvest","dir":"Articles","previous_headings":"Visualization","what":"Catch vs Harvest","title":"CPUE and Catch Estimation","text":"","code":"# Combine catch and harvest for comparison catch_harvest <- bind_rows(   catch_species %>% mutate(type = \"Total Catch\"),   harvest_species %>% mutate(type = \"Harvest (Kept)\") )  ggplot(catch_harvest, aes(x = target_species, y = estimate, fill = type)) +   geom_col(position = \"dodge\", alpha = 0.7) +   geom_errorbar(     aes(ymin = ci_low, ymax = ci_high),     position = position_dodge(width = 0.9),     width = 0.2   ) +   labs(     title = \"Total Catch vs Harvest by Species\",     x = \"Target Species\",     y = \"Number of Fish\",     fill = \"Type\",     caption = \"Error bars show 95% confidence intervals\"   ) +   scale_fill_manual(values = c(\"steelblue\", \"coral\")) +   theme_minimal() +   theme(axis.text.x = element_text(angle = 45, hjust = 1))"},{"path":"/articles/cpue_catch.html","id":"advanced-replicate-designs","dir":"Articles","previous_headings":"","what":"Advanced: Replicate Designs","title":"CPUE and Catch Estimation","text":"robust variance estimation, use replicate weights:","code":"# Convert to bootstrap replicate design # Note: This example requires careful setup of replicate weights # For production use, see vignette(\"replicate_designs_creel\")  svy_rep <- survey::as.svrepdesign(   svy_day,   type = \"bootstrap\",   replicates = 50,   mse = TRUE )  # Estimate CPUE with the day-level design (not shown for brevity) # For real applications, carefully join replicate weights to interview data # cpue_rep <- est_cpue(svy_day, by = c(\"target_species\"))"},{"path":"/articles/cpue_catch.html","id":"best-practices","dir":"Articles","previous_headings":"","what":"Best Practices","title":"CPUE and Catch Estimation","text":"Use ratio--means CPUE unless trips complete Check zero-effort trips using mean--ratios Use replicate designs complex variance structures Stratify appropriately using parameter Document assumptions trip completion effort measurement Visualize uncertainty using confidence intervals","code":""},{"path":[]},{"path":"/articles/cpue_catch.html","id":"ratio-of-means-variance","dir":"Articles","previous_headings":"Statistical Notes","what":"Ratio-of-Means Variance","title":"CPUE and Catch Estimation","text":"ratio--means estimator uses delta method via survey::svyratio(): Var(R̂)≈1X‾2[Var(Y‾)+R2Var(X‾)−2RCov(Y‾,X‾)]\\text{Var}(\\hat{R}) \\approx \\frac{1}{\\bar{X}^2}\\left[\\text{Var}(\\bar{Y}) + R^2\\text{Var}(\\bar{X}) - 2R\\text{Cov}(\\bar{Y},\\bar{X})\\right] R=Y‾/X‾R = \\bar{Y}/\\bar{X} ratio, Y‾\\bar{Y} mean catch, X‾\\bar{X} mean effort.","code":""},{"path":"/articles/cpue_catch.html","id":"mean-of-ratios-variance","dir":"Articles","previous_headings":"Statistical Notes","what":"Mean-of-Ratios Variance","title":"CPUE and Catch Estimation","text":"mean--ratios estimator treats ratio observation: Var(R‾)=1nVar(Ri)\\text{Var}(\\bar{R}) = \\frac{1}{n}\\text{Var}(R_i) can unstable effort varies widely includes zeros.","code":""},{"path":"/articles/cpue_catch.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"CPUE and Catch Estimation","text":"Lumley, T. (2004). Analysis complex survey samples. Journal Statistical Software, 9(1), 1-19. Pollock, K. H., Jones, C. M., & Brown, T. L. (1994). Angler survey methods applications fisheries management. American Fisheries Society. Cochran, W. G. (1977). Sampling techniques (3rd ed.). Wiley.","code":""},{"path":"/articles/cpue_catch.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See Also","title":"CPUE and Catch Estimation","text":"vignette(\"getting-started\") - Introduction tidycreel vignette(\"effort_survey_first\") - Effort estimation ?est_cpue - CPUE estimation function documentation ?est_catch - Catch estimation function documentation","code":""},{"path":"/articles/effort_aerial.html","id":"aerial-survey-effort-estimation-in-tidycreel","dir":"Articles","previous_headings":"","what":"Aerial Survey Effort Estimation in tidycreel","title":"Aerial Survey Effort Estimation Example","text":"vignette demonstrates aerial effort estimation using day-PSU survey design optional visibility calibration adjustments.","code":""},{"path":"/articles/effort_aerial.html","id":"example-data","dir":"Articles","previous_headings":"","what":"Example Data","title":"Aerial Survey Effort Estimation Example","text":"","code":"library(tidycreel) library(dplyr)  # Minimal calendar and day design calendar <- tibble::tibble(   date = as.Date(c('2025-08-01','2025-08-02')),   day_type = c('weekday','weekend'),   month = c('Aug','Aug'),   target_sample = c(4,4),   actual_sample = c(2,2) ) svy_day <- as_day_svydesign(calendar, day_id = 'date', strata_vars = c('day_type','month'))  # Simulated aerial counts aerial_counts <- tibble::tibble(   date = rep(calendar$date, each = 2),   location = rep(c('A','B'), times = 2),   count = c(20, 15, 25, 18),   interval_minutes = 60,   total_day_minutes = 600,   visibility = c(0.8, 0.9, 0.75, 0.9),   calibration = c(1.05, 1.00, 1.10, 1.02) )"},{"path":"/articles/effort_aerial.html","id":"estimation-with-visibility-and-calibration-correction","dir":"Articles","previous_headings":"","what":"Estimation with Visibility and Calibration Correction","title":"Aerial Survey Effort Estimation Example","text":"","code":"result <- est_effort.aerial(   counts = aerial_counts,   by = c('location'),   minutes_col = 'interval_minutes',   total_minutes_col = 'total_day_minutes',   visibility_col = 'visibility',   calibration_col = 'calibration',   day_id = 'date',   svy = svy_day ) result"},{"path":"/articles/effort_aerial.html","id":"output-structure","dir":"Articles","previous_headings":"","what":"Output Structure","title":"Aerial Survey Effort Estimation Example","text":"estimate: Visibility- calibration-adjusted effort per group se: Standard error (design-based) ci_low, ci_high: Confidence interval n: Number counts per stratum method: “aerial” diagnostics: Diagnostics column (future expansion)","code":""},{"path":"/articles/effort_aerial.html","id":"notes","dir":"Articles","previous_headings":"","what":"Notes","title":"Aerial Survey Effort Estimation Example","text":"Visibility correction adjusts detection probability (e.g., observer bias, weather). Calibration factors integrate ground truth reference counts. Stratified expansion allows aggregation date, location, stratum. Variance estimation supports analytic (Taylor) replicate-weight designs via svrepdesign.","code":""},{"path":"/articles/effort_aerial.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Aerial Survey Effort Estimation Example","text":"Pollock, K. H., et al. (1994). “Estimating fishing effort aerial surveys.” Fisheries Research. Malvestuto, S. P. (1996). “Sampling creel survey design.” American Fisheries Society.","code":""},{"path":"/articles/effort_design_based.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Effort Estimation in Creel Surveys: Design-Based Methods","text":"vignette demonstrates estimate fishing effort using design-based methods creel surveys tidycreel package. covers instantaneous, progressive (roving), aerial estimators using day-PSU survey design variance.","code":""},{"path":"/articles/effort_design_based.html","id":"example-data","dir":"Articles","previous_headings":"","what":"Example Data","title":"Effort Estimation in Creel Surveys: Design-Based Methods","text":"","code":"library(tidycreel) library(tibble)  # Simulated instantaneous count data inst_counts <- tibble(   date = as.Date(c(\"2025-08-20\", \"2025-08-20\", \"2025-08-21\")),   time = c(\"12:00\", \"14:00\", \"13:00\"),   count = c(10, 12, 8),   interval_minutes = c(60, 60, 60),   location = c(\"A\", \"A\", \"B\") )"},{"path":"/articles/effort_design_based.html","id":"build-a-day-psu-design","dir":"Articles","previous_headings":"Example Data","what":"Build a day-PSU design","title":"Effort Estimation in Creel Surveys: Design-Based Methods","text":"","code":"calendar <- tibble(   date = as.Date(c(\"2025-08-20\",\"2025-08-21\")),   day_type = c(\"weekday\",\"weekday\"),   month = c(\"Aug\",\"Aug\"),   target_sample = c(4,4),   actual_sample = c(2,2) ) svy_day <- as_day_svydesign(calendar, day_id = \"date\", strata_vars = c(\"day_type\",\"month\"))"},{"path":"/articles/effort_design_based.html","id":"instantaneous-estimator-snapshot","dir":"Articles","previous_headings":"","what":"Instantaneous Estimator (snapshot)","title":"Effort Estimation in Creel Surveys: Design-Based Methods","text":"","code":"est_effort.instantaneous(inst_counts, by = c(\"location\"), minutes_col = \"interval_minutes\", day_id = \"date\", svy = svy_day)"},{"path":"/articles/effort_design_based.html","id":"progressive-roving-estimator","dir":"Articles","previous_headings":"","what":"Progressive (Roving) Estimator","title":"Effort Estimation in Creel Surveys: Design-Based Methods","text":"","code":"prog_counts <- tibble(   date = rep(as.Date(c(\"2025-08-20\",\"2025-08-21\")), each = 2),   location = rep(c(\"A\",\"B\"), times = 2),   pass_id = rep(1:2, times = 2),   count = c(5, 8, 10, 12),   route_minutes = c(45, 45, 45, 45) ) est_effort.progressive(prog_counts, by = c(\"location\"), route_minutes_col = \"route_minutes\", pass_id = \"pass_id\", day_id = \"date\", svy = svy_day)"},{"path":"/articles/effort_design_based.html","id":"aerial-estimator","dir":"Articles","previous_headings":"","what":"Aerial Estimator","title":"Effort Estimation in Creel Surveys: Design-Based Methods","text":"","code":"aerial_counts <- tibble(   date = as.Date(rep(\"2025-08-20\", 3)),   time = c(\"09:00\", \"11:00\", \"13:00\"),   count = c(15, 18, 20),   interval_minutes = c(45, 45, 45),   location = c(\"A\", \"B\", \"B\") ) est_effort.aerial(aerial_counts, by = c(\"location\"), minutes_col = \"interval_minutes\", day_id = \"date\", svy = svy_day)"},{"path":"/articles/effort_design_based.html","id":"diagnostics-and-grouping","dir":"Articles","previous_headings":"Aerial Estimator","what":"Diagnostics and Grouping","title":"Effort Estimation in Creel Surveys: Design-Based Methods","text":"Estimators handle missing grouping columns warnings compute design-based SE/CI day design. single-group cases without design, SE/CI may NA; prefer providing svy.","code":""},{"path":"/articles/effort_design_based.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Effort Estimation in Creel Surveys: Design-Based Methods","text":"Pollock, K.H., et al. (1994). Sampling estimation creel surveys. Fisheries, 19(6), 24-27. Malvestuto, S.P. (1996). Sampling recreational creel. Murphy & Willis (Eds.), Fisheries Techniques (2nd ed.).","code":""},{"path":"/articles/effort_examples.html","id":"extended-examples-for-effort-estimators","dir":"Articles","previous_headings":"","what":"Extended Examples for Effort Estimators","title":"Effort Estimation: Extended Examples","text":"vignette provides additional examples edge cases effort estimators tidycreel. demonstrates grouping, diagnostics, error handling. variance, prefer supplying day-PSU design built as_day_svydesign().","code":""},{"path":[]},{"path":[]},{"path":[]},{"path":[]},{"path":"/articles/effort_examples.html","id":"example-missing-grouping-columns","dir":"Articles","previous_headings":"","what":"Example: Missing Grouping Columns","title":"Effort Estimation: Extended Examples","text":"","code":"library(tidycreel)  # Data missing 'location' and 'shift_block' counts <- tibble(   date = as.Date(c(\"2025-08-20\", \"2025-08-21\")),   time = c(\"12:00\", \"14:00\"),   count = c(10, 12),   interval_minutes = c(60, 60) ) result <- est_effort.instantaneous(counts) print(result)"},{"path":"/articles/effort_examples.html","id":"example-single-group-seci-na","dir":"Articles","previous_headings":"","what":"Example: Single Group (SE/CI NA)","title":"Effort Estimation: Extended Examples","text":"","code":"single_group <- tibble(   date = as.Date(\"2025-08-20\"),   time = \"12:00\",   count = 10,   interval_minutes = 60 ) result <- est_effort.progressive(single_group, route_minutes_col = \"interval_minutes\") print(result)"},{"path":"/articles/effort_examples.html","id":"example-multiple-groups-seci-calculated","dir":"Articles","previous_headings":"","what":"Example: Multiple Groups (SE/CI calculated)","title":"Effort Estimation: Extended Examples","text":"","code":"multi_group <- tibble(   date = rep(as.Date(\"2025-08-20\"), 4),   time = c(\"08:00\", \"10:00\", \"12:00\", \"14:00\"),   count = c(5, 8, 10, 12),   interval_minutes = c(30, 30, 30, 30),   location = c(\"A\", \"A\", \"B\", \"B\") ) result <- est_effort.aerial(multi_group, minutes_col = \"interval_minutes\") print(result)"},{"path":"/articles/effort_examples.html","id":"example-error-handling-for-missing-columns","dir":"Articles","previous_headings":"","what":"Example: Error Handling for Missing Columns","title":"Effort Estimation: Extended Examples","text":"","code":"bad_data <- tibble(date = as.Date(\"2025-08-20\"), count = 10) try(est_effort.progressive(bad_data)) # Should throw an error (missing route_minutes)"},{"path":"/articles/effort_examples.html","id":"example-custom-grouping","dir":"Articles","previous_headings":"","what":"Example: Custom Grouping","title":"Effort Estimation: Extended Examples","text":"","code":"custom_group <- tibble(   date = rep(as.Date(\"2025-08-20\"), 3),   time = c(\"09:00\", \"11:00\", \"13:00\"),   count = c(15, 18, 20),   interval_minutes = c(45, 45, 45),   region = c(\"North\", \"South\", \"South\") ) result <- est_effort.instantaneous(custom_group, by = c(\"region\")) print(result)"},{"path":[]},{"path":"/articles/effort_survey_first.html","id":"build-a-day-psu-survey-design","dir":"Articles","previous_headings":"","what":"1) Build a day-PSU survey design","title":"Effort Estimation (Survey-First)","text":"","code":"calendar <- tibble::tibble(   date = as.Date(c(\"2025-08-20\",\"2025-08-21\")),   day_type = c(\"weekday\",\"weekday\"),   month = c(\"August\",\"August\"),   target_sample = c(4,4),   actual_sample = c(2,2) )  svy_day <- as_day_svydesign(calendar, day_id = \"date\", strata_vars = c(\"day_type\",\"month\"))"},{"path":"/articles/effort_survey_first.html","id":"instantaneous-snapshot-effort","dir":"Articles","previous_headings":"","what":"2) Instantaneous (snapshot) effort","title":"Effort Estimation (Survey-First)","text":"","code":"counts_inst <- tibble::tibble(   date = as.Date(c(\"2025-08-20\",\"2025-08-20\",\"2025-08-21\",\"2025-08-21\")),   location = c(\"A\",\"B\",\"A\",\"B\"),   count = c(10,12,8,15),   interval_minutes = 60,   total_day_minutes = 720 )  res_inst <- est_effort.instantaneous(   counts_inst,   by = c(\"location\"),   minutes_col = c(\"interval_minutes\"),   total_minutes_col = c(\"total_day_minutes\"),   day_id = \"date\",   svy = svy_day ) res_inst"},{"path":"/articles/effort_survey_first.html","id":"progressive-roving-effort","dir":"Articles","previous_headings":"","what":"3) Progressive (roving) effort","title":"Effort Estimation (Survey-First)","text":"","code":"counts_prog <- tibble::tibble(   date = rep(as.Date(c(\"2025-08-20\",\"2025-08-21\")), each = 4),   location = rep(c(\"A\",\"A\",\"B\",\"B\"), times = 2),   pass_id = rep(c(1,2,1,2), times = 2),   count = c(10,12,8,15,9,11,7,16),   route_minutes = 60 )  res_prog <- est_effort.progressive(   counts_prog,   by = c(\"location\"),   route_minutes_col = c(\"route_minutes\"),   pass_id = c(\"pass_id\"),   day_id = \"date\",   svy = svy_day ) res_prog"},{"path":"/articles/effort_survey_first.html","id":"notes","dir":"Articles","previous_headings":"","what":"Notes","title":"Effort Estimation (Survey-First)","text":"Estimates variance come day-PSU design via survey package. replicate variance, convert svy_day survey::.svrepdesign() pass estimators. Prefer defining total_minutes_col instantaneous counts; otherwise estimator sums per-count minutes warning.","code":""},{"path":"/articles/effort_survey_first.html","id":"see-also","dir":"Articles","previous_headings":"","what":"See also","title":"Effort Estimation (Survey-First)","text":"vignettes/aerial.Rmd aerial snapshot counts covariates calibration/post-stratification. ?est_effort.instantaneous, ?est_effort.progressive, ?as_day_svydesign.","code":""},{"path":"/articles/getting-started.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Getting Started with tidycreel","text":"tidycreel package provides survey-first framework creel surveys. Designs lean containers; estimation uses day-level survey designs (svydesign) built sampling calendar as_day_svydesign().","code":""},{"path":"/articles/getting-started.html","id":"survey-design-types","dir":"Articles","previous_headings":"","what":"Survey Design Types","title":"Getting Started with tidycreel","text":"tidycreel supports three main data components: Interviews (access-point roving) count tables (instantaneous/progressive). Sampling calendar (days, strata, target vs actual samples). Estimators operate day-PSU svydesign variance.","code":""},{"path":"/articles/getting-started.html","id":"loading-example-data","dir":"Articles","previous_headings":"","what":"Loading Example Data","title":"Getting Started with tidycreel","text":"package includes example datasets ’ll use throughout vignette:","code":"# Load example datasets interviews <- readr::read_csv(   system.file(\"extdata/toy_interviews.csv\", package = \"tidycreel\") ) #> Rows: 26 Columns: 17 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr  (6): interview_id, location, mode, shift_block, day_type, target_species #> dbl  (7): party_size, hours_fished, catch_total, catch_kept, catch_released,... #> lgl  (1): trip_complete #> dttm (2): time_start, time_end #> date (1): date #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. counts <- readr::read_csv(   system.file(\"extdata/toy_counts.csv\", package = \"tidycreel\") ) #> Rows: 24 Columns: 16 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr  (8): count_id, location, mode, weather_code, visibility, count_category... #> dbl  (6): anglers_count, parties_count, temperature, wind_speed, count_durat... #> dttm (1): time #> date (1): date #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message. calendar <- readr::read_csv(   system.file(\"extdata/toy_calendar.csv\", package = \"tidycreel\") ) #> Rows: 18 Columns: 11 #> ── Column specification ──────────────────────────────────────────────────────── #> Delimiter: \",\" #> chr  (6): stratum_id, day_type, season, month, shift_block, location #> dbl  (2): target_sample, actual_sample #> lgl  (2): weekend, holiday #> date (1): date #>  #> ℹ Use `spec()` to retrieve the full column specification for this data. #> ℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.  # Preview the data head(interviews) #> # A tibble: 6 × 17 #>   interview_id date       time_start          time_end            location mode  #>   <chr>        <date>     <dttm>              <dttm>              <chr>    <chr> #> 1 INT001       2024-01-01 2024-01-01 08:30:00 2024-01-01 08:45:00 Lake_A   boat  #> 2 INT001B      2024-01-01 2024-01-01 08:30:00 2024-01-01 08:45:00 Lake_B   boat  #> 3 INT002       2024-01-01 2024-01-01 09:15:00 2024-01-01 09:30:00 Lake_A   bank  #> 4 INT002B      2024-01-01 2024-01-01 09:15:00 2024-01-01 09:30:00 Lake_B   bank  #> 5 INT003       2024-01-01 2024-01-01 10:00:00 2024-01-01 10:20:00 Lake_A   boat  #> 6 INT003B      2024-01-01 2024-01-01 10:00:00 2024-01-01 10:20:00 Lake_B   boat  #> # ℹ 11 more variables: shift_block <chr>, day_type <chr>, party_size <dbl>, #> #   hours_fished <dbl>, target_species <chr>, catch_total <dbl>, #> #   catch_kept <dbl>, catch_released <dbl>, weight_total <dbl>, #> #   trip_complete <lgl>, effort_expansion <dbl> head(counts) #> # A tibble: 6 × 16 #>   count_id date       time                location mode  anglers_count #>   <chr>    <date>     <dttm>              <chr>    <chr>         <dbl> #> 1 C001     2024-01-01 2024-01-01 08:30:00 Lake_A   boat             10 #> 2 C002     2024-01-01 2024-01-01 09:15:00 Lake_A   bank              8 #> 3 C003     2024-01-01 2024-01-01 14:30:00 Lake_A   boat              6 #> 4 C004     2024-01-01 2024-01-01 15:20:00 Lake_A   bank              4 #> 5 C005     2024-01-02 2024-01-02 07:45:00 Lake_A   boat             12 #> 6 C006     2024-01-02 2024-01-02 09:30:00 Lake_A   boat              9 #> # ℹ 10 more variables: parties_count <dbl>, weather_code <chr>, #> #   temperature <dbl>, wind_speed <dbl>, visibility <chr>, #> #   count_duration <dbl>, count_category <chr>, count_value <dbl>, #> #   shift_block <chr>, day_type <chr> head(calendar) #> # A tibble: 6 × 11 #>   date       stratum_id        day_type season month weekend holiday shift_block #>   <date>     <chr>             <chr>    <chr>  <chr> <lgl>   <lgl>   <chr>       #> 1 2024-01-01 2024-01-01-weekd… weekday  winter Janu… FALSE   FALSE   morning     #> 2 2024-01-01 2024-01-01-weekd… weekday  winter Janu… FALSE   FALSE   morning     #> 3 2024-01-01 2024-01-01-weekd… weekday  winter Janu… FALSE   FALSE   afternoon   #> 4 2024-01-01 2024-01-01-weekd… weekday  winter Janu… FALSE   FALSE   afternoon   #> 5 2024-01-01 2024-01-01-weekd… weekday  winter Janu… FALSE   FALSE   evening     #> 6 2024-01-01 2024-01-01-weekd… weekday  winter Janu… FALSE   FALSE   evening     #> # ℹ 3 more variables: location <chr>, target_sample <dbl>, actual_sample <dbl>"},{"path":"/articles/getting-started.html","id":"creating-an-access-point-survey-container","dir":"Articles","previous_headings":"","what":"Creating an Access-Point Survey Container","title":"Getting Started with tidycreel","text":"Access-point designs used interviews conducted fixed locations anglers exit fishery. constructor validates stores inputs downstream estimation.","code":"# Create access-point survey design access_design <- design_access(   interviews = interviews,   calendar = calendar,   strata_vars = c(\"date\", \"shift_block\") )  # Examine the design object class(access_design) #> [1] \"access_design\" \"creel_design\"  \"list\" names(access_design) #> [1] \"design_type\"    \"interviews\"     \"calendar\"       \"locations\"      #> [5] \"strata_vars\"    \"weight_method\"  \"design_weights\" \"svy_design\"     #> [9] \"metadata\""},{"path":"/articles/getting-started.html","id":"creating-a-roving-survey-container","dir":"Articles","previous_headings":"","what":"Creating a Roving Survey Container","title":"Getting Started with tidycreel","text":"Roving designs used interviewers move locations conduct interviews. constructor stores interview/count data calendar downstream estimation.","code":"# Minimal counts table matching the validation schema counts_rov <- tibble::tibble(   count_id = c(\"C001\",\"C002\",\"C003\"),   date = as.Date(c(\"2025-08-20\",\"2025-08-20\",\"2025-08-21\")),   time = as.POSIXct(c(\"2025-08-20 09:00:00\",\"2025-08-20 11:00:00\",\"2025-08-21 10:00:00\"), tz = \"UTC\"),   location = c(\"A\",\"B\",\"A\"),   mode = c(\"boat\",\"bank\",\"boat\"),   anglers_count = c(10L, 12L, 8L),   parties_count = c(5L, 6L, 4L),   weather_code = c(\"clear\",\"clear\",\"overcast\"),   temperature = c(20, 22, 19),   wind_speed = c(5, 6, 4),   visibility = c(\"good\",\"good\",\"fair\"),   count_duration = c(60L, 60L, 60L) )  # Create roving survey design roving_design <- design_roving(   interviews = interviews,   counts = counts_rov,   calendar = calendar,   strata_vars = c(\"date\", \"shift_block\", \"location\") )  # Examine the design object class(roving_design) #> [1] \"roving_design\" \"creel_design\"  \"list\" names(roving_design) #>  [1] \"design_type\"         \"interviews\"          \"counts\"              #>  [4] \"calendar\"            \"locations\"           \"strata_vars\"         #>  [7] \"effort_method\"       \"coverage_correction\" \"design_weights\"      #> [10] \"effort_estimates\"    \"svy_design\"          \"metadata\""},{"path":"/articles/getting-started.html","id":"day-psu-designs-and-replicate-variance","dir":"Articles","previous_headings":"","what":"Day-PSU Designs and Replicate Variance","title":"Getting Started with tidycreel","text":"Build day-level survey design calendar (optionally) convert replicate-weight design robust SEs.","code":"svy_day <- as_day_svydesign(calendar, day_id = \"date\", strata_vars = c(\"day_type\", \"month\"))  # Bootstrap replicate design with 50 reps (keep small in examples) svy_rep <- survey::as.svrepdesign(svy_day, type = \"bootstrap\", replicates = 50, mse = TRUE) class(svy_rep) #> [1] \"svyrep.design\" summary(stats::weights(svy_day)) #>    Min. 1st Qu.  Median    Mean 3rd Qu.    Max.  #>   1.027   1.027   1.064   1.052   1.064   1.064"},{"path":"/articles/getting-started.html","id":"estimating-effort-survey-first","dir":"Articles","previous_headings":"","what":"Estimating Effort (Survey-First)","title":"Getting Started with tidycreel","text":"day-PSU design, estimate effort counts using survey-first estimators.","code":"# Example instantaneous counts (toy) counts_inst <- tibble::tibble(   date = as.Date(c(\"2024-01-01\",\"2024-01-01\",\"2024-01-02\",\"2024-01-02\")),   location = c(\"A\",\"B\",\"A\",\"B\"),   count = c(10,12,8,15),   interval_minutes = 60,   total_day_minutes = 600 )  est_effort(   design = svy_day,   counts = counts_inst,   method = \"instantaneous\",   by = c(\"location\") ) #> # A tibble: 2 × 8 #>   location estimate    se ci_low ci_high     n method        diagnostics #>   <chr>       <dbl> <dbl>  <dbl>   <dbl> <int> <chr>         <list>      #> 1 A            191.    NA     NA      NA    NA instantaneous <NULL>      #> 2 B            287.    NA     NA      NA    NA instantaneous <NULL>"},{"path":"/articles/getting-started.html","id":"estimating-cpue-and-catch-survey-first","dir":"Articles","previous_headings":"","what":"Estimating CPUE and Catch (Survey-First)","title":"Getting Started with tidycreel","text":"CPUE estimated design-based interview data. Prefer ratio--means form incomplete trips; use mean--ratios complete trips.","code":"# Access container; CPUE/Catch accept a svydesign/svrepdesign or a creel_design. design <- design_access(interviews = interviews, calendar = calendar)  # CPUE by species (ratio-of-means) suppressWarnings({   cpue_species <- est_cpue(design, by = c(\"target_species\"), response = \"catch_total\") }) #> ✔ Auto mode: Detected 100% complete trips (n=26). #> ℹ Using mean-of-ratios estimator (appropriate for complete trips). cpue_species #> # A tibble: 4 × 8 #>   target_species estimate    se ci_low ci_high     n method          diagnostics #>   <chr>             <dbl> <dbl>  <dbl>   <dbl> <int> <chr>           <list>      #> 1 bass               1.16 0.100  0.960    1.35    10 cpue_mean_of_r… <NULL>      #> 2 catfish            1    0      1        1        4 cpue_mean_of_r… <NULL>      #> 3 panfish            1.83 0.392  1.07     2.60     4 cpue_mean_of_r… <NULL>      #> 4 walleye            1.77 0.176  1.43     2.12     8 cpue_mean_of_r… <NULL>  # CPUE (mean-of-ratios) — for complete trips suppressWarnings({   cpue_mor <- est_cpue(design, by = c(\"target_species\"), response = \"catch_total\", mode = \"mean_of_ratios\") }) cpue_mor #> # A tibble: 4 × 8 #>   target_species estimate    se ci_low ci_high     n method          diagnostics #>   <chr>             <dbl> <dbl>  <dbl>   <dbl> <int> <chr>           <list>      #> 1 bass               1.16 0.100  0.960    1.35    10 cpue_mean_of_r… <NULL>      #> 2 catfish            1    0      1        1        4 cpue_mean_of_r… <NULL>      #> 3 panfish            1.83 0.392  1.07     2.60     4 cpue_mean_of_r… <NULL>      #> 4 walleye            1.77 0.176  1.43     2.12     8 cpue_mean_of_r… <NULL>  # Harvest totals by species suppressWarnings({   harvest_species <- est_catch(design, by = c(\"target_species\"), response = \"catch_kept\") }) harvest_species #> # A tibble: 4 × 8 #>   target_species estimate    se ci_low ci_high     n method          diagnostics #>   <chr>             <dbl> <dbl>  <dbl>   <dbl> <int> <chr>           <list>      #> 1 bass                 22  6.26  9.73     34.3    10 catch_total:ca… <NULL>      #> 2 catfish               6  2.98  0.162    11.8     4 catch_total:ca… <NULL>      #> 3 panfish              10  5.55 -0.878    20.9     4 catch_total:ca… <NULL>      #> 4 walleye              44 14.8  15.0      73.0     8 catch_total:ca… <NULL>"},{"path":[]},{"path":"/articles/getting-started.html","id":"custom-stratification","dir":"Articles","previous_headings":"Advanced Usage","what":"Custom Stratification","title":"Getting Started with tidycreel","text":"can specify custom stratification variables based survey design:","code":"## Diagnostics: check structure before design creation str(calendar) #> spc_tbl_ [18 × 11] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #>  $ date         : Date[1:18], format: \"2024-01-01\" \"2024-01-01\" ... #>  $ stratum_id   : chr [1:18] \"2024-01-01-weekday-morning\" \"2024-01-01-weekday-morning\" \"2024-01-01-weekday-afternoon\" \"2024-01-01-weekday-afternoon\" ... #>  $ day_type     : chr [1:18] \"weekday\" \"weekday\" \"weekday\" \"weekday\" ... #>  $ season       : chr [1:18] \"winter\" \"winter\" \"winter\" \"winter\" ... #>  $ month        : chr [1:18] \"January\" \"January\" \"January\" \"January\" ... #>  $ weekend      : logi [1:18] FALSE FALSE FALSE FALSE FALSE FALSE ... #>  $ holiday      : logi [1:18] FALSE FALSE FALSE FALSE FALSE FALSE ... #>  $ shift_block  : chr [1:18] \"morning\" \"morning\" \"afternoon\" \"afternoon\" ... #>  $ location     : chr [1:18] \"Lake_A\" \"Lake_B\" \"Lake_A\" \"Lake_B\" ... #>  $ target_sample: num [1:18] 10 10 10 10 5 5 10 10 10 10 ... #>  $ actual_sample: num [1:18] 8 8 12 12 3 3 10 10 9 9 ... #>  - attr(*, \"spec\")= #>   .. cols( #>   ..   date = col_date(format = \"\"), #>   ..   stratum_id = col_character(), #>   ..   day_type = col_character(), #>   ..   season = col_character(), #>   ..   month = col_character(), #>   ..   weekend = col_logical(), #>   ..   holiday = col_logical(), #>   ..   shift_block = col_character(), #>   ..   location = col_character(), #>   ..   target_sample = col_double(), #>   ..   actual_sample = col_double() #>   .. ) #>  - attr(*, \"problems\")=<externalptr> str(interviews) #> spc_tbl_ [26 × 17] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #>  $ interview_id    : chr [1:26] \"INT001\" \"INT001B\" \"INT002\" \"INT002B\" ... #>  $ date            : Date[1:26], format: \"2024-01-01\" \"2024-01-01\" ... #>  $ time_start      : POSIXct[1:26], format: \"2024-01-01 08:30:00\" \"2024-01-01 08:30:00\" ... #>  $ time_end        : POSIXct[1:26], format: \"2024-01-01 08:45:00\" \"2024-01-01 08:45:00\" ... #>  $ location        : chr [1:26] \"Lake_A\" \"Lake_B\" \"Lake_A\" \"Lake_B\" ... #>  $ mode            : chr [1:26] \"boat\" \"boat\" \"bank\" \"bank\" ... #>  $ shift_block     : chr [1:26] \"morning\" \"morning\" \"morning\" \"morning\" ... #>  $ day_type        : chr [1:26] \"weekday\" \"weekday\" \"weekday\" \"weekday\" ... #>  $ party_size      : num [1:26] 2 2 1 1 3 3 2 2 1 1 ... #>  $ hours_fished    : num [1:26] 4.5 4.5 3 3 6 6 2.5 2.5 1.5 1.5 ... #>  $ target_species  : chr [1:26] \"walleye\" \"walleye\" \"bass\" \"bass\" ... #>  $ catch_total     : num [1:26] 5 5 2 2 8 8 3 3 4 4 ... #>  $ catch_kept      : num [1:26] 3 3 1 1 5 5 2 2 4 4 ... #>  $ catch_released  : num [1:26] 2 2 1 1 3 3 1 1 0 0 ... #>  $ weight_total    : num [1:26] 2.5 2.5 1.2 1.2 4.1 4.1 1.8 1.8 0.8 0.8 ... #>  $ trip_complete   : logi [1:26] TRUE TRUE TRUE TRUE TRUE TRUE ... #>  $ effort_expansion: num [1:26] 1 1 1 1 1 1 1 1 1 1 ... #>  - attr(*, \"spec\")= #>   .. cols( #>   ..   interview_id = col_character(), #>   ..   date = col_date(format = \"\"), #>   ..   time_start = col_datetime(format = \"\"), #>   ..   time_end = col_datetime(format = \"\"), #>   ..   location = col_character(), #>   ..   mode = col_character(), #>   ..   shift_block = col_character(), #>   ..   day_type = col_character(), #>   ..   party_size = col_double(), #>   ..   hours_fished = col_double(), #>   ..   target_species = col_character(), #>   ..   catch_total = col_double(), #>   ..   catch_kept = col_double(), #>   ..   catch_released = col_double(), #>   ..   weight_total = col_double(), #>   ..   trip_complete = col_logical(), #>   ..   effort_expansion = col_double() #>   .. ) #>  - attr(*, \"problems\")=<externalptr> # Create design with custom stratification custom_design <- design_access(   interviews = interviews,   calendar = calendar,   strata_vars = c(\"date\") )  # Check stratification str(custom_design$interviews) #> spc_tbl_ [26 × 17] (S3: spec_tbl_df/tbl_df/tbl/data.frame) #>  $ interview_id    : chr [1:26] \"INT001\" \"INT001B\" \"INT002\" \"INT002B\" ... #>  $ date            : Date[1:26], format: \"2024-01-01\" \"2024-01-01\" ... #>  $ time_start      : POSIXct[1:26], format: \"2024-01-01 08:30:00\" \"2024-01-01 08:30:00\" ... #>  $ time_end        : POSIXct[1:26], format: \"2024-01-01 08:45:00\" \"2024-01-01 08:45:00\" ... #>  $ location        : chr [1:26] \"Lake_A\" \"Lake_B\" \"Lake_A\" \"Lake_B\" ... #>  $ mode            : chr [1:26] \"boat\" \"boat\" \"bank\" \"bank\" ... #>  $ shift_block     : chr [1:26] \"morning\" \"morning\" \"morning\" \"morning\" ... #>  $ day_type        : chr [1:26] \"weekday\" \"weekday\" \"weekday\" \"weekday\" ... #>  $ party_size      : num [1:26] 2 2 1 1 3 3 2 2 1 1 ... #>  $ hours_fished    : num [1:26] 4.5 4.5 3 3 6 6 2.5 2.5 1.5 1.5 ... #>  $ target_species  : chr [1:26] \"walleye\" \"walleye\" \"bass\" \"bass\" ... #>  $ catch_total     : num [1:26] 5 5 2 2 8 8 3 3 4 4 ... #>  $ catch_kept      : num [1:26] 3 3 1 1 5 5 2 2 4 4 ... #>  $ catch_released  : num [1:26] 2 2 1 1 3 3 1 1 0 0 ... #>  $ weight_total    : num [1:26] 2.5 2.5 1.2 1.2 4.1 4.1 1.8 1.8 0.8 0.8 ... #>  $ trip_complete   : logi [1:26] TRUE TRUE TRUE TRUE TRUE TRUE ... #>  $ effort_expansion: num [1:26] 1 1 1 1 1 1 1 1 1 1 ... #>  - attr(*, \"spec\")= #>   .. cols( #>   ..   interview_id = col_character(), #>   ..   date = col_date(format = \"\"), #>   ..   time_start = col_datetime(format = \"\"), #>   ..   time_end = col_datetime(format = \"\"), #>   ..   location = col_character(), #>   ..   mode = col_character(), #>   ..   shift_block = col_character(), #>   ..   day_type = col_character(), #>   ..   party_size = col_double(), #>   ..   hours_fished = col_double(), #>   ..   target_species = col_character(), #>   ..   catch_total = col_double(), #>   ..   catch_kept = col_double(), #>   ..   catch_released = col_double(), #>   ..   weight_total = col_double(), #>   ..   trip_complete = col_logical(), #>   ..   effort_expansion = col_double() #>   .. ) #>  - attr(*, \"problems\")=<externalptr> dplyr::count(custom_design$interviews, date, shift_block) #> # A tibble: 9 × 3 #>   date       shift_block     n #>   <date>     <chr>       <int> #> 1 2024-01-01 afternoon       4 #> 2 2024-01-01 evening         2 #> 3 2024-01-01 morning         6 #> 4 2024-01-02 afternoon       2 #> 5 2024-01-02 evening         2 #> 6 2024-01-02 morning         4 #> 7 2024-01-06 afternoon       2 #> 8 2024-01-06 evening         2 #> 9 2024-01-06 morning         2"},{"path":"/articles/getting-started.html","id":"handling-missing-data","dir":"Articles","previous_headings":"Advanced Usage","what":"Handling Missing Data","title":"Getting Started with tidycreel","text":"validation functions catch missing required columns:","code":"# This will produce an error due to missing columns tryCatch({   bad_interviews <- interviews[, -1]  # Remove first column   design_access(bad_interviews, calendar) }, error = function(e) {   message(\"Validation error: \", e$message) }) #> Validation error: Missing required columns: interview_id"},{"path":"/articles/getting-started.html","id":"next-steps","dir":"Articles","previous_headings":"","what":"Next Steps","title":"Getting Started with tidycreel","text":"Now lean survey containers day-PSU design, can: Estimate effort CPUE survey-first estimators svydesign Calculate population totals appropriate variance estimates Perform hypothesis tests comparing different groups time periods Generate reports confidence intervals uncertainty bounds See package documentation advanced features estimation functions.","code":""},{"path":"/articles/getting-started.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Getting Started with tidycreel","text":"Pollock, K. H., Jones, C. M., & Brown, T. L. (1994). Angler survey methods applications fisheries management. American Fisheries Society. Malvestuto, S. P. (1996). Sampling recreational creel. Murphy, B. R. & Willis, D. W. (Eds.), Fisheries techniques (2nd ed., pp. 591-623). American Fisheries Society.","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Ratio Estimators","text":"One common questions creel survey analysis : “use ratio--means mean--ratios estimate catch rate?” vignette answers question : Decision rules based survey design type Simulation demonstrations showing estimator performance Practical guidance variance estimation Clear examples using tidycreel","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"quick-answer-decision-tree","dir":"Articles","previous_headings":"","what":"Quick Answer: Decision Tree","title":"Ratio Estimators","text":"","code":"# Code code example ┌─────────────────────────────────────────────┐ │   What type of interviews do you have?      │ └─────────────────┬───────────────────────────┘                   │         ┌─────────┴───────────┐         │                     │     ┌───▼──────┐          ┌───▼────────┐     │ ACCESS   │          │ ROVING     │     │(Complete │          │(Incomplete │     │ trips)   │          │  trips)    │     └───┬──────┘          └───┬────────┘         │                     │         │                     │     ┌───▼─────────────────┐   │     │ Use RATIO-OF-MEANS  │   │     │  R₁ = Σcatch/Σeffort│   │     │                     │   │     │ Why? Each angler    │   │     │ has equal sampling  │   │     │ probability.        │   │     │                     │   │     │ ✓ Unbiased          │   │     │ ✓ Finite variance   │   │     └─────────────────────┘   │                               │                   ┌───────────▼────────────────┐                   │ Use MEAN-OF-RATIOS         │                   │  R₂ = (1/n)Σ(catch/effort) │                   │                            │                   │ IMPORTANT: Truncate short  │                   │ trips (< 20-30 minutes)    │                   │                            │                   │ Why? Sampling probability  │                   │ ∝ trip length. R₁ would    │                   │ give biased estimate.      │                   │                            │                   │ ⚠ Avoid if bag limits      │                   │   are low & easily obtained│                   └────────────────────────────┘"},{"path":"/articles/ratio-estimators-guide.html","id":"theoretical-background","dir":"Articles","previous_headings":"","what":"Theoretical Background","title":"Ratio Estimators","text":"diving simulations practical examples, let’s establish statistical foundation estimator choice matters. key understanding sampling probabilities differ survey designs. Sampling Design: complete - Interviews conducted anglers complete trips equal probability - anglers equal probability interviewed - P(interviewed) = constant, regardless trip length Appropriate Estimator: Ratio--Means (R₁) R̂1=∑j=1nCj*∑j=1nLj*\\hat{R}_1 = \\frac{\\sum_{j=1}^{n} C_j^*}{\\sum_{j=1}^{n} L_j^*} Cj*C_j^* = total catch completed trip Lj*L_j^* = total trip length completion. Expected Value: E(R̂1)≈Total CatchTotal EffortE(\\hat{R}_1) \\approx \\frac{\\text{Total Catch}}{\\text{Total Effort}} ✓ want total catch estimation! Sampling Design: - Interviews conducted fishing trips ∝ trip length - Sampling probability ∝ trip length - Longer trips likely encountered Appropriate Estimator: Mean--Ratios (R₂) Truncation R̂2=1n∑j=1nCjLj\\hat{R}_2 = \\frac{1}{n} \\sum_{j=1}^{n} \\frac{C_j}{L_j} CjC_j = catch time interview LjL_j = elapsed time interview. truncation: include interviews Lj>LminL_j > L_{min} (typically 20-30 minutes). Expected Value: E(R̂2)≈Total CatchTotal EffortE(\\hat{R}_2) \\approx \\frac{\\text{Total Catch}}{\\text{Total Effort}} ✓ Correct roving interviews! use R₁ roving? ratio--means roving interviews : E(R̂1roving)≈∑Lj*2⋅(Cj*/Lj*)∑Lj*2E(\\hat{R}_1^{roving}) \\approx \\frac{\\sum L_j^{*2} \\cdot (C_j^*/L_j^*)}{\\sum L_j^{*2}} weighted average weights = (trip length)², estimate population catch rate!","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"access-point-complete-trip-interviews","dir":"Articles","previous_headings":"","what":"Access Point (Complete Trip) Interviews","title":"Ratio Estimators","text":"Sampling Design: complete - Interviews conducted anglers complete trips equal probability - anglers equal probability interviewed - P(interviewed) = constant, regardless trip length Appropriate Estimator: Ratio--Means (R₁) R̂1=∑j=1nCj*∑j=1nLj*\\hat{R}_1 = \\frac{\\sum_{j=1}^{n} C_j^*}{\\sum_{j=1}^{n} L_j^*} Cj*C_j^* = total catch completed trip Lj*L_j^* = total trip length completion. Expected Value: E(R̂1)≈Total CatchTotal EffortE(\\hat{R}_1) \\approx \\frac{\\text{Total Catch}}{\\text{Total Effort}} ✓ want total catch estimation!","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"roving-incomplete-trip-interviews","dir":"Articles","previous_headings":"","what":"Roving (Incomplete Trip) Interviews","title":"Ratio Estimators","text":"Sampling Design: - Interviews conducted fishing trips ∝ trip length - Sampling probability ∝ trip length - Longer trips likely encountered Appropriate Estimator: Mean--Ratios (R₂) Truncation R̂2=1n∑j=1nCjLj\\hat{R}_2 = \\frac{1}{n} \\sum_{j=1}^{n} \\frac{C_j}{L_j} CjC_j = catch time interview LjL_j = elapsed time interview. truncation: include interviews Lj>LminL_j > L_{min} (typically 20-30 minutes). Expected Value: E(R̂2)≈Total CatchTotal EffortE(\\hat{R}_2) \\approx \\frac{\\text{Total Catch}}{\\text{Total Effort}} ✓ Correct roving interviews! use R₁ roving? ratio--means roving interviews : E(R̂1roving)≈∑Lj*2⋅(Cj*/Lj*)∑Lj*2E(\\hat{R}_1^{roving}) \\approx \\frac{\\sum L_j^{*2} \\cdot (C_j^*/L_j^*)}{\\sum L_j^{*2}} weighted average weights = (trip length)², estimate population catch rate!","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"handling-mixed-complete-and-incomplete-trips","dir":"Articles","previous_headings":"","what":"Handling Mixed Complete and Incomplete Trips","title":"Ratio Estimators","text":"matters. Real creel surveys often produce mix completed (access-point) incomplete (roving/intercept) interviews. Estimator choice must follow inclusion probability, just trip status, avoid bias. inclusion probability differs design (equal-probability access points vs. length-biased roving), pooling interviews applying single estimator can introduce bias. Treat designs according sampling properties. Treat complete incomplete interviews two strata, combine effort weighting: Complete trips (access point): use Ratio--Means (R₁ = ΣC / ΣE). Incomplete trips (roving): use Mean--Ratios (R₂ = (1/n) Σ(C/E)) truncation short trips (e.g., < 20–30 min). Effort-weighted combination: R̂combined=R1Ecomplete+R2EincompleteEcomplete+Eincomplete \\hat{R}_{\\text{combined}} = \\frac{R_1 E_{\\text{complete}} + R_2 E_{\\text{incomplete}}}{E_{\\text{complete}} + E_{\\text{incomplete}}} can estimate selection/inclusion probabilities (e.g., model trip completeness roving intercept likelihood), use weighted ratio: R̂weighted=∑iwiCi∑iwiEi,wi=1/P(selecti). \\hat{R}_{\\text{weighted}} = \\frac{\\sum_i w_i C_i}{\\sum_i w_i E_i}, \\quad w_i = 1 / P(\\text{select}_i). useful hybrid designs sampling varies predictably across modes, times, sites. Compute: () R₁ complete , (b) R₂ incomplete (truncation), (c) combined estimator. differences small (e.g., < 5–10%), pooling assumptions may reasonable; document . apply R₁ unfiltered roving data — biased high due length-biased sampling. apply R₂ complete trips — bias direction depends effort variability. Always truncate short incomplete trips stabilize R₂ reduce small-denominator issues. bag limits frequently hit, cautious R₂ (ceiling effects can distort ratios). Estimate SEs stratum appropriate formula (delta-method R₁; sample variance ratios R₂), combine via delta-method using effort-weight combination .","code":"# R code example complete <- data %>% dplyr::filter(trip_complete == TRUE) incomplete <- data %>% dplyr::filter(trip_complete == FALSE, trip_length >= 0.5)  # 0.5 h = 30 min  r1 <- sum(complete$catch) / sum(complete$effort) r2 <- mean(incomplete$catch / incomplete$effort)  E1 <- sum(complete$effort) E2 <- sum(incomplete$effort)  R_combined <- (r1 * E1 + r2 * E2) / (E1 + E2)"},{"path":"/articles/ratio-estimators-guide.html","id":"principle","dir":"Articles","previous_headings":"","what":"Principle","title":"Ratio Estimators","text":"inclusion probability differs design (equal-probability access points vs. length-biased roving), pooling interviews applying single estimator can introduce bias. Treat designs according sampling properties.","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"separate-estimation-recommended","dir":"Articles","previous_headings":"","what":"1️⃣ Separate Estimation (Recommended)","title":"Ratio Estimators","text":"Treat complete incomplete interviews two strata, combine effort weighting: Complete trips (access point): use Ratio--Means (R₁ = ΣC / ΣE). Incomplete trips (roving): use Mean--Ratios (R₂ = (1/n) Σ(C/E)) truncation short trips (e.g., < 20–30 min). Effort-weighted combination: R̂combined=R1Ecomplete+R2EincompleteEcomplete+Eincomplete \\hat{R}_{\\text{combined}} = \\frac{R_1 E_{\\text{complete}} + R_2 E_{\\text{incomplete}}}{E_{\\text{complete}} + E_{\\text{incomplete}}}","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"model-based-weighting-optional","dir":"Articles","previous_headings":"","what":"2️⃣ Model-Based Weighting (optional)","title":"Ratio Estimators","text":"can estimate selection/inclusion probabilities (e.g., model trip completeness roving intercept likelihood), use weighted ratio: R̂weighted=∑iwiCi∑iwiEi,wi=1/P(selecti). \\hat{R}_{\\text{weighted}} = \\frac{\\sum_i w_i C_i}{\\sum_i w_i E_i}, \\quad w_i = 1 / P(\\text{select}_i). useful hybrid designs sampling varies predictably across modes, times, sites.","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"sensitivity-analysis","dir":"Articles","previous_headings":"","what":"3️⃣ Sensitivity Analysis","title":"Ratio Estimators","text":"Compute: () R₁ complete , (b) R₂ incomplete (truncation), (c) combined estimator. differences small (e.g., < 5–10%), pooling assumptions may reasonable; document .","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"cautions","dir":"Articles","previous_headings":"","what":"Cautions","title":"Ratio Estimators","text":"apply R₁ unfiltered roving data — biased high due length-biased sampling. apply R₂ complete trips — bias direction depends effort variability. Always truncate short incomplete trips stabilize R₂ reduce small-denominator issues. bag limits frequently hit, cautious R₂ (ceiling effects can distort ratios).","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"implementation-sketch-r","dir":"Articles","previous_headings":"","what":"Implementation sketch (R)","title":"Ratio Estimators","text":"","code":"# R code example complete <- data %>% dplyr::filter(trip_complete == TRUE) incomplete <- data %>% dplyr::filter(trip_complete == FALSE, trip_length >= 0.5)  # 0.5 h = 30 min  r1 <- sum(complete$catch) / sum(complete$effort) r2 <- mean(incomplete$catch / incomplete$effort)  E1 <- sum(complete$effort) E2 <- sum(incomplete$effort)  R_combined <- (r1 * E1 + r2 * E2) / (E1 + E2)"},{"path":"/articles/ratio-estimators-guide.html","id":"variance-note","dir":"Articles","previous_headings":"","what":"Variance note","title":"Ratio Estimators","text":"Estimate SEs stratum appropriate formula (delta-method R₁; sample variance ratios R₂), combine via delta-method using effort-weight combination .","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"simulation-study","dir":"Articles","previous_headings":"","what":"Simulation Study","title":"Ratio Estimators","text":"theoretical results show estimator choice matters. large bias practice? truncation really help? Let’s demonstrate principles simulation, following approach Rasmussen et al. (1998) Pollock et al. (1997). ’ll simulate realistic fishing scenario compare estimator performance. Simulate traditional access point creel interview anglers finish. Now simulate roving interviews anglers intercepted trips. Run 1000 replications assess bias precision. Access Point Design: Estimator Performance estimator mean bias pct_bias se rmse r1 1.9953 -0.0069 -0.3452 0.4276 0.4274 r2 2.0081 0.0059 0.2955 0.4081 0.4079 Key Finding: access interviews, estimators approximately unbiased, ratio--means (R₁) typically slightly lower variance.  Access Point Design: Distribution Estimates. estimators center true value (dashed line), demonstrating unbiasedness. ratio--means (R₁) shows slightly tighter clustering, indicating lower variance. Roving Design: Estimator Performance estimator truncation mean bias pct_bias rmse Ratio Means truncation 1.9957 -0.0209 -1.0341 0.4985 Mean Ratios truncation 1.9909 -0.0256 -1.2698 0.4629 Ratio Means 30-min truncation 1.9966 -0.0199 -0.9880 0.5041 Mean Ratios 30-min truncation 2.0092 -0.0073 -0.3629 0.4400 Key Findings: R₁ (ratio--means) BIASED roving interviews 1. R₁ (ratio--means) BIASED roving interviews - estimate population catch rate R₂ (mean--ratios) without truncation approximately unbiased high variance 2. R₂ (mean--ratios) without truncation approximately unbiased high variance (unstable) R₂ truncation approximately unbiased lower variance RECOMMENDED 3. R₂ truncation approximately unbiased lower variance ✓ RECOMMENDED  Roving Design: Effect Truncation. R₁ (ratio--means) biased roving surveys regardless truncation. R₂ (mean--ratios) unbiased high variance without truncation; truncation reduces variance maintaining unbiasedness.","code":"# R code example #' Simulate a day of fishing with known parameters #' #' @param n_anglers Number of anglers fishing during the day #' @param mean_trip_hours Mean trip length (hours) #' @param mean_catch_rate Mean catch per hour (Poisson rate parameter) #' @param day_length_hours Length of fishing day #' @return List with population parameters and individual angler data simulate_fishing_day <- function(n_anglers = 100,                                  mean_trip_hours = 4,                                  mean_catch_rate = 2,                                  day_length_hours = 12) {    # Each angler's true catch rate (gamma-distributed for heterogeneity)   # Shape = 1, rate = 1/mean gives exponential with specified mean   # This creates variation in angler skill/success   alpha <- 1   beta <- 1 / mean_catch_rate   catch_rates <- rgamma(n_anglers, shape = alpha, rate = beta)    # Trip lengths (gamma-distributed)   shape_trip <- 4  # Controls variability   rate_trip <- shape_trip / mean_trip_hours   trip_lengths <- rgamma(n_anglers, shape = shape_trip, rate = rate_trip)   trip_lengths <- pmin(trip_lengths, day_length_hours)  # Can't exceed day length    # Generate catches for each angler (Poisson process)   # Expected catch = catch_rate * trip_length   completed_catch <- rpois(n_anglers, lambda = catch_rates * trip_lengths)    # True population parameters   total_effort <- sum(trip_lengths)   total_catch <- sum(completed_catch)   true_catch_rate <- total_catch / total_effort    # Return angler-level data   tibble(     angler_id = 1:n_anglers,     catch_rate_true = catch_rates,     trip_length = trip_lengths,     completed_catch = completed_catch,     true_population_rate = true_catch_rate,     total_effort = total_effort,     total_catch = total_catch   ) }  # Example fishing_day <- simulate_fishing_day(n_anglers = 100) head(fishing_day) # Code code example # A tibble: 6 × 7   angler_id catch_rate_true trip_length completed_catch true_population_rate       <int>           <dbl>       <dbl>           <int>                <dbl> 1         1           2.00         4.78               7                 2.15 2         2           2.26         1.56               5                 2.15 3         3           0.851        4.74               4                 2.15 4         4           1.03         6.06               5                 2.15 5         5           6.96         4.52              35                 2.15 6         6           0.627        5.59               3                 2.15 # ℹ 2 more variables: total_effort <dbl>, total_catch <int> # R code example # Summary of true population parameters cat(\"True Population Parameters:\\n\") # Code code example True Population Parameters: # R code example cat(\"  Total anglers:\", nrow(fishing_day), \"\\n\") # Code code example   Total anglers: 100 # R code example cat(\"  Total effort:\", round(fishing_day$total_effort[1], 1), \"hours\\n\") # Code code example   Total effort: 391.8 hours # R code example cat(\"  Total catch:\", fishing_day$total_catch[1], \"fish\\n\") # Code code example   Total catch: 844 fish # R code example cat(\"  True catch rate:\", round(fishing_day$true_population_rate[1], 3), \"fish/hour\\n\") # Code code example   True catch rate: 2.154 fish/hour # R code example #' Simulate access point interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Number of interviews to conduct #' @return Tibble with interview data sample_access_interviews <- function(fishing_day, n_interviews = 30) {   # Simple random sample (equal probability)   sampled <- fishing_day %>%     sample_n(size = min(n_interviews, nrow(fishing_day)), replace = FALSE) %>%     select(angler_id, completed_catch, trip_length, true_population_rate)    sampled }  # Single realization access_sample <- sample_access_interviews(fishing_day, n_interviews = 30) head(access_sample) # Code code example # A tibble: 6 × 4   angler_id completed_catch trip_length true_population_rate       <int>           <int>       <dbl>                <dbl> 1         1               7        4.78                 2.15 2        69               4        5.05                 2.15 3        79              14        6.27                 2.15 4        19               5        6.75                 2.15 5        12               1        4.72                 2.15 6        64               0        5.88                 2.15 # R code example # Calculate both estimators calculate_estimates <- function(interviews, truncate_minutes = NULL) {    # Apply truncation if specified (for roving surveys)   if (!is.null(truncate_minutes)) {     interviews <- interviews %>%       filter(trip_length >= truncate_minutes / 60)   }    n <- nrow(interviews)    # Ratio-of-means   r1 <- sum(interviews$completed_catch) / sum(interviews$trip_length)    # Mean-of-ratios   r2 <- mean(interviews$completed_catch / interviews$trip_length)    # Variance estimates (simplified)   # For R₁: use delta method (Taylor series approximation)   # Var(R₁) ≈ (1/n·E̅²) · Var(C - R₁·E)   # where residual = catch - estimated_rate × effort   r <- interviews$completed_catch   e <- interviews$trip_length   r_bar <- mean(r)   e_bar <- mean(e)   var_r1 <- (1 / (n * e_bar^2)) * var(r - r1 * e)   se_r1 <- sqrt(var_r1)    # For R₂: simple variance of the ratios   ratios <- interviews$completed_catch / interviews$trip_length   var_r2 <- var(ratios) / n   se_r2 <- sqrt(var_r2)    tibble(     n = n,     ratio_of_means = r1,     mean_of_ratios = r2,     se_r1 = se_r1,     se_r2 = se_r2,     true_rate = interviews$true_population_rate[1]   ) }  access_results <- calculate_estimates(access_sample) access_results # Code code example # A tibble: 1 × 6       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> 1    30           2.04           2.41 0.401 0.463      2.15 # R code example #' Simulate roving interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Target number of interviews #' @return Tibble with incomplete trip interview data sample_roving_interviews <- function(fishing_day, n_interviews = 30) {    # Length-biased sampling: probability of encounter ∝ trip duration   # P(interview angler i) = L_i / Σ L_j (normalized by total effort)   # Longer trips have higher chance of being encountered during roving   prob_intercept <- fishing_day$trip_length / sum(fishing_day$trip_length)    # Sample with probability proportional to size   sampled_indices <- sample(     1:nrow(fishing_day),     size = min(n_interviews, nrow(fishing_day)),     replace = FALSE,     prob = prob_intercept   )    sampled <- fishing_day[sampled_indices, ]    # For each intercepted angler, determine interview time   # Uniform on [0, trip_length] (on average, intercepted at midpoint)   sampled <- sampled %>%     mutate(       # Time fished when interviewed (uniform on [0, trip_length])       # On average, anglers are intercepted at midpoint of their trip       time_at_interview = runif(n(), min = 0, max = trip_length),        # Catch at interview time (incomplete trip)       # Poisson process: E[catch | time_t] = λ × t       # where λ = angler's true catch rate, t = time fished so far       catch_at_interview = rpois(n(), lambda = catch_rate_true * time_at_interview)     ) %>%     select(angler_id, catch_at_interview, time_at_interview,            completed_catch, trip_length, true_population_rate)    sampled }  roving_sample <- sample_roving_interviews(fishing_day, n_interviews = 30) head(roving_sample) # Code code example # A tibble: 6 × 6   angler_id catch_at_interview time_at_interview completed_catch trip_length       <int>              <int>             <dbl>           <int>       <dbl> 1        27                  1             2.57                2        5.27 2        37                  4             1.46               13        2.99 3        81                  0             0.326               3        3.86 4        32                  1             2.30                8        5.76 5        97                  6             3.54               10        4.81 6        28                  4             2.58                5        2.72 # ℹ 1 more variable: true_population_rate <dbl> # R code example # For roving, use incomplete data # Note: calculate_estimates() expects columns named 'completed_catch' and 'trip_length' roving_data <- roving_sample %>%   select(angler_id,          completed_catch = catch_at_interview,          trip_length = time_at_interview,          true_population_rate)  # No truncation roving_no_trunc <- calculate_estimates(roving_data, truncate_minutes = NULL)  # With truncation (30 minutes) roving_with_trunc <- calculate_estimates(roving_data, truncate_minutes = 30)  bind_rows(   roving_no_trunc %>% mutate(truncation = \"None\"),   roving_with_trunc %>% mutate(truncation = \"30 min\") ) # Code code example # A tibble: 2 × 7       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate truncation   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> <chr> 1    30           1.98           1.77 0.329 0.289      2.15 None 2    27           1.97           1.67 0.334 0.281      2.15 30 min # R code example run_simulation <- function(n_reps = 1000,                            n_anglers = 100,                            n_interviews = 30,                            interview_type = c(\"access\", \"roving\")) {    interview_type <- match.arg(interview_type)    results <- map_dfr(1:n_reps, function(rep) {     # Generate population     day <- simulate_fishing_day(n_anglers = n_anglers)     true_rate <- day$true_population_rate[1]      # Sample based on design     if (interview_type == \"access\") {       sample_data <- sample_access_interviews(day, n_interviews)       sample_data <- sample_data %>%         rename(catch = completed_catch, effort = trip_length)     } else {       sample_data <- sample_roving_interviews(day, n_interviews) %>%         rename(catch = catch_at_interview, effort = time_at_interview)     }      # Calculate estimators     # No truncation     r1_no <- sum(sample_data$catch) / sum(sample_data$effort)     r2_no <- mean(sample_data$catch / sample_data$effort)      # With truncation (30 min = 0.5 hr)     trunc_data <- sample_data %>% filter(effort >= 0.5)     if (nrow(trunc_data) > 0) {       r1_trunc <- sum(trunc_data$catch) / sum(trunc_data$effort)       r2_trunc <- mean(trunc_data$catch / trunc_data$effort)     } else {       r1_trunc <- NA       r2_trunc <- NA     }      tibble(       rep = rep,       true_rate = true_rate,       r1_no_trunc = r1_no,       r2_no_trunc = r2_no,       r1_with_trunc = r1_trunc,       r2_with_trunc = r2_trunc,       n_interviews = n_interviews,       n_after_trunc = nrow(trunc_data)     )   })    results %>%     mutate(design = interview_type) }  # Run simulations access_mc <- run_simulation(n_reps = 1000, interview_type = \"access\") roving_mc <- run_simulation(n_reps = 1000, interview_type = \"roving\") # R code example # Summary statistics access_summary <- access_mc %>%   summarise(     true_rate = mean(true_rate),      # Ratio of means (R₁)     r1_mean = mean(r1_no_trunc),     r1_bias = mean(r1_no_trunc - true_rate),     r1_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate),     r1_rmse = sqrt(mean((r1_no_trunc - true_rate)^2)),     r1_se = sd(r1_no_trunc),      # Mean of ratios (R₂)     r2_mean = mean(r2_no_trunc),     r2_bias = mean(r2_no_trunc - true_rate),     r2_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate),     r2_rmse = sqrt(mean((r2_no_trunc - true_rate)^2)),     r2_se = sd(r2_no_trunc)   )  access_summary %>%   pivot_longer(cols = -true_rate, names_to = c(\"estimator\", \"metric\"), names_sep = \"_\", values_to = \"value\", names_repair = \"minimal\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   select(estimator, mean, bias, pct, se, rmse) %>%   rename(pct_bias = pct) %>%   knitr::kable(digits = 4, caption = \"Access Point Design: Estimator Performance\") # R code example access_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc) %>%   pivot_longer(cols = c(r1_no_trunc, r2_no_trunc),                names_to = \"estimator\",                values_to = \"estimate\") %>%   mutate(     estimator = recode(estimator,       r1_no_trunc = \"Ratio of Means (R1)\",       r2_no_trunc = \"Mean of Ratios (R2)\"     ),     # NEW: HTML subscripts for facet strips     estimator_lab = recode(estimator,       \"Ratio of Means (R1)\" = \"R<sub>1<\/sub> (Ratio of Means)\",       \"Mean of Ratios (R2)\" = \"R<sub>2<\/sub> (Mean of Ratios)\"     )   ) %>%   ggplot(aes(x = estimate, fill = estimator)) +   geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +   geom_vline(aes(xintercept = mean(true_rate)), linetype = \"dashed\", size = 1) +   facet_wrap(~ estimator_lab, ncol = 1) +   labs(     title = \"Access Point Design: Sampling Distribution\",     subtitle = \"Dashed line = true population catch rate\",     x = \"Estimated Catch Rate (fish/hour)\",     y = \"Frequency\"   ) +   theme_minimal() +   theme(     legend.position = \"none\",     # NEW: render HTML in strip labels     strip.text = ggtext::element_markdown()   ) # R code example # Summary statistics roving_summary <- roving_mc %>%   summarise(     true_rate = mean(true_rate),      # R1 no truncation     r1_no_mean = mean(r1_no_trunc, na.rm = TRUE),     r1_no_bias = mean(r1_no_trunc - true_rate, na.rm = TRUE),     r1_no_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_no_rmse = sqrt(mean((r1_no_trunc - true_rate)^2, na.rm = TRUE)),      # R2 no truncation     r2_no_mean = mean(r2_no_trunc, na.rm = TRUE),     r2_no_bias = mean(r2_no_trunc - true_rate, na.rm = TRUE),     r2_no_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_no_rmse = sqrt(mean((r2_no_trunc - true_rate)^2, na.rm = TRUE)),      # R1 with truncation     r1_trunc_mean = mean(r1_with_trunc, na.rm = TRUE),     r1_trunc_bias = mean(r1_with_trunc - true_rate, na.rm = TRUE),     r1_trunc_pct_bias = 100 * mean((r1_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_trunc_rmse = sqrt(mean((r1_with_trunc - true_rate)^2, na.rm = TRUE)),      # R2 with truncation     r2_trunc_mean = mean(r2_with_trunc, na.rm = TRUE),     r2_trunc_bias = mean(r2_with_trunc - true_rate, na.rm = TRUE),     r2_trunc_pct_bias = 100 * mean((r2_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_trunc_rmse = sqrt(mean((r2_with_trunc - true_rate)^2, na.rm = TRUE))   )  roving_summary %>%   pivot_longer(cols = -true_rate,                names_to = c(\"estimator\", \"truncation\", \"metric\"),                names_pattern = \"([^_]+)_([^_]+)_(.*)\",                values_to = \"value\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   mutate(estimator = recode(estimator, r1 = \"Ratio of Means\", r2 = \"Mean of Ratios\"),          truncation = recode(truncation, no = \"No truncation\", trunc = \"30-min truncation\")) %>%   select(estimator, truncation, mean, bias, pct_bias, rmse) %>%   knitr::kable(digits = 4, caption = \"Roving Design: Estimator Performance\") # R code example  labels <- c(   \"r1\" = \"italic(R)[1]~'(Ratio~of~Means)'\",   \"r2\" = \"italic(R)[2]~'(Mean~of~Ratios)'\" )   roving_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc, r1_with_trunc, r2_with_trunc) %>%   pivot_longer(cols = -c(rep, true_rate),                names_to = \"estimator\",                values_to = \"estimate\") %>%   filter(!is.na(estimate)) %>%   mutate(     Estimator_lab = dplyr::case_when(       Estimator %in% c(\"R1\",\"Ratio of Means\",\"Ratio-of-Means\",\"R_1\") ~         \"R<sub>1<\/sub> (Ratio of Means)\",       Estimator %in% c(\"R2\",\"Mean of Ratios\",\"Mean-of-Ratios\",\"R_2\") ~         \"R<sub>2<\/sub> (Mean of Ratios)\",       TRUE ~ Estimator     ),     Truncation_lab = dplyr::case_when(       Truncation %in% c(\"30-Min Truncation\",\"30 min\",\"30min\",\"30\") ~         \"30-Min Truncation\",       TRUE ~ \"No Truncation\"     )   ) %>%   ggplot(aes(x = estimate, fill = Estimator)) +   # ... geoms ...   facet_grid(Estimator_lab ~ Truncation_lab, switch = \"y\") +   theme_minimal() +   theme(     legend.position = \"none\",     strip.text.x = ggtext::element_markdown(),     strip.text.y = ggtext::element_markdown()   )"},{"path":"/articles/ratio-estimators-guide.html","id":"simulation-setup","dir":"Articles","previous_headings":"","what":"Simulation Setup","title":"Ratio Estimators","text":"’ll simulate realistic fishing scenario compare estimator performance.","code":"# R code example #' Simulate a day of fishing with known parameters #' #' @param n_anglers Number of anglers fishing during the day #' @param mean_trip_hours Mean trip length (hours) #' @param mean_catch_rate Mean catch per hour (Poisson rate parameter) #' @param day_length_hours Length of fishing day #' @return List with population parameters and individual angler data simulate_fishing_day <- function(n_anglers = 100,                                  mean_trip_hours = 4,                                  mean_catch_rate = 2,                                  day_length_hours = 12) {    # Each angler's true catch rate (gamma-distributed for heterogeneity)   # Shape = 1, rate = 1/mean gives exponential with specified mean   # This creates variation in angler skill/success   alpha <- 1   beta <- 1 / mean_catch_rate   catch_rates <- rgamma(n_anglers, shape = alpha, rate = beta)    # Trip lengths (gamma-distributed)   shape_trip <- 4  # Controls variability   rate_trip <- shape_trip / mean_trip_hours   trip_lengths <- rgamma(n_anglers, shape = shape_trip, rate = rate_trip)   trip_lengths <- pmin(trip_lengths, day_length_hours)  # Can't exceed day length    # Generate catches for each angler (Poisson process)   # Expected catch = catch_rate * trip_length   completed_catch <- rpois(n_anglers, lambda = catch_rates * trip_lengths)    # True population parameters   total_effort <- sum(trip_lengths)   total_catch <- sum(completed_catch)   true_catch_rate <- total_catch / total_effort    # Return angler-level data   tibble(     angler_id = 1:n_anglers,     catch_rate_true = catch_rates,     trip_length = trip_lengths,     completed_catch = completed_catch,     true_population_rate = true_catch_rate,     total_effort = total_effort,     total_catch = total_catch   ) }  # Example fishing_day <- simulate_fishing_day(n_anglers = 100) head(fishing_day) # Code code example # A tibble: 6 × 7   angler_id catch_rate_true trip_length completed_catch true_population_rate       <int>           <dbl>       <dbl>           <int>                <dbl> 1         1           2.00         4.78               7                 2.15 2         2           2.26         1.56               5                 2.15 3         3           0.851        4.74               4                 2.15 4         4           1.03         6.06               5                 2.15 5         5           6.96         4.52              35                 2.15 6         6           0.627        5.59               3                 2.15 # ℹ 2 more variables: total_effort <dbl>, total_catch <int> # R code example # Summary of true population parameters cat(\"True Population Parameters:\\n\") # Code code example True Population Parameters: # R code example cat(\"  Total anglers:\", nrow(fishing_day), \"\\n\") # Code code example   Total anglers: 100 # R code example cat(\"  Total effort:\", round(fishing_day$total_effort[1], 1), \"hours\\n\") # Code code example   Total effort: 391.8 hours # R code example cat(\"  Total catch:\", fishing_day$total_catch[1], \"fish\\n\") # Code code example   Total catch: 844 fish # R code example cat(\"  True catch rate:\", round(fishing_day$true_population_rate[1], 3), \"fish/hour\\n\") # Code code example   True catch rate: 2.154 fish/hour"},{"path":"/articles/ratio-estimators-guide.html","id":"scenario-1-access-point-interviews-complete-trips","dir":"Articles","previous_headings":"","what":"Scenario 1: Access Point Interviews (Complete Trips)","title":"Ratio Estimators","text":"Simulate traditional access point creel interview anglers finish.","code":"# R code example #' Simulate access point interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Number of interviews to conduct #' @return Tibble with interview data sample_access_interviews <- function(fishing_day, n_interviews = 30) {   # Simple random sample (equal probability)   sampled <- fishing_day %>%     sample_n(size = min(n_interviews, nrow(fishing_day)), replace = FALSE) %>%     select(angler_id, completed_catch, trip_length, true_population_rate)    sampled }  # Single realization access_sample <- sample_access_interviews(fishing_day, n_interviews = 30) head(access_sample) # Code code example # A tibble: 6 × 4   angler_id completed_catch trip_length true_population_rate       <int>           <int>       <dbl>                <dbl> 1         1               7        4.78                 2.15 2        69               4        5.05                 2.15 3        79              14        6.27                 2.15 4        19               5        6.75                 2.15 5        12               1        4.72                 2.15 6        64               0        5.88                 2.15 # R code example # Calculate both estimators calculate_estimates <- function(interviews, truncate_minutes = NULL) {    # Apply truncation if specified (for roving surveys)   if (!is.null(truncate_minutes)) {     interviews <- interviews %>%       filter(trip_length >= truncate_minutes / 60)   }    n <- nrow(interviews)    # Ratio-of-means   r1 <- sum(interviews$completed_catch) / sum(interviews$trip_length)    # Mean-of-ratios   r2 <- mean(interviews$completed_catch / interviews$trip_length)    # Variance estimates (simplified)   # For R₁: use delta method (Taylor series approximation)   # Var(R₁) ≈ (1/n·E̅²) · Var(C - R₁·E)   # where residual = catch - estimated_rate × effort   r <- interviews$completed_catch   e <- interviews$trip_length   r_bar <- mean(r)   e_bar <- mean(e)   var_r1 <- (1 / (n * e_bar^2)) * var(r - r1 * e)   se_r1 <- sqrt(var_r1)    # For R₂: simple variance of the ratios   ratios <- interviews$completed_catch / interviews$trip_length   var_r2 <- var(ratios) / n   se_r2 <- sqrt(var_r2)    tibble(     n = n,     ratio_of_means = r1,     mean_of_ratios = r2,     se_r1 = se_r1,     se_r2 = se_r2,     true_rate = interviews$true_population_rate[1]   ) }  access_results <- calculate_estimates(access_sample) access_results # Code code example # A tibble: 1 × 6       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> 1    30           2.04           2.41 0.401 0.463      2.15"},{"path":"/articles/ratio-estimators-guide.html","id":"scenario-2-roving-interviews-incomplete-trips","dir":"Articles","previous_headings":"","what":"Scenario 2: Roving Interviews (Incomplete Trips)","title":"Ratio Estimators","text":"Now simulate roving interviews anglers intercepted trips.","code":"# R code example #' Simulate roving interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Target number of interviews #' @return Tibble with incomplete trip interview data sample_roving_interviews <- function(fishing_day, n_interviews = 30) {    # Length-biased sampling: probability of encounter ∝ trip duration   # P(interview angler i) = L_i / Σ L_j (normalized by total effort)   # Longer trips have higher chance of being encountered during roving   prob_intercept <- fishing_day$trip_length / sum(fishing_day$trip_length)    # Sample with probability proportional to size   sampled_indices <- sample(     1:nrow(fishing_day),     size = min(n_interviews, nrow(fishing_day)),     replace = FALSE,     prob = prob_intercept   )    sampled <- fishing_day[sampled_indices, ]    # For each intercepted angler, determine interview time   # Uniform on [0, trip_length] (on average, intercepted at midpoint)   sampled <- sampled %>%     mutate(       # Time fished when interviewed (uniform on [0, trip_length])       # On average, anglers are intercepted at midpoint of their trip       time_at_interview = runif(n(), min = 0, max = trip_length),        # Catch at interview time (incomplete trip)       # Poisson process: E[catch | time_t] = λ × t       # where λ = angler's true catch rate, t = time fished so far       catch_at_interview = rpois(n(), lambda = catch_rate_true * time_at_interview)     ) %>%     select(angler_id, catch_at_interview, time_at_interview,            completed_catch, trip_length, true_population_rate)    sampled }  roving_sample <- sample_roving_interviews(fishing_day, n_interviews = 30) head(roving_sample) # Code code example # A tibble: 6 × 6   angler_id catch_at_interview time_at_interview completed_catch trip_length       <int>              <int>             <dbl>           <int>       <dbl> 1        27                  1             2.57                2        5.27 2        37                  4             1.46               13        2.99 3        81                  0             0.326               3        3.86 4        32                  1             2.30                8        5.76 5        97                  6             3.54               10        4.81 6        28                  4             2.58                5        2.72 # ℹ 1 more variable: true_population_rate <dbl> # R code example # For roving, use incomplete data # Note: calculate_estimates() expects columns named 'completed_catch' and 'trip_length' roving_data <- roving_sample %>%   select(angler_id,          completed_catch = catch_at_interview,          trip_length = time_at_interview,          true_population_rate)  # No truncation roving_no_trunc <- calculate_estimates(roving_data, truncate_minutes = NULL)  # With truncation (30 minutes) roving_with_trunc <- calculate_estimates(roving_data, truncate_minutes = 30)  bind_rows(   roving_no_trunc %>% mutate(truncation = \"None\"),   roving_with_trunc %>% mutate(truncation = \"30 min\") ) # Code code example # A tibble: 2 × 7       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate truncation   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> <chr> 1    30           1.98           1.77 0.329 0.289      2.15 None 2    27           1.97           1.67 0.334 0.281      2.15 30 min"},{"path":"/articles/ratio-estimators-guide.html","id":"monte-carlo-simulation","dir":"Articles","previous_headings":"","what":"Monte Carlo Simulation","title":"Ratio Estimators","text":"Run 1000 replications assess bias precision.","code":"# R code example run_simulation <- function(n_reps = 1000,                            n_anglers = 100,                            n_interviews = 30,                            interview_type = c(\"access\", \"roving\")) {    interview_type <- match.arg(interview_type)    results <- map_dfr(1:n_reps, function(rep) {     # Generate population     day <- simulate_fishing_day(n_anglers = n_anglers)     true_rate <- day$true_population_rate[1]      # Sample based on design     if (interview_type == \"access\") {       sample_data <- sample_access_interviews(day, n_interviews)       sample_data <- sample_data %>%         rename(catch = completed_catch, effort = trip_length)     } else {       sample_data <- sample_roving_interviews(day, n_interviews) %>%         rename(catch = catch_at_interview, effort = time_at_interview)     }      # Calculate estimators     # No truncation     r1_no <- sum(sample_data$catch) / sum(sample_data$effort)     r2_no <- mean(sample_data$catch / sample_data$effort)      # With truncation (30 min = 0.5 hr)     trunc_data <- sample_data %>% filter(effort >= 0.5)     if (nrow(trunc_data) > 0) {       r1_trunc <- sum(trunc_data$catch) / sum(trunc_data$effort)       r2_trunc <- mean(trunc_data$catch / trunc_data$effort)     } else {       r1_trunc <- NA       r2_trunc <- NA     }      tibble(       rep = rep,       true_rate = true_rate,       r1_no_trunc = r1_no,       r2_no_trunc = r2_no,       r1_with_trunc = r1_trunc,       r2_with_trunc = r2_trunc,       n_interviews = n_interviews,       n_after_trunc = nrow(trunc_data)     )   })    results %>%     mutate(design = interview_type) }  # Run simulations access_mc <- run_simulation(n_reps = 1000, interview_type = \"access\") roving_mc <- run_simulation(n_reps = 1000, interview_type = \"roving\")"},{"path":"/articles/ratio-estimators-guide.html","id":"results-access-point-design","dir":"Articles","previous_headings":"","what":"Results: Access Point Design","title":"Ratio Estimators","text":"Access Point Design: Estimator Performance estimator mean bias pct_bias se rmse r1 1.9953 -0.0069 -0.3452 0.4276 0.4274 r2 2.0081 0.0059 0.2955 0.4081 0.4079 Key Finding: access interviews, estimators approximately unbiased, ratio--means (R₁) typically slightly lower variance.  Access Point Design: Distribution Estimates. estimators center true value (dashed line), demonstrating unbiasedness. ratio--means (R₁) shows slightly tighter clustering, indicating lower variance.","code":"# R code example # Summary statistics access_summary <- access_mc %>%   summarise(     true_rate = mean(true_rate),      # Ratio of means (R₁)     r1_mean = mean(r1_no_trunc),     r1_bias = mean(r1_no_trunc - true_rate),     r1_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate),     r1_rmse = sqrt(mean((r1_no_trunc - true_rate)^2)),     r1_se = sd(r1_no_trunc),      # Mean of ratios (R₂)     r2_mean = mean(r2_no_trunc),     r2_bias = mean(r2_no_trunc - true_rate),     r2_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate),     r2_rmse = sqrt(mean((r2_no_trunc - true_rate)^2)),     r2_se = sd(r2_no_trunc)   )  access_summary %>%   pivot_longer(cols = -true_rate, names_to = c(\"estimator\", \"metric\"), names_sep = \"_\", values_to = \"value\", names_repair = \"minimal\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   select(estimator, mean, bias, pct, se, rmse) %>%   rename(pct_bias = pct) %>%   knitr::kable(digits = 4, caption = \"Access Point Design: Estimator Performance\") # R code example access_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc) %>%   pivot_longer(cols = c(r1_no_trunc, r2_no_trunc),                names_to = \"estimator\",                values_to = \"estimate\") %>%   mutate(     estimator = recode(estimator,       r1_no_trunc = \"Ratio of Means (R1)\",       r2_no_trunc = \"Mean of Ratios (R2)\"     ),     # NEW: HTML subscripts for facet strips     estimator_lab = recode(estimator,       \"Ratio of Means (R1)\" = \"R<sub>1<\/sub> (Ratio of Means)\",       \"Mean of Ratios (R2)\" = \"R<sub>2<\/sub> (Mean of Ratios)\"     )   ) %>%   ggplot(aes(x = estimate, fill = estimator)) +   geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +   geom_vline(aes(xintercept = mean(true_rate)), linetype = \"dashed\", size = 1) +   facet_wrap(~ estimator_lab, ncol = 1) +   labs(     title = \"Access Point Design: Sampling Distribution\",     subtitle = \"Dashed line = true population catch rate\",     x = \"Estimated Catch Rate (fish/hour)\",     y = \"Frequency\"   ) +   theme_minimal() +   theme(     legend.position = \"none\",     # NEW: render HTML in strip labels     strip.text = ggtext::element_markdown()   )"},{"path":"/articles/ratio-estimators-guide.html","id":"results-roving-design","dir":"Articles","previous_headings":"","what":"Results: Roving Design","title":"Ratio Estimators","text":"Roving Design: Estimator Performance estimator truncation mean bias pct_bias rmse Ratio Means truncation 1.9957 -0.0209 -1.0341 0.4985 Mean Ratios truncation 1.9909 -0.0256 -1.2698 0.4629 Ratio Means 30-min truncation 1.9966 -0.0199 -0.9880 0.5041 Mean Ratios 30-min truncation 2.0092 -0.0073 -0.3629 0.4400 Key Findings: R₁ (ratio--means) BIASED roving interviews 1. R₁ (ratio--means) BIASED roving interviews - estimate population catch rate R₂ (mean--ratios) without truncation approximately unbiased high variance 2. R₂ (mean--ratios) without truncation approximately unbiased high variance (unstable) R₂ truncation approximately unbiased lower variance RECOMMENDED 3. R₂ truncation approximately unbiased lower variance ✓ RECOMMENDED  Roving Design: Effect Truncation. R₁ (ratio--means) biased roving surveys regardless truncation. R₂ (mean--ratios) unbiased high variance without truncation; truncation reduces variance maintaining unbiasedness.","code":"# R code example # Summary statistics roving_summary <- roving_mc %>%   summarise(     true_rate = mean(true_rate),      # R1 no truncation     r1_no_mean = mean(r1_no_trunc, na.rm = TRUE),     r1_no_bias = mean(r1_no_trunc - true_rate, na.rm = TRUE),     r1_no_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_no_rmse = sqrt(mean((r1_no_trunc - true_rate)^2, na.rm = TRUE)),      # R2 no truncation     r2_no_mean = mean(r2_no_trunc, na.rm = TRUE),     r2_no_bias = mean(r2_no_trunc - true_rate, na.rm = TRUE),     r2_no_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_no_rmse = sqrt(mean((r2_no_trunc - true_rate)^2, na.rm = TRUE)),      # R1 with truncation     r1_trunc_mean = mean(r1_with_trunc, na.rm = TRUE),     r1_trunc_bias = mean(r1_with_trunc - true_rate, na.rm = TRUE),     r1_trunc_pct_bias = 100 * mean((r1_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_trunc_rmse = sqrt(mean((r1_with_trunc - true_rate)^2, na.rm = TRUE)),      # R2 with truncation     r2_trunc_mean = mean(r2_with_trunc, na.rm = TRUE),     r2_trunc_bias = mean(r2_with_trunc - true_rate, na.rm = TRUE),     r2_trunc_pct_bias = 100 * mean((r2_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_trunc_rmse = sqrt(mean((r2_with_trunc - true_rate)^2, na.rm = TRUE))   )  roving_summary %>%   pivot_longer(cols = -true_rate,                names_to = c(\"estimator\", \"truncation\", \"metric\"),                names_pattern = \"([^_]+)_([^_]+)_(.*)\",                values_to = \"value\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   mutate(estimator = recode(estimator, r1 = \"Ratio of Means\", r2 = \"Mean of Ratios\"),          truncation = recode(truncation, no = \"No truncation\", trunc = \"30-min truncation\")) %>%   select(estimator, truncation, mean, bias, pct_bias, rmse) %>%   knitr::kable(digits = 4, caption = \"Roving Design: Estimator Performance\") # R code example  labels <- c(   \"r1\" = \"italic(R)[1]~'(Ratio~of~Means)'\",   \"r2\" = \"italic(R)[2]~'(Mean~of~Ratios)'\" )   roving_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc, r1_with_trunc, r2_with_trunc) %>%   pivot_longer(cols = -c(rep, true_rate),                names_to = \"estimator\",                values_to = \"estimate\") %>%   filter(!is.na(estimate)) %>%   mutate(     Estimator_lab = dplyr::case_when(       Estimator %in% c(\"R1\",\"Ratio of Means\",\"Ratio-of-Means\",\"R_1\") ~         \"R<sub>1<\/sub> (Ratio of Means)\",       Estimator %in% c(\"R2\",\"Mean of Ratios\",\"Mean-of-Ratios\",\"R_2\") ~         \"R<sub>2<\/sub> (Mean of Ratios)\",       TRUE ~ Estimator     ),     Truncation_lab = dplyr::case_when(       Truncation %in% c(\"30-Min Truncation\",\"30 min\",\"30min\",\"30\") ~         \"30-Min Truncation\",       TRUE ~ \"No Truncation\"     )   ) %>%   ggplot(aes(x = estimate, fill = Estimator)) +   # ... geoms ...   facet_grid(Estimator_lab ~ Truncation_lab, switch = \"y\") +   theme_minimal() +   theme(     legend.position = \"none\",     strip.text.x = ggtext::element_markdown(),     strip.text.y = ggtext::element_markdown()   )"},{"path":"/articles/ratio-estimators-guide.html","id":"practical-implementation-with-tidycreel","dir":"Articles","previous_headings":"","what":"Practical Implementation with tidycreel","title":"Ratio Estimators","text":"","code":"# R code example # Assuming you have complete-trip interview data interviews_complete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 8),   hours_fished = rgamma(100, shape = 4, rate = 1),   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # Create survey design svy_interviews <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_complete )  # Use RATIO-OF-MEANS (default and recommended) cpue_access <- est_cpue(   design = svy_interviews,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"ratio_of_means\"  # ✓ Correct for access interviews )  cpue_access # R code example # Assuming you have incomplete-trip interview data interviews_incomplete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 4),  # Catch so far   hours_fished = runif(100, min = 0.2, max = 6),  # Time so far   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # IMPORTANT: Truncate short trips before analysis interviews_truncated <- interviews_incomplete %>%   filter(hours_fished >= 0.5)  # Remove trips < 30 minutes  # Create survey design svy_roving <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_truncated )  # Use MEAN-OF-RATIOS for roving interviews cpue_roving <- est_cpue(   design = svy_roving,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"mean_of_ratios\"  # ✓ Correct for roving interviews )  cpue_roving"},{"path":"/articles/ratio-estimators-guide.html","id":"access-point-survey-example","dir":"Articles","previous_headings":"","what":"Access Point Survey Example","title":"Ratio Estimators","text":"","code":"# R code example # Assuming you have complete-trip interview data interviews_complete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 8),   hours_fished = rgamma(100, shape = 4, rate = 1),   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # Create survey design svy_interviews <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_complete )  # Use RATIO-OF-MEANS (default and recommended) cpue_access <- est_cpue(   design = svy_interviews,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"ratio_of_means\"  # ✓ Correct for access interviews )  cpue_access"},{"path":"/articles/ratio-estimators-guide.html","id":"roving-survey-example","dir":"Articles","previous_headings":"","what":"Roving Survey Example","title":"Ratio Estimators","text":"","code":"# R code example # Assuming you have incomplete-trip interview data interviews_incomplete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 4),  # Catch so far   hours_fished = runif(100, min = 0.2, max = 6),  # Time so far   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # IMPORTANT: Truncate short trips before analysis interviews_truncated <- interviews_incomplete %>%   filter(hours_fished >= 0.5)  # Remove trips < 30 minutes  # Create survey design svy_roving <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_truncated )  # Use MEAN-OF-RATIOS for roving interviews cpue_roving <- est_cpue(   design = svy_roving,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"mean_of_ratios\"  # ✓ Correct for roving interviews )  cpue_roving"},{"path":"/articles/ratio-estimators-guide.html","id":"variance-estimation","dir":"Articles","previous_headings":"","what":"Variance Estimation","title":"Ratio Estimators","text":"ratio--means survey weights, survey package automatically uses delta method: Note: variance formulas assume sampling infinite (large) population. sample size substantial relative total number anglers (n/N > 5%), may want apply finite population correction (FPC): multiply variance (1 - n/N). However, creel surveys population potential anglers large, correction negligible. Var(R̂1)≈1nE‾2Var(C−R̂1E)\\text{Var}(\\hat{R}_1) \\approx \\frac{1}{n\\bar{E}^2} \\text{Var}(C - \\hat{R}_1 E) CC = catch, EE = effort. mean--ratios, variance straightforward: Var(R̂2)=1nVar(CjEj)\\text{Var}(\\hat{R}_2) = \\frac{1}{n} \\text{Var}\\left(\\frac{C_j}{E_j}\\right)","code":"# R code example # survey::svyratio() provides proper variance cpue_result <- est_cpue(design = svy_interviews, mode = \"ratio_of_means\")  # Standard error is included cpue_result$se  # 95% confidence interval cpue_result$ci_low cpue_result$ci_high # R code example # survey::svymean() on the ratio variable cpue_roving <- est_cpue(design = svy_roving, mode = \"mean_of_ratios\")  # Standard error and CIs included cpue_roving$se cpue_roving$ci_low cpue_roving$ci_high"},{"path":"/articles/ratio-estimators-guide.html","id":"access-point-ratio-of-means","dir":"Articles","previous_headings":"","what":"Access Point (Ratio-of-Means)","title":"Ratio Estimators","text":"ratio--means survey weights, survey package automatically uses delta method: Note: variance formulas assume sampling infinite (large) population. sample size substantial relative total number anglers (n/N > 5%), may want apply finite population correction (FPC): multiply variance (1 - n/N). However, creel surveys population potential anglers large, correction negligible. Var(R̂1)≈1nE‾2Var(C−R̂1E)\\text{Var}(\\hat{R}_1) \\approx \\frac{1}{n\\bar{E}^2} \\text{Var}(C - \\hat{R}_1 E) CC = catch, EE = effort.","code":"# R code example # survey::svyratio() provides proper variance cpue_result <- est_cpue(design = svy_interviews, mode = \"ratio_of_means\")  # Standard error is included cpue_result$se  # 95% confidence interval cpue_result$ci_low cpue_result$ci_high"},{"path":"/articles/ratio-estimators-guide.html","id":"roving-mean-of-ratios-with-truncation","dir":"Articles","previous_headings":"","what":"Roving (Mean-of-Ratios with Truncation)","title":"Ratio Estimators","text":"mean--ratios, variance straightforward: Var(R̂2)=1nVar(CjEj)\\text{Var}(\\hat{R}_2) = \\frac{1}{n} \\text{Var}\\left(\\frac{C_j}{E_j}\\right)","code":"# R code example # survey::svymean() on the ratio variable cpue_roving <- est_cpue(design = svy_roving, mode = \"mean_of_ratios\")  # Standard error and CIs included cpue_roving$se cpue_roving$ci_low cpue_roving$ci_high"},{"path":"/articles/ratio-estimators-guide.html","id":"special-considerations","dir":"Articles","previous_headings":"","what":"Special Considerations","title":"Ratio Estimators","text":"⚠️ CRITICAL WARNING: Roving surveys can produce severe negative bias (underestimation 20-50%+) bag limits low (≤5 fish) anglers comply leaving immediately upon reaching limit. Problem: anglers leave immediately catching limit, roving clerk encounter unsuccessful anglers, leading severe underestimation. Example simulation (bag limit = 2 fish): Roving Bias Different Bag Limits bag_limit true_rate mean_estimate bias pct_bias 2 2.010 0.341 -1.668 -83.017 5 2.001 0.655 -1.346 -67.286 10 2.003 1.021 -0.982 -49.014 Recommendation: bag limits low (≤5 fish) compliance high, use access point interviews instead roving. catch rates change systematically trips (e.g., learning curve, time--day effects), roving interviews may biased. Check : Comparing incomplete-trip catch rates complete-trip catch rates Looking patterns catch rate vs. time--day nonstationary: Consider access point interviews model time-varying catch rate.","code":"# R code example simulate_with_bag_limit <- function(n_reps = 500, bag_limit = 2) {   map_dfr(1:n_reps, function(rep) {     # Simulate fishing day     day <- simulate_fishing_day(n_anglers = 100)     true_rate <- day$true_population_rate[1]      # Apply bag limit: anglers stop when limit reached     day_limited <- day %>%       mutate(         # Time to reach bag limit (exponential waiting time)         time_to_limit = ifelse(catch_rate_true > 0,                                bag_limit / catch_rate_true,                                Inf),         # Actual trip length (stop at limit or planned end, whichever comes first)         actual_trip_length = pmin(trip_length, time_to_limit),         # Actual catch (capped at bag limit)         actual_catch = pmin(completed_catch, bag_limit),         # Did angler reach bag limit before planned trip end?         reached_limit = (time_to_limit < trip_length)       )      # Roving interviews can only encounter anglers still on-site     # Those who reached bag limit before their planned trip end have already left     # Only those who haven't reached the limit OR reached it at/after planned end are available     still_fishing <- day_limited %>%       filter(!reached_limit)      if (nrow(still_fishing) > 10) {       # Sample from those still fishing       sample_data <- sample_roving_interviews(still_fishing, n_interviews = 30) %>%         rename(catch = catch_at_interview, effort = time_at_interview) %>%         filter(effort >= 0.5)        if (nrow(sample_data) > 0) {         r2 <- mean(sample_data$catch / sample_data$effort)         return(tibble(rep = rep, true_rate = true_rate, estimated_rate = r2,                      bag_limit = bag_limit))       }     }      tibble(rep = rep, true_rate = true_rate, estimated_rate = NA, bag_limit = bag_limit)   }) }  bag_limit_results <- bind_rows(   simulate_with_bag_limit(bag_limit = 2),   simulate_with_bag_limit(bag_limit = 5),   simulate_with_bag_limit(bag_limit = 10) )  bag_limit_summary <- bag_limit_results %>%   filter(!is.na(estimated_rate)) %>%   group_by(bag_limit) %>%   summarise(     true_rate = mean(true_rate),     mean_estimate = mean(estimated_rate),     bias = mean(estimated_rate - true_rate),     pct_bias = 100 * mean((estimated_rate - true_rate) / true_rate)   )  bag_limit_summary %>%   knitr::kable(digits = 3, caption = \"Roving Bias Under Different Bag Limits\")"},{"path":"/articles/ratio-estimators-guide.html","id":"bag-limits","dir":"Articles","previous_headings":"","what":"Bag Limits","title":"Ratio Estimators","text":"⚠️ CRITICAL WARNING: Roving surveys can produce severe negative bias (underestimation 20-50%+) bag limits low (≤5 fish) anglers comply leaving immediately upon reaching limit. Problem: anglers leave immediately catching limit, roving clerk encounter unsuccessful anglers, leading severe underestimation. Example simulation (bag limit = 2 fish): Roving Bias Different Bag Limits bag_limit true_rate mean_estimate bias pct_bias 2 2.010 0.341 -1.668 -83.017 5 2.001 0.655 -1.346 -67.286 10 2.003 1.021 -0.982 -49.014 Recommendation: bag limits low (≤5 fish) compliance high, use access point interviews instead roving.","code":"# R code example simulate_with_bag_limit <- function(n_reps = 500, bag_limit = 2) {   map_dfr(1:n_reps, function(rep) {     # Simulate fishing day     day <- simulate_fishing_day(n_anglers = 100)     true_rate <- day$true_population_rate[1]      # Apply bag limit: anglers stop when limit reached     day_limited <- day %>%       mutate(         # Time to reach bag limit (exponential waiting time)         time_to_limit = ifelse(catch_rate_true > 0,                                bag_limit / catch_rate_true,                                Inf),         # Actual trip length (stop at limit or planned end, whichever comes first)         actual_trip_length = pmin(trip_length, time_to_limit),         # Actual catch (capped at bag limit)         actual_catch = pmin(completed_catch, bag_limit),         # Did angler reach bag limit before planned trip end?         reached_limit = (time_to_limit < trip_length)       )      # Roving interviews can only encounter anglers still on-site     # Those who reached bag limit before their planned trip end have already left     # Only those who haven't reached the limit OR reached it at/after planned end are available     still_fishing <- day_limited %>%       filter(!reached_limit)      if (nrow(still_fishing) > 10) {       # Sample from those still fishing       sample_data <- sample_roving_interviews(still_fishing, n_interviews = 30) %>%         rename(catch = catch_at_interview, effort = time_at_interview) %>%         filter(effort >= 0.5)        if (nrow(sample_data) > 0) {         r2 <- mean(sample_data$catch / sample_data$effort)         return(tibble(rep = rep, true_rate = true_rate, estimated_rate = r2,                      bag_limit = bag_limit))       }     }      tibble(rep = rep, true_rate = true_rate, estimated_rate = NA, bag_limit = bag_limit)   }) }  bag_limit_results <- bind_rows(   simulate_with_bag_limit(bag_limit = 2),   simulate_with_bag_limit(bag_limit = 5),   simulate_with_bag_limit(bag_limit = 10) )  bag_limit_summary <- bag_limit_results %>%   filter(!is.na(estimated_rate)) %>%   group_by(bag_limit) %>%   summarise(     true_rate = mean(true_rate),     mean_estimate = mean(estimated_rate),     bias = mean(estimated_rate - true_rate),     pct_bias = 100 * mean((estimated_rate - true_rate) / true_rate)   )  bag_limit_summary %>%   knitr::kable(digits = 3, caption = \"Roving Bias Under Different Bag Limits\")"},{"path":"/articles/ratio-estimators-guide.html","id":"nonstationary-catch-rates","dir":"Articles","previous_headings":"","what":"Nonstationary Catch Rates","title":"Ratio Estimators","text":"catch rates change systematically trips (e.g., learning curve, time--day effects), roving interviews may biased. Check : Comparing incomplete-trip catch rates complete-trip catch rates Looking patterns catch rate vs. time--day nonstationary: Consider access point interviews model time-varying catch rate.","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"summary-practical-guidelines","dir":"Articles","previous_headings":"","what":"Summary: Practical Guidelines","title":"Ratio Estimators","text":"Survey Type Interview Type Recommended Estimator Function Call Access point Complete trips Ratio--means (R₁) est_cpue(…, mode = “ratio_of_means”) Roving Incomplete trips Mean--ratios (R₂) truncation est_cpue(…, mode = “mean_of_ratios”) + filter short trips Complemented (aerial-access) Complete trips Ratio--means (R₁) est_cpue(…, mode = “ratio_of_means”) Complemented (aerial-roving) Incomplete trips Mean--ratios (R₂) truncation est_cpue(…, mode = “mean_of_ratios”) + filter surveys: Check missing data catch effort - Check missing data catch effort Verify effort > 0 interviews - Verify effort > 0 interviews Check outliers (data entry errors) - Check outliers (data entry errors) ROVING surveys specifically: Truncate short trips (< 20-30 minutes) - Truncate short trips (< 20-30 minutes) Check bag limit compliance (may cause bias) - Check bag limit compliance (may cause bias) Verify catch rate stationarity (possible) - Verify catch rate stationarity (possible) Use proper survey weights svydesign() - Use proper survey weights svydesign() Include stratification variables - Include stratification variables Use svyratio() ratio--means - Use svyratio() ratio--means Use svymean() catch/effort ratio mean--ratios - Use svymean() catch/effort ratio mean--ratios Report standard errors confidence intervals - Report standard errors confidence intervals","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"decision-rules","dir":"Articles","previous_headings":"","what":"Decision Rules","title":"Ratio Estimators","text":"Survey Type Interview Type Recommended Estimator Function Call Access point Complete trips Ratio--means (R₁) est_cpue(…, mode = “ratio_of_means”) Roving Incomplete trips Mean--ratios (R₂) truncation est_cpue(…, mode = “mean_of_ratios”) + filter short trips Complemented (aerial-access) Complete trips Ratio--means (R₁) est_cpue(…, mode = “ratio_of_means”) Complemented (aerial-roving) Incomplete trips Mean--ratios (R₂) truncation est_cpue(…, mode = “mean_of_ratios”) + filter","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"pre-processing-checklist","dir":"Articles","previous_headings":"","what":"Pre-processing Checklist","title":"Ratio Estimators","text":"surveys: Check missing data catch effort - Check missing data catch effort Verify effort > 0 interviews - Verify effort > 0 interviews Check outliers (data entry errors) - Check outliers (data entry errors) ROVING surveys specifically: Truncate short trips (< 20-30 minutes) - Truncate short trips (< 20-30 minutes) Check bag limit compliance (may cause bias) - Check bag limit compliance (may cause bias) Verify catch rate stationarity (possible) - Verify catch rate stationarity (possible)","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"variance-estimation-checklist","dir":"Articles","previous_headings":"","what":"Variance Estimation Checklist","title":"Ratio Estimators","text":"Use proper survey weights svydesign() - Use proper survey weights svydesign() Include stratification variables - Include stratification variables Use svyratio() ratio--means - Use svyratio() ratio--means Use svymean() catch/effort ratio mean--ratios - Use svymean() catch/effort ratio mean--ratios Report standard errors confidence intervals - Report standard errors confidence intervals","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Ratio Estimators","text":"Pollock, K.H., Hoenig, J.M., Jones, C.M., Robson, D.S., & Greene, C.J. (1997). Catch rate estimation roving access point surveys. North American Journal Fisheries Management, 17(1), 11-19. Pollock, K.H., Hoenig, J.M., Jones, C.M., Robson, D.S., & Greene, C.J. (1997). Catch rate estimation roving access point surveys. North American Journal Fisheries Management , 17(1), 11-19. Rasmussen, P.W., Staggs, M.D., Beard, T.D., & Newman, S.P. (1998). Bias confidence interval coverage creel survey estimators evaluated simulation. Transactions American Fisheries Society, 127(3), 469-480. Rasmussen, P.W., Staggs, M.D., Beard, T.D., & Newman, S.P. (1998). Bias confidence interval coverage creel survey estimators evaluated simulation. Transactions American Fisheries Society , 127(3), 469-480. Jones, C.M., Robson, D.S., Lakkis, H.D., & Kressel, J. (1995). Properties catch rates used analysis angler surveys. Transactions American Fisheries Society, 124(6), 911-928. Jones, C.M., Robson, D.S., Lakkis, H.D., & Kressel, J. (1995). Properties catch rates used analysis angler surveys. Transactions American Fisheries Society , 124(6), 911-928. Lumley, T. (2004). Analysis complex survey samples. Journal Statistical Software, 9(1), 1-19. Lumley, T. (2004). Analysis complex survey samples. Journal Statistical Software , 9(1), 1-19.","code":""},{"path":"/articles/ratio-estimators-guide.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Ratio Estimators","text":"choice ratio--means mean--ratios depends fundamentally survey design: Access point interviews ratio--means - Access point interviews → Use ratio--means Roving interviews mean--ratios truncation - Roving interviews → Use mean--ratios truncation tidycreel package implements estimators proper variance estimation survey package. following decision rules vignette, can ensure catch rate estimates unbiased confidence intervals correct coverage.","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"introduction","dir":"Articles","previous_headings":"","what":"Introduction","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"One common questions creel survey analysis : “use ratio--means mean--ratios estimate catch rate?” vignette answers question : Decision rules based survey design type Simulation demonstrations showing estimator performance Practical guidance variance estimation Clear examples using tidycreel","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"quick-answer-decision-tree","dir":"Articles","previous_headings":"","what":"Quick Answer: Decision Tree","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"","code":"┌─────────────────────────────────────────────┐ │   What type of interviews do you have?      │ └─────────────────┬───────────────────────────┘                   │         ┌─────────┴─────────┐         │                   │     ┌───▼──────┐          ┌───▼────────┐     │ ACCESS   │          │ ROVING     │     │(Complete │          │(Incomplete │     │ trips)   │          │  trips)    │     └───┬──────┘          └───┬────────┘         │                     │         │                     │     ┌───▼─────────────────┐   │     │ Use RATIO-OF-MEANS  │   │     │  R₁ = Σcatch/Σeffort│   │     │                     │   │     │ Why? Each angler    │   │     │ has equal sampling  │   │     │ probability.        │   │     │                     │   │     │ ✓ Unbiased          │   │     │ ✓ Finite variance   │   │     └─────────────────────┘   │                               │                   ┌───────────▼────────────────┐                   │ Use MEAN-OF-RATIOS         │                   │  R₂ = (1/n)Σ(catch/effort) │                   │                            │                   │ IMPORTANT: Truncate short  │                   │ trips (< 20-30 minutes)    │                   │                            │                   │ Why? Sampling probability  │                   │ ∝ trip length. R₁ would    │                   │ give biased estimate.      │                   │                            │                   │ ⚠ Avoid if bag limits      │                   │   are low & easily obtained│                   └────────────────────────────┘"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"theoretical-background","dir":"Articles","previous_headings":"","what":"Theoretical Background","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Sampling Design: Interviews conducted anglers complete trips anglers equal probability interviewed P(interviewed) = constant, regardless trip length Appropriate Estimator: Ratio--Means (R₁) [_1 = ] (C_j^) = total catch completed trip (L_j^) = total trip length completion. Expected Value: [E(_1) ] ✓ want total catch estimation! Sampling Design: Interviews conducted fishing trips Sampling probability ∝ trip length Longer trips likely encountered Appropriate Estimator: Mean--Ratios (R₂) Truncation [2 = {j=1}^{n} ] (C_j) = catch time interview (L_j) = elapsed time interview. truncation: include interviews (L_j > L_{min}) (typically 20-30 minutes). Expected Value: [E(_2) ] ✓ Correct roving interviews! use R₁ roving? ratio--means roving interviews : [E(_1^{roving}) ] weighted average weights = (trip length)², estimate population catch rate! matters: Real creel surveys often produce mix completed (access-point) incomplete (roving/intercept) interviews. Estimator choice must follow inclusion probability, just trip status, avoid bias. inclusion probability differs design (equal-probability access points vs. length-biased roving), pooling interviews applying single estimator can introduce bias. Treat designs according sampling properties. Treat complete incomplete interviews two strata, combine effort weighting: Complete trips (access point): use Ratio--Means (R₁ = ΣC / ΣE). Incomplete trips (roving): use Mean--Ratios (R₂ = (1/n) Σ(C/E)) truncation short trips (e.g., < 20–30 min). Effort-weighted combination: R̂combined=R1Ecomplete+R2EincompleteEcomplete+Eincomplete \\hat{R}_{\\text{combined}} = \\frac{R_1 E_{\\text{complete}} + R_2 E_{\\text{incomplete}}}{E_{\\text{complete}} + E_{\\text{incomplete}}} can estimate selection/inclusion probabilities (e.g., model trip completeness roving intercept likelihood), use weighted ratio: R̂weighted=∑iwiCi∑iwiEi,wi=1/P(selecti). \\hat{R}_{\\text{weighted}} = \\frac{\\sum_i w_i C_i}{\\sum_i w_i E_i}, \\quad w_i = 1 / P(\\text{select}_i). useful hybrid designs sampling varies predictably across modes, times, sites. Compute: () R₁ complete , (b) R₂ incomplete (truncation), (c) combined estimator. differences small (e.g., < 5–10%), pooling assumptions may reasonable; document . apply R₁ unfiltered roving data — biased high due length-biased sampling. apply R₂ complete trips — bias direction depends effort variability. Always truncate short incomplete trips stabilize R₂ reduce small-denominator issues. bag limits frequently hit, cautious R₂ (ceiling effects can distort ratios). Estimate SEs stratum appropriate formula (delta-method R₁; sample variance ratios R₂), combine via delta-method using effort-weight combination .","code":"complete <- data %>% dplyr::filter(trip_complete == TRUE) incomplete <- data %>% dplyr::filter(trip_complete == FALSE, trip_length >= 0.5)  # 0.5 h = 30 min  r1 <- sum(complete$catch) / sum(complete$effort) r2 <- mean(incomplete$catch / incomplete$effort)  E1 <- sum(complete$effort) E2 <- sum(incomplete$effort)  R_combined <- (r1 * E1 + r2 * E2) / (E1 + E2)"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"access-point-complete-trip-interviews","dir":"Articles","previous_headings":"","what":"Access Point (Complete Trip) Interviews","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Sampling Design: Interviews conducted anglers complete trips anglers equal probability interviewed P(interviewed) = constant, regardless trip length Appropriate Estimator: Ratio--Means (R₁) [_1 = ] (C_j^) = total catch completed trip (L_j^) = total trip length completion. Expected Value: [E(_1) ] ✓ want total catch estimation!","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"roving-incomplete-trip-interviews","dir":"Articles","previous_headings":"","what":"Roving (Incomplete Trip) Interviews","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Sampling Design: Interviews conducted fishing trips Sampling probability ∝ trip length Longer trips likely encountered Appropriate Estimator: Mean--Ratios (R₂) Truncation [2 = {j=1}^{n} ] (C_j) = catch time interview (L_j) = elapsed time interview. truncation: include interviews (L_j > L_{min}) (typically 20-30 minutes). Expected Value: [E(_2) ] ✓ Correct roving interviews! use R₁ roving? ratio--means roving interviews : [E(_1^{roving}) ] weighted average weights = (trip length)², estimate population catch rate!","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"handling-mixed-complete-and-incomplete-trips","dir":"Articles","previous_headings":"","what":"Handling Mixed Complete and Incomplete Trips","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"matters: Real creel surveys often produce mix completed (access-point) incomplete (roving/intercept) interviews. Estimator choice must follow inclusion probability, just trip status, avoid bias. inclusion probability differs design (equal-probability access points vs. length-biased roving), pooling interviews applying single estimator can introduce bias. Treat designs according sampling properties. Treat complete incomplete interviews two strata, combine effort weighting: Complete trips (access point): use Ratio--Means (R₁ = ΣC / ΣE). Incomplete trips (roving): use Mean--Ratios (R₂ = (1/n) Σ(C/E)) truncation short trips (e.g., < 20–30 min). Effort-weighted combination: R̂combined=R1Ecomplete+R2EincompleteEcomplete+Eincomplete \\hat{R}_{\\text{combined}} = \\frac{R_1 E_{\\text{complete}} + R_2 E_{\\text{incomplete}}}{E_{\\text{complete}} + E_{\\text{incomplete}}} can estimate selection/inclusion probabilities (e.g., model trip completeness roving intercept likelihood), use weighted ratio: R̂weighted=∑iwiCi∑iwiEi,wi=1/P(selecti). \\hat{R}_{\\text{weighted}} = \\frac{\\sum_i w_i C_i}{\\sum_i w_i E_i}, \\quad w_i = 1 / P(\\text{select}_i). useful hybrid designs sampling varies predictably across modes, times, sites. Compute: () R₁ complete , (b) R₂ incomplete (truncation), (c) combined estimator. differences small (e.g., < 5–10%), pooling assumptions may reasonable; document . apply R₁ unfiltered roving data — biased high due length-biased sampling. apply R₂ complete trips — bias direction depends effort variability. Always truncate short incomplete trips stabilize R₂ reduce small-denominator issues. bag limits frequently hit, cautious R₂ (ceiling effects can distort ratios). Estimate SEs stratum appropriate formula (delta-method R₁; sample variance ratios R₂), combine via delta-method using effort-weight combination .","code":"complete <- data %>% dplyr::filter(trip_complete == TRUE) incomplete <- data %>% dplyr::filter(trip_complete == FALSE, trip_length >= 0.5)  # 0.5 h = 30 min  r1 <- sum(complete$catch) / sum(complete$effort) r2 <- mean(incomplete$catch / incomplete$effort)  E1 <- sum(complete$effort) E2 <- sum(incomplete$effort)  R_combined <- (r1 * E1 + r2 * E2) / (E1 + E2)"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"simulation-study","dir":"Articles","previous_headings":"","what":"Simulation Study","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"theoretical results show estimator choice matters. large bias practice? truncation really help? Let’s demonstrate principles simulation, following approach Rasmussen et al. (1998) Pollock et al. (1997). ’ll simulate realistic fishing scenario compare estimator performance. Simulate traditional access point creel interview anglers finish. Now simulate roving interviews anglers intercepted trips. Run 1000 replications assess bias precision. Access Point Design: Estimator Performance Key Finding: access interviews, estimators approximately unbiased, ratio--means (R₁) typically slightly lower variance.  Access Point Design: Distribution Estimates. estimators center true value (dashed line), demonstrating unbiasedness. ratio--means (R₁) shows slightly tighter clustering, indicating lower variance. Roving Design: Estimator Performance Key Findings: R₁ (ratio--means) BIASED roving interviews - estimate population catch rate R₂ (mean--ratios) without truncation approximately unbiased high variance (unstable) R₂ truncation approximately unbiased lower variance ✓ RECOMMENDED  Roving Design: Effect Truncation. R₁ (ratio--means) biased roving surveys regardless truncation. R₂ (mean--ratios) unbiased high variance without truncation; truncation reduces variance maintaining unbiasedness.","code":"#' Simulate a day of fishing with known parameters #' #' @param n_anglers Number of anglers fishing during the day #' @param mean_trip_hours Mean trip length (hours) #' @param mean_catch_rate Mean catch per hour (Poisson rate parameter) #' @param day_length_hours Length of fishing day #' @return List with population parameters and individual angler data simulate_fishing_day <- function(n_anglers = 100,                                  mean_trip_hours = 4,                                  mean_catch_rate = 2,                                  day_length_hours = 12) {    # Each angler's true catch rate (gamma-distributed for heterogeneity)   # Shape = 1, rate = 1/mean gives exponential with specified mean   # This creates variation in angler skill/success   alpha <- 1   beta <- 1 / mean_catch_rate   catch_rates <- rgamma(n_anglers, shape = alpha, rate = beta)    # Trip lengths (gamma-distributed)   shape_trip <- 4  # Controls variability   rate_trip <- shape_trip / mean_trip_hours   trip_lengths <- rgamma(n_anglers, shape = shape_trip, rate = rate_trip)   trip_lengths <- pmin(trip_lengths, day_length_hours)  # Can't exceed day length    # Generate catches for each angler (Poisson process)   # Expected catch = catch_rate * trip_length   completed_catch <- rpois(n_anglers, lambda = catch_rates * trip_lengths)    # True population parameters   total_effort <- sum(trip_lengths)   total_catch <- sum(completed_catch)   true_catch_rate <- total_catch / total_effort    # Return angler-level data   tibble(     angler_id = 1:n_anglers,     catch_rate_true = catch_rates,     trip_length = trip_lengths,     completed_catch = completed_catch,     true_population_rate = true_catch_rate,     total_effort = total_effort,     total_catch = total_catch   ) }  # Example fishing_day <- simulate_fishing_day(n_anglers = 100) head(fishing_day) # A tibble: 6 × 7   angler_id catch_rate_true trip_length completed_catch true_population_rate       <int>           <dbl>       <dbl>           <int>                <dbl> 1         1           2.00         4.78               7                 2.15 2         2           2.26         1.56               5                 2.15 3         3           0.851        4.74               4                 2.15 4         4           1.03         6.06               5                 2.15 5         5           6.96         4.52              35                 2.15 6         6           0.627        5.59               3                 2.15 # ℹ 2 more variables: total_effort <dbl>, total_catch <int> # Summary of true population parameters cat(\"True Population Parameters:\\n\") True Population Parameters: cat(\"  Total anglers:\", nrow(fishing_day), \"\\n\") Total anglers: 100 cat(\"  Total effort:\", round(fishing_day$total_effort[1], 1), \"hours\\n\") Total effort: 391.8 hours cat(\"  Total catch:\", fishing_day$total_catch[1], \"fish\\n\") Total catch: 844 fish cat(\"  True catch rate:\", round(fishing_day$true_population_rate[1], 3), \"fish/hour\\n\") True catch rate: 2.154 fish/hour #' Simulate access point interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Number of interviews to conduct #' @return Tibble with interview data sample_access_interviews <- function(fishing_day, n_interviews = 30) {   # Simple random sample (equal probability)   sampled <- fishing_day %>%     sample_n(size = min(n_interviews, nrow(fishing_day)), replace = FALSE) %>%     select(angler_id, completed_catch, trip_length, true_population_rate)    sampled }  # Single realization access_sample <- sample_access_interviews(fishing_day, n_interviews = 30) head(access_sample) # A tibble: 6 × 4   angler_id completed_catch trip_length true_population_rate       <int>           <int>       <dbl>                <dbl> 1         1               7        4.78                 2.15 2        69               4        5.05                 2.15 3        79              14        6.27                 2.15 4        19               5        6.75                 2.15 5        12               1        4.72                 2.15 6        64               0        5.88                 2.15 # Calculate both estimators calculate_estimates <- function(interviews, truncate_minutes = NULL) {    # Apply truncation if specified (for roving surveys)   if (!is.null(truncate_minutes)) {     interviews <- interviews %>%       filter(trip_length >= truncate_minutes / 60)   }    n <- nrow(interviews)    # Ratio-of-means   r1 <- sum(interviews$completed_catch) / sum(interviews$trip_length)    # Mean-of-ratios   r2 <- mean(interviews$completed_catch / interviews$trip_length)    # Variance estimates (simplified)   # For R1: use delta method (Taylor series approximation)   # Var(R₁) ≈ (1/n·E̅²) · Var(C - R₁·E)   # where residual = catch - estimated_rate × effort   r <- interviews$completed_catch   e <- interviews$trip_length   r_bar <- mean(r)   e_bar <- mean(e)   var_r1 <- (1 / (n * e_bar^2)) * var(r - r1 * e)   se_r1 <- sqrt(var_r1)    # For R2: simple variance of the ratios   ratios <- interviews$completed_catch / interviews$trip_length   var_r2 <- var(ratios) / n   se_r2 <- sqrt(var_r2)    tibble(     n = n,     ratio_of_means = r1,     mean_of_ratios = r2,     se_r1 = se_r1,     se_r2 = se_r2,     true_rate = interviews$true_population_rate[1]   ) }  access_results <- calculate_estimates(access_sample) access_results # A tibble: 1 × 6       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> 1    30           2.04           2.41 0.401 0.463      2.15 #' Simulate roving interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Target number of interviews #' @return Tibble with incomplete trip interview data sample_roving_interviews <- function(fishing_day, n_interviews = 30) {    # Length-biased sampling: probability of encounter ∝ trip duration   # P(interview angler i) = L_i / Σ L_j (normalized by total effort)   # Longer trips have higher chance of being encountered during roving   prob_intercept <- fishing_day$trip_length / sum(fishing_day$trip_length)    # Sample with probability proportional to size   sampled_indices <- sample(     1:nrow(fishing_day),     size = min(n_interviews, nrow(fishing_day)),     replace = FALSE,     prob = prob_intercept   )    sampled <- fishing_day[sampled_indices, ]    # For each intercepted angler, determine interview time   # Uniform on [0, trip_length] (on average, intercepted at midpoint)   sampled <- sampled %>%     mutate(       # Time fished when interviewed (uniform on [0, trip_length])       # On average, anglers are intercepted at midpoint of their trip       time_at_interview = runif(n(), min = 0, max = trip_length),        # Catch at interview time (incomplete trip)       # Poisson process: E[catch | time_t] = λ × t       # where λ = angler's true catch rate, t = time fished so far       catch_at_interview = rpois(n(), lambda = catch_rate_true * time_at_interview)     ) %>%     select(angler_id, catch_at_interview, time_at_interview,            completed_catch, trip_length, true_population_rate)    sampled }  roving_sample <- sample_roving_interviews(fishing_day, n_interviews = 30) head(roving_sample) # A tibble: 6 × 6   angler_id catch_at_interview time_at_interview completed_catch trip_length       <int>              <int>             <dbl>           <int>       <dbl> 1        27                  1             2.57                2        5.27 2        37                  4             1.46               13        2.99 3        81                  0             0.326               3        3.86 4        32                  1             2.30                8        5.76 5        97                  6             3.54               10        4.81 6        28                  4             2.58                5        2.72 # ℹ 1 more variable: true_population_rate <dbl> # For roving, use incomplete data # Note: calculate_estimates() expects columns named 'completed_catch' and 'trip_length' roving_data <- roving_sample %>%   select(angler_id,          completed_catch = catch_at_interview,          trip_length = time_at_interview,          true_population_rate)  # No truncation roving_no_trunc <- calculate_estimates(roving_data, truncate_minutes = NULL)  # With truncation (30 minutes) roving_with_trunc <- calculate_estimates(roving_data, truncate_minutes = 30)  bind_rows(   roving_no_trunc %>% mutate(truncation = \"None\"),   roving_with_trunc %>% mutate(truncation = \"30 min\") ) # A tibble: 2 × 7       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate truncation   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> <chr> 1    30           1.98           1.77 0.329 0.289      2.15 None 2    27           1.97           1.67 0.334 0.281      2.15 30 min run_simulation <- function(n_reps = 1000,                            n_anglers = 100,                            n_interviews = 30,                            interview_type = c(\"access\", \"roving\")) {    interview_type <- match.arg(interview_type)    results <- map_dfr(1:n_reps, function(rep) {     # Generate population     day <- simulate_fishing_day(n_anglers = n_anglers)     true_rate <- day$true_population_rate[1]      # Sample based on design     if (interview_type == \"access\") {       sample_data <- sample_access_interviews(day, n_interviews)       sample_data <- sample_data %>%         rename(catch = completed_catch, effort = trip_length)     } else {       sample_data <- sample_roving_interviews(day, n_interviews) %>%         rename(catch = catch_at_interview, effort = time_at_interview)     }      # Calculate estimators     # No truncation     r1_no <- sum(sample_data$catch) / sum(sample_data$effort)     r2_no <- mean(sample_data$catch / sample_data$effort)      # With truncation (30 min = 0.5 hr)     trunc_data <- sample_data %>% filter(effort >= 0.5)     if (nrow(trunc_data) > 0) {       r1_trunc <- sum(trunc_data$catch) / sum(trunc_data$effort)       r2_trunc <- mean(trunc_data$catch / trunc_data$effort)     } else {       r1_trunc <- NA       r2_trunc <- NA     }      tibble(       rep = rep,       true_rate = true_rate,       r1_no_trunc = r1_no,       r2_no_trunc = r2_no,       r1_with_trunc = r1_trunc,       r2_with_trunc = r2_trunc,       n_interviews = n_interviews,       n_after_trunc = nrow(trunc_data)     )   })    results %>%     mutate(design = interview_type) }  # Run simulations access_mc <- run_simulation(n_reps = 1000, interview_type = \"access\") roving_mc <- run_simulation(n_reps = 1000, interview_type = \"roving\") # Summary statistics access_summary <- access_mc %>%   summarise(     true_rate = mean(true_rate),      # Ratio of means (R1)     r1_mean = mean(r1_no_trunc),     r1_bias = mean(r1_no_trunc - true_rate),     r1_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate),     r1_rmse = sqrt(mean((r1_no_trunc - true_rate)^2)),     r1_se = sd(r1_no_trunc),      # Mean of ratios (R2)     r2_mean = mean(r2_no_trunc),     r2_bias = mean(r2_no_trunc - true_rate),     r2_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate),     r2_rmse = sqrt(mean((r2_no_trunc - true_rate)^2)),     r2_se = sd(r2_no_trunc)   )  access_summary %>%   pivot_longer(cols = -true_rate, names_to = c(\"estimator\", \"metric\"), names_sep = \"_\", values_to = \"value\", names_repair = \"minimal\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   select(estimator, mean, bias, pct, se, rmse) %>%   rename(pct_bias = pct) %>%   knitr::kable(digits = 4, caption = \"Access Point Design: Estimator Performance\") access_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc) %>%   pivot_longer(cols = c(r1_no_trunc, r2_no_trunc),                names_to = \"estimator\",                values_to = \"estimate\") %>%   mutate(estimator = recode(estimator,                             r1_no_trunc = \"Ratio of Means (R₁)\",                             r2_no_trunc = \"Mean of Ratios (R₂)\")) %>%   ggplot(aes(x = estimate, fill = estimator)) +   geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +   geom_vline(aes(xintercept = mean(true_rate)), linetype = \"dashed\", size = 1) +   facet_wrap(~estimator, ncol = 1) +   labs(title = \"Access Point Design: Sampling Distribution\",        subtitle = \"Dashed line = true population catch rate\",        x = \"Estimated Catch Rate (fish/hour)\",        y = \"Frequency\") +   theme_minimal() +   theme(legend.position = \"none\") # Summary statistics roving_summary <- roving_mc %>%   summarise(     true_rate = mean(true_rate),      # R1 no truncation     r1_no_mean = mean(r1_no_trunc, na.rm = TRUE),     r1_no_bias = mean(r1_no_trunc - true_rate, na.rm = TRUE),     r1_no_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_no_rmse = sqrt(mean((r1_no_trunc - true_rate)^2, na.rm = TRUE)),      # R2 no truncation     r2_no_mean = mean(r2_no_trunc, na.rm = TRUE),     r2_no_bias = mean(r2_no_trunc - true_rate, na.rm = TRUE),     r2_no_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_no_rmse = sqrt(mean((r2_no_trunc - true_rate)^2, na.rm = TRUE)),      # R1 with truncation     r1_trunc_mean = mean(r1_with_trunc, na.rm = TRUE),     r1_trunc_bias = mean(r1_with_trunc - true_rate, na.rm = TRUE),     r1_trunc_pct_bias = 100 * mean((r1_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_trunc_rmse = sqrt(mean((r1_with_trunc - true_rate)^2, na.rm = TRUE)),      # R2 with truncation     r2_trunc_mean = mean(r2_with_trunc, na.rm = TRUE),     r2_trunc_bias = mean(r2_with_trunc - true_rate, na.rm = TRUE),     r2_trunc_pct_bias = 100 * mean((r2_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_trunc_rmse = sqrt(mean((r2_with_trunc - true_rate)^2, na.rm = TRUE))   )  roving_summary %>%   pivot_longer(cols = -true_rate,                names_to = c(\"estimator\", \"truncation\", \"metric\"),                names_pattern = \"([^_]+)_([^_]+)_(.*)\",                values_to = \"value\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   mutate(estimator = recode(estimator, r1 = \"Ratio of Means\", r2 = \"Mean of Ratios\"),          truncation = recode(truncation, no = \"No truncation\", trunc = \"30-min truncation\")) %>%   select(estimator, truncation, mean, bias, pct_bias, rmse) %>%   knitr::kable(digits = 4, caption = \"Roving Design: Estimator Performance\") roving_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc, r1_with_trunc, r2_with_trunc) %>%   pivot_longer(cols = -c(rep, true_rate),                names_to = \"estimator\",                values_to = \"estimate\") %>%   filter(!is.na(estimate)) %>%   mutate(     estimator_type = ifelse(grepl(\"r1\", estimator), \"Ratio of Means (R₁)\", \"Mean of Ratios (R₂)\"),     truncation = ifelse(grepl(\"no_trunc\", estimator), \"No Truncation\", \"30-Min Truncation\")   ) %>%   ggplot(aes(x = estimate, fill = truncation)) +   geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +   geom_vline(aes(xintercept = mean(true_rate)), linetype = \"dashed\", size = 1) +   facet_grid(estimator_type ~ truncation, scales = \"free_y\") +   labs(title = \"Roving Design: Impact of Estimator Choice and Truncation\",        subtitle = \"Dashed line = true population catch rate\",        x = \"Estimated Catch Rate (fish/hour)\",        y = \"Frequency\",        fill = \"Truncation\") +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"simulation-setup","dir":"Articles","previous_headings":"","what":"Simulation Setup","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"’ll simulate realistic fishing scenario compare estimator performance.","code":"#' Simulate a day of fishing with known parameters #' #' @param n_anglers Number of anglers fishing during the day #' @param mean_trip_hours Mean trip length (hours) #' @param mean_catch_rate Mean catch per hour (Poisson rate parameter) #' @param day_length_hours Length of fishing day #' @return List with population parameters and individual angler data simulate_fishing_day <- function(n_anglers = 100,                                  mean_trip_hours = 4,                                  mean_catch_rate = 2,                                  day_length_hours = 12) {    # Each angler's true catch rate (gamma-distributed for heterogeneity)   # Shape = 1, rate = 1/mean gives exponential with specified mean   # This creates variation in angler skill/success   alpha <- 1   beta <- 1 / mean_catch_rate   catch_rates <- rgamma(n_anglers, shape = alpha, rate = beta)    # Trip lengths (gamma-distributed)   shape_trip <- 4  # Controls variability   rate_trip <- shape_trip / mean_trip_hours   trip_lengths <- rgamma(n_anglers, shape = shape_trip, rate = rate_trip)   trip_lengths <- pmin(trip_lengths, day_length_hours)  # Can't exceed day length    # Generate catches for each angler (Poisson process)   # Expected catch = catch_rate * trip_length   completed_catch <- rpois(n_anglers, lambda = catch_rates * trip_lengths)    # True population parameters   total_effort <- sum(trip_lengths)   total_catch <- sum(completed_catch)   true_catch_rate <- total_catch / total_effort    # Return angler-level data   tibble(     angler_id = 1:n_anglers,     catch_rate_true = catch_rates,     trip_length = trip_lengths,     completed_catch = completed_catch,     true_population_rate = true_catch_rate,     total_effort = total_effort,     total_catch = total_catch   ) }  # Example fishing_day <- simulate_fishing_day(n_anglers = 100) head(fishing_day) # A tibble: 6 × 7   angler_id catch_rate_true trip_length completed_catch true_population_rate       <int>           <dbl>       <dbl>           <int>                <dbl> 1         1           2.00         4.78               7                 2.15 2         2           2.26         1.56               5                 2.15 3         3           0.851        4.74               4                 2.15 4         4           1.03         6.06               5                 2.15 5         5           6.96         4.52              35                 2.15 6         6           0.627        5.59               3                 2.15 # ℹ 2 more variables: total_effort <dbl>, total_catch <int> # Summary of true population parameters cat(\"True Population Parameters:\\n\") True Population Parameters: cat(\"  Total anglers:\", nrow(fishing_day), \"\\n\") Total anglers: 100 cat(\"  Total effort:\", round(fishing_day$total_effort[1], 1), \"hours\\n\") Total effort: 391.8 hours cat(\"  Total catch:\", fishing_day$total_catch[1], \"fish\\n\") Total catch: 844 fish cat(\"  True catch rate:\", round(fishing_day$true_population_rate[1], 3), \"fish/hour\\n\") True catch rate: 2.154 fish/hour"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"scenario-1-access-point-interviews-complete-trips","dir":"Articles","previous_headings":"","what":"Scenario 1: Access Point Interviews (Complete Trips)","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Simulate traditional access point creel interview anglers finish.","code":"#' Simulate access point interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Number of interviews to conduct #' @return Tibble with interview data sample_access_interviews <- function(fishing_day, n_interviews = 30) {   # Simple random sample (equal probability)   sampled <- fishing_day %>%     sample_n(size = min(n_interviews, nrow(fishing_day)), replace = FALSE) %>%     select(angler_id, completed_catch, trip_length, true_population_rate)    sampled }  # Single realization access_sample <- sample_access_interviews(fishing_day, n_interviews = 30) head(access_sample) # A tibble: 6 × 4   angler_id completed_catch trip_length true_population_rate       <int>           <int>       <dbl>                <dbl> 1         1               7        4.78                 2.15 2        69               4        5.05                 2.15 3        79              14        6.27                 2.15 4        19               5        6.75                 2.15 5        12               1        4.72                 2.15 6        64               0        5.88                 2.15 # Calculate both estimators calculate_estimates <- function(interviews, truncate_minutes = NULL) {    # Apply truncation if specified (for roving surveys)   if (!is.null(truncate_minutes)) {     interviews <- interviews %>%       filter(trip_length >= truncate_minutes / 60)   }    n <- nrow(interviews)    # Ratio-of-means   r1 <- sum(interviews$completed_catch) / sum(interviews$trip_length)    # Mean-of-ratios   r2 <- mean(interviews$completed_catch / interviews$trip_length)    # Variance estimates (simplified)   # For R1: use delta method (Taylor series approximation)   # Var(R₁) ≈ (1/n·E̅²) · Var(C - R₁·E)   # where residual = catch - estimated_rate × effort   r <- interviews$completed_catch   e <- interviews$trip_length   r_bar <- mean(r)   e_bar <- mean(e)   var_r1 <- (1 / (n * e_bar^2)) * var(r - r1 * e)   se_r1 <- sqrt(var_r1)    # For R2: simple variance of the ratios   ratios <- interviews$completed_catch / interviews$trip_length   var_r2 <- var(ratios) / n   se_r2 <- sqrt(var_r2)    tibble(     n = n,     ratio_of_means = r1,     mean_of_ratios = r2,     se_r1 = se_r1,     se_r2 = se_r2,     true_rate = interviews$true_population_rate[1]   ) }  access_results <- calculate_estimates(access_sample) access_results # A tibble: 1 × 6       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> 1    30           2.04           2.41 0.401 0.463      2.15"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"scenario-2-roving-interviews-incomplete-trips","dir":"Articles","previous_headings":"","what":"Scenario 2: Roving Interviews (Incomplete Trips)","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Now simulate roving interviews anglers intercepted trips.","code":"#' Simulate roving interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Target number of interviews #' @return Tibble with incomplete trip interview data sample_roving_interviews <- function(fishing_day, n_interviews = 30) {    # Length-biased sampling: probability of encounter ∝ trip duration   # P(interview angler i) = L_i / Σ L_j (normalized by total effort)   # Longer trips have higher chance of being encountered during roving   prob_intercept <- fishing_day$trip_length / sum(fishing_day$trip_length)    # Sample with probability proportional to size   sampled_indices <- sample(     1:nrow(fishing_day),     size = min(n_interviews, nrow(fishing_day)),     replace = FALSE,     prob = prob_intercept   )    sampled <- fishing_day[sampled_indices, ]    # For each intercepted angler, determine interview time   # Uniform on [0, trip_length] (on average, intercepted at midpoint)   sampled <- sampled %>%     mutate(       # Time fished when interviewed (uniform on [0, trip_length])       # On average, anglers are intercepted at midpoint of their trip       time_at_interview = runif(n(), min = 0, max = trip_length),        # Catch at interview time (incomplete trip)       # Poisson process: E[catch | time_t] = λ × t       # where λ = angler's true catch rate, t = time fished so far       catch_at_interview = rpois(n(), lambda = catch_rate_true * time_at_interview)     ) %>%     select(angler_id, catch_at_interview, time_at_interview,            completed_catch, trip_length, true_population_rate)    sampled }  roving_sample <- sample_roving_interviews(fishing_day, n_interviews = 30) head(roving_sample) # A tibble: 6 × 6   angler_id catch_at_interview time_at_interview completed_catch trip_length       <int>              <int>             <dbl>           <int>       <dbl> 1        27                  1             2.57                2        5.27 2        37                  4             1.46               13        2.99 3        81                  0             0.326               3        3.86 4        32                  1             2.30                8        5.76 5        97                  6             3.54               10        4.81 6        28                  4             2.58                5        2.72 # ℹ 1 more variable: true_population_rate <dbl> # For roving, use incomplete data # Note: calculate_estimates() expects columns named 'completed_catch' and 'trip_length' roving_data <- roving_sample %>%   select(angler_id,          completed_catch = catch_at_interview,          trip_length = time_at_interview,          true_population_rate)  # No truncation roving_no_trunc <- calculate_estimates(roving_data, truncate_minutes = NULL)  # With truncation (30 minutes) roving_with_trunc <- calculate_estimates(roving_data, truncate_minutes = 30)  bind_rows(   roving_no_trunc %>% mutate(truncation = \"None\"),   roving_with_trunc %>% mutate(truncation = \"30 min\") ) # A tibble: 2 × 7       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate truncation   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> <chr> 1    30           1.98           1.77 0.329 0.289      2.15 None 2    27           1.97           1.67 0.334 0.281      2.15 30 min"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"monte-carlo-simulation","dir":"Articles","previous_headings":"","what":"Monte Carlo Simulation","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Run 1000 replications assess bias precision.","code":"run_simulation <- function(n_reps = 1000,                            n_anglers = 100,                            n_interviews = 30,                            interview_type = c(\"access\", \"roving\")) {    interview_type <- match.arg(interview_type)    results <- map_dfr(1:n_reps, function(rep) {     # Generate population     day <- simulate_fishing_day(n_anglers = n_anglers)     true_rate <- day$true_population_rate[1]      # Sample based on design     if (interview_type == \"access\") {       sample_data <- sample_access_interviews(day, n_interviews)       sample_data <- sample_data %>%         rename(catch = completed_catch, effort = trip_length)     } else {       sample_data <- sample_roving_interviews(day, n_interviews) %>%         rename(catch = catch_at_interview, effort = time_at_interview)     }      # Calculate estimators     # No truncation     r1_no <- sum(sample_data$catch) / sum(sample_data$effort)     r2_no <- mean(sample_data$catch / sample_data$effort)      # With truncation (30 min = 0.5 hr)     trunc_data <- sample_data %>% filter(effort >= 0.5)     if (nrow(trunc_data) > 0) {       r1_trunc <- sum(trunc_data$catch) / sum(trunc_data$effort)       r2_trunc <- mean(trunc_data$catch / trunc_data$effort)     } else {       r1_trunc <- NA       r2_trunc <- NA     }      tibble(       rep = rep,       true_rate = true_rate,       r1_no_trunc = r1_no,       r2_no_trunc = r2_no,       r1_with_trunc = r1_trunc,       r2_with_trunc = r2_trunc,       n_interviews = n_interviews,       n_after_trunc = nrow(trunc_data)     )   })    results %>%     mutate(design = interview_type) }  # Run simulations access_mc <- run_simulation(n_reps = 1000, interview_type = \"access\") roving_mc <- run_simulation(n_reps = 1000, interview_type = \"roving\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"results-access-point-design","dir":"Articles","previous_headings":"","what":"Results: Access Point Design","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Access Point Design: Estimator Performance Key Finding: access interviews, estimators approximately unbiased, ratio--means (R₁) typically slightly lower variance.  Access Point Design: Distribution Estimates. estimators center true value (dashed line), demonstrating unbiasedness. ratio--means (R₁) shows slightly tighter clustering, indicating lower variance.","code":"# Summary statistics access_summary <- access_mc %>%   summarise(     true_rate = mean(true_rate),      # Ratio of means (R1)     r1_mean = mean(r1_no_trunc),     r1_bias = mean(r1_no_trunc - true_rate),     r1_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate),     r1_rmse = sqrt(mean((r1_no_trunc - true_rate)^2)),     r1_se = sd(r1_no_trunc),      # Mean of ratios (R2)     r2_mean = mean(r2_no_trunc),     r2_bias = mean(r2_no_trunc - true_rate),     r2_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate),     r2_rmse = sqrt(mean((r2_no_trunc - true_rate)^2)),     r2_se = sd(r2_no_trunc)   )  access_summary %>%   pivot_longer(cols = -true_rate, names_to = c(\"estimator\", \"metric\"), names_sep = \"_\", values_to = \"value\", names_repair = \"minimal\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   select(estimator, mean, bias, pct, se, rmse) %>%   rename(pct_bias = pct) %>%   knitr::kable(digits = 4, caption = \"Access Point Design: Estimator Performance\") access_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc) %>%   pivot_longer(cols = c(r1_no_trunc, r2_no_trunc),                names_to = \"estimator\",                values_to = \"estimate\") %>%   mutate(estimator = recode(estimator,                             r1_no_trunc = \"Ratio of Means (R₁)\",                             r2_no_trunc = \"Mean of Ratios (R₂)\")) %>%   ggplot(aes(x = estimate, fill = estimator)) +   geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +   geom_vline(aes(xintercept = mean(true_rate)), linetype = \"dashed\", size = 1) +   facet_wrap(~estimator, ncol = 1) +   labs(title = \"Access Point Design: Sampling Distribution\",        subtitle = \"Dashed line = true population catch rate\",        x = \"Estimated Catch Rate (fish/hour)\",        y = \"Frequency\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"results-roving-design","dir":"Articles","previous_headings":"","what":"Results: Roving Design","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Roving Design: Estimator Performance Key Findings: R₁ (ratio--means) BIASED roving interviews - estimate population catch rate R₂ (mean--ratios) without truncation approximately unbiased high variance (unstable) R₂ truncation approximately unbiased lower variance ✓ RECOMMENDED  Roving Design: Effect Truncation. R₁ (ratio--means) biased roving surveys regardless truncation. R₂ (mean--ratios) unbiased high variance without truncation; truncation reduces variance maintaining unbiasedness.","code":"# Summary statistics roving_summary <- roving_mc %>%   summarise(     true_rate = mean(true_rate),      # R1 no truncation     r1_no_mean = mean(r1_no_trunc, na.rm = TRUE),     r1_no_bias = mean(r1_no_trunc - true_rate, na.rm = TRUE),     r1_no_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_no_rmse = sqrt(mean((r1_no_trunc - true_rate)^2, na.rm = TRUE)),      # R2 no truncation     r2_no_mean = mean(r2_no_trunc, na.rm = TRUE),     r2_no_bias = mean(r2_no_trunc - true_rate, na.rm = TRUE),     r2_no_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_no_rmse = sqrt(mean((r2_no_trunc - true_rate)^2, na.rm = TRUE)),      # R1 with truncation     r1_trunc_mean = mean(r1_with_trunc, na.rm = TRUE),     r1_trunc_bias = mean(r1_with_trunc - true_rate, na.rm = TRUE),     r1_trunc_pct_bias = 100 * mean((r1_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_trunc_rmse = sqrt(mean((r1_with_trunc - true_rate)^2, na.rm = TRUE)),      # R2 with truncation     r2_trunc_mean = mean(r2_with_trunc, na.rm = TRUE),     r2_trunc_bias = mean(r2_with_trunc - true_rate, na.rm = TRUE),     r2_trunc_pct_bias = 100 * mean((r2_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_trunc_rmse = sqrt(mean((r2_with_trunc - true_rate)^2, na.rm = TRUE))   )  roving_summary %>%   pivot_longer(cols = -true_rate,                names_to = c(\"estimator\", \"truncation\", \"metric\"),                names_pattern = \"([^_]+)_([^_]+)_(.*)\",                values_to = \"value\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   mutate(estimator = recode(estimator, r1 = \"Ratio of Means\", r2 = \"Mean of Ratios\"),          truncation = recode(truncation, no = \"No truncation\", trunc = \"30-min truncation\")) %>%   select(estimator, truncation, mean, bias, pct_bias, rmse) %>%   knitr::kable(digits = 4, caption = \"Roving Design: Estimator Performance\") roving_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc, r1_with_trunc, r2_with_trunc) %>%   pivot_longer(cols = -c(rep, true_rate),                names_to = \"estimator\",                values_to = \"estimate\") %>%   filter(!is.na(estimate)) %>%   mutate(     estimator_type = ifelse(grepl(\"r1\", estimator), \"Ratio of Means (R₁)\", \"Mean of Ratios (R₂)\"),     truncation = ifelse(grepl(\"no_trunc\", estimator), \"No Truncation\", \"30-Min Truncation\")   ) %>%   ggplot(aes(x = estimate, fill = truncation)) +   geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +   geom_vline(aes(xintercept = mean(true_rate)), linetype = \"dashed\", size = 1) +   facet_grid(estimator_type ~ truncation, scales = \"free_y\") +   labs(title = \"Roving Design: Impact of Estimator Choice and Truncation\",        subtitle = \"Dashed line = true population catch rate\",        x = \"Estimated Catch Rate (fish/hour)\",        y = \"Frequency\",        fill = \"Truncation\") +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"practical-implementation-with-tidycreel","dir":"Articles","previous_headings":"","what":"Practical Implementation with tidycreel","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"","code":"# Assuming you have complete-trip interview data interviews_complete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 8),   hours_fished = rgamma(100, shape = 4, rate = 1),   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # Create survey design svy_interviews <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_complete )  # Use RATIO-OF-MEANS (default and recommended) cpue_access <- est_cpue(   design = svy_interviews,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"ratio_of_means\"  # ✓ Correct for access interviews )  cpue_access # Assuming you have incomplete-trip interview data interviews_incomplete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 4),  # Catch so far   hours_fished = runif(100, min = 0.2, max = 6),  # Time so far   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # IMPORTANT: Truncate short trips before analysis interviews_truncated <- interviews_incomplete %>%   filter(hours_fished >= 0.5)  # Remove trips < 30 minutes  # Create survey design svy_roving <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_truncated )  # Use MEAN-OF-RATIOS for roving interviews cpue_roving <- est_cpue(   design = svy_roving,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"mean_of_ratios\"  # ✓ Correct for roving interviews )  cpue_roving"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"access-point-survey-example","dir":"Articles","previous_headings":"","what":"Access Point Survey Example","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"","code":"# Assuming you have complete-trip interview data interviews_complete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 8),   hours_fished = rgamma(100, shape = 4, rate = 1),   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # Create survey design svy_interviews <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_complete )  # Use RATIO-OF-MEANS (default and recommended) cpue_access <- est_cpue(   design = svy_interviews,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"ratio_of_means\"  # ✓ Correct for access interviews )  cpue_access"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"roving-survey-example","dir":"Articles","previous_headings":"","what":"Roving Survey Example","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"","code":"# Assuming you have incomplete-trip interview data interviews_incomplete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 4),  # Catch so far   hours_fished = runif(100, min = 0.2, max = 6),  # Time so far   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # IMPORTANT: Truncate short trips before analysis interviews_truncated <- interviews_incomplete %>%   filter(hours_fished >= 0.5)  # Remove trips < 30 minutes  # Create survey design svy_roving <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_truncated )  # Use MEAN-OF-RATIOS for roving interviews cpue_roving <- est_cpue(   design = svy_roving,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"mean_of_ratios\"  # ✓ Correct for roving interviews )  cpue_roving"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"variance-estimation","dir":"Articles","previous_headings":"","what":"Variance Estimation","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"ratio--means survey weights, survey package automatically uses delta method: Note: variance formulas assume sampling infinite (large) population. sample size substantial relative total number anglers (n/N > 5%), may want apply finite population correction (FPC): multiply variance (1 - n/N). However, creel surveys population potential anglers large, correction negligible. [(_1) (C - _1 E)] (C) = catch, (E) = effort. mean--ratios, variance straightforward: [(_2) = ()]","code":"# survey::svyratio() provides proper variance cpue_result <- est_cpue(design = svy_interviews, mode = \"ratio_of_means\")  # Standard error is included cpue_result$se  # 95% confidence interval cpue_result$ci_low cpue_result$ci_high # survey::svymean() on the ratio variable cpue_roving <- est_cpue(design = svy_roving, mode = \"mean_of_ratios\")  # Standard error and CIs included cpue_roving$se cpue_roving$ci_low cpue_roving$ci_high"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"access-point-ratio-of-means","dir":"Articles","previous_headings":"","what":"Access Point (Ratio-of-Means)","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"ratio--means survey weights, survey package automatically uses delta method: Note: variance formulas assume sampling infinite (large) population. sample size substantial relative total number anglers (n/N > 5%), may want apply finite population correction (FPC): multiply variance (1 - n/N). However, creel surveys population potential anglers large, correction negligible. [(_1) (C - _1 E)] (C) = catch, (E) = effort.","code":"# survey::svyratio() provides proper variance cpue_result <- est_cpue(design = svy_interviews, mode = \"ratio_of_means\")  # Standard error is included cpue_result$se  # 95% confidence interval cpue_result$ci_low cpue_result$ci_high"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"roving-mean-of-ratios-with-truncation","dir":"Articles","previous_headings":"","what":"Roving (Mean-of-Ratios with Truncation)","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"mean--ratios, variance straightforward: [(_2) = ()]","code":"# survey::svymean() on the ratio variable cpue_roving <- est_cpue(design = svy_roving, mode = \"mean_of_ratios\")  # Standard error and CIs included cpue_roving$se cpue_roving$ci_low cpue_roving$ci_high"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"special-considerations","dir":"Articles","previous_headings":"","what":"Special Considerations","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"⚠️ CRITICAL WARNING: Roving surveys can produce severe negative bias (underestimation 20-50%+) bag limits low (≤5 fish) anglers comply leaving immediately upon reaching limit. Problem: anglers leave immediately catching limit, roving clerk encounter unsuccessful anglers, leading severe underestimation. Example simulation (bag limit = 2 fish): Roving Bias Different Bag Limits Recommendation: bag limits low (≤5 fish) compliance high, use access point interviews instead roving. catch rates change systematically trips (e.g., learning curve, time--day effects), roving interviews may biased. Check : Comparing incomplete-trip catch rates complete-trip catch rates Looking patterns catch rate vs. time--day nonstationary: Consider access point interviews model time-varying catch rate.","code":"simulate_with_bag_limit <- function(n_reps = 500, bag_limit = 2) {   map_dfr(1:n_reps, function(rep) {     # Simulate fishing day     day <- simulate_fishing_day(n_anglers = 100)     true_rate <- day$true_population_rate[1]      # Apply bag limit: anglers stop when limit reached     day_limited <- day %>%       mutate(         # Time to reach bag limit (exponential waiting time)         time_to_limit = ifelse(catch_rate_true > 0,                                bag_limit / catch_rate_true,                                Inf),         # Actual trip length (stop at limit or planned end, whichever comes first)         actual_trip_length = pmin(trip_length, time_to_limit),         # Actual catch (capped at bag limit)         actual_catch = pmin(completed_catch, bag_limit),         # Did angler reach bag limit before planned trip end?         reached_limit = (time_to_limit < trip_length)       )      # Roving interviews can only encounter anglers still on-site     # Those who reached bag limit before their planned trip end have already left     # Only those who haven't reached the limit OR reached it at/after planned end are available     still_fishing <- day_limited %>%       filter(!reached_limit)      if (nrow(still_fishing) > 10) {       # Sample from those still fishing       sample_data <- sample_roving_interviews(still_fishing, n_interviews = 30) %>%         rename(catch = catch_at_interview, effort = time_at_interview) %>%         filter(effort >= 0.5)        if (nrow(sample_data) > 0) {         r2 <- mean(sample_data$catch / sample_data$effort)         return(tibble(rep = rep, true_rate = true_rate, estimated_rate = r2,                      bag_limit = bag_limit))       }     }      tibble(rep = rep, true_rate = true_rate, estimated_rate = NA, bag_limit = bag_limit)   }) }  bag_limit_results <- bind_rows(   simulate_with_bag_limit(bag_limit = 2),   simulate_with_bag_limit(bag_limit = 5),   simulate_with_bag_limit(bag_limit = 10) )  bag_limit_summary <- bag_limit_results %>%   filter(!is.na(estimated_rate)) %>%   group_by(bag_limit) %>%   summarise(     true_rate = mean(true_rate),     mean_estimate = mean(estimated_rate),     bias = mean(estimated_rate - true_rate),     pct_bias = 100 * mean((estimated_rate - true_rate) / true_rate)   )  bag_limit_summary %>%   knitr::kable(digits = 3, caption = \"Roving Bias Under Different Bag Limits\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"bag-limits","dir":"Articles","previous_headings":"","what":"Bag Limits","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"⚠️ CRITICAL WARNING: Roving surveys can produce severe negative bias (underestimation 20-50%+) bag limits low (≤5 fish) anglers comply leaving immediately upon reaching limit. Problem: anglers leave immediately catching limit, roving clerk encounter unsuccessful anglers, leading severe underestimation. Example simulation (bag limit = 2 fish): Roving Bias Different Bag Limits Recommendation: bag limits low (≤5 fish) compliance high, use access point interviews instead roving.","code":"simulate_with_bag_limit <- function(n_reps = 500, bag_limit = 2) {   map_dfr(1:n_reps, function(rep) {     # Simulate fishing day     day <- simulate_fishing_day(n_anglers = 100)     true_rate <- day$true_population_rate[1]      # Apply bag limit: anglers stop when limit reached     day_limited <- day %>%       mutate(         # Time to reach bag limit (exponential waiting time)         time_to_limit = ifelse(catch_rate_true > 0,                                bag_limit / catch_rate_true,                                Inf),         # Actual trip length (stop at limit or planned end, whichever comes first)         actual_trip_length = pmin(trip_length, time_to_limit),         # Actual catch (capped at bag limit)         actual_catch = pmin(completed_catch, bag_limit),         # Did angler reach bag limit before planned trip end?         reached_limit = (time_to_limit < trip_length)       )      # Roving interviews can only encounter anglers still on-site     # Those who reached bag limit before their planned trip end have already left     # Only those who haven't reached the limit OR reached it at/after planned end are available     still_fishing <- day_limited %>%       filter(!reached_limit)      if (nrow(still_fishing) > 10) {       # Sample from those still fishing       sample_data <- sample_roving_interviews(still_fishing, n_interviews = 30) %>%         rename(catch = catch_at_interview, effort = time_at_interview) %>%         filter(effort >= 0.5)        if (nrow(sample_data) > 0) {         r2 <- mean(sample_data$catch / sample_data$effort)         return(tibble(rep = rep, true_rate = true_rate, estimated_rate = r2,                      bag_limit = bag_limit))       }     }      tibble(rep = rep, true_rate = true_rate, estimated_rate = NA, bag_limit = bag_limit)   }) }  bag_limit_results <- bind_rows(   simulate_with_bag_limit(bag_limit = 2),   simulate_with_bag_limit(bag_limit = 5),   simulate_with_bag_limit(bag_limit = 10) )  bag_limit_summary <- bag_limit_results %>%   filter(!is.na(estimated_rate)) %>%   group_by(bag_limit) %>%   summarise(     true_rate = mean(true_rate),     mean_estimate = mean(estimated_rate),     bias = mean(estimated_rate - true_rate),     pct_bias = 100 * mean((estimated_rate - true_rate) / true_rate)   )  bag_limit_summary %>%   knitr::kable(digits = 3, caption = \"Roving Bias Under Different Bag Limits\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"nonstationary-catch-rates","dir":"Articles","previous_headings":"","what":"Nonstationary Catch Rates","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"catch rates change systematically trips (e.g., learning curve, time--day effects), roving interviews may biased. Check : Comparing incomplete-trip catch rates complete-trip catch rates Looking patterns catch rate vs. time--day nonstationary: Consider access point interviews model time-varying catch rate.","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"summary-practical-guidelines","dir":"Articles","previous_headings":"","what":"Summary: Practical Guidelines","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"surveys: Check missing data catch effort Verify effort > 0 interviews Check outliers (data entry errors) ROVING surveys specifically: Truncate short trips (< 20-30 minutes) Check bag limit compliance (may cause bias) Verify catch rate stationarity (possible) Use proper survey weights svydesign() Include stratification variables Use svyratio() ratio--means Use svymean() catch/effort ratio mean--ratios Report standard errors confidence intervals","code":""},{"path":[]},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"pre-processing-checklist","dir":"Articles","previous_headings":"","what":"Pre-processing Checklist","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"surveys: Check missing data catch effort Verify effort > 0 interviews Check outliers (data entry errors) ROVING surveys specifically: Truncate short trips (< 20-30 minutes) Check bag limit compliance (may cause bias) Verify catch rate stationarity (possible)","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"variance-estimation-checklist","dir":"Articles","previous_headings":"","what":"Variance Estimation Checklist","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Use proper survey weights svydesign() Include stratification variables Use svyratio() ratio--means Use svymean() catch/effort ratio mean--ratios Report standard errors confidence intervals","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Pollock, K.H., Hoenig, J.M., Jones, C.M., Robson, D.S., & Greene, C.J. (1997). Catch rate estimation roving access point surveys. North American Journal Fisheries Management, 17(1), 11-19. Rasmussen, P.W., Staggs, M.D., Beard, T.D., & Newman, S.P. (1998). Bias confidence interval coverage creel survey estimators evaluated simulation. Transactions American Fisheries Society, 127(3), 469-480. Jones, C.M., Robson, D.S., Lakkis, H.D., & Kressel, J. (1995). Properties catch rates used analysis angler surveys. Transactions American Fisheries Society, 124(6), 911-928. Lumley, T. (2004). Analysis complex survey samples. Journal Statistical Software, 9(1), 1-19.","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"conclusion","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"choice ratio--means mean--ratios depends fundamentally survey design: Access point interviews → Use ratio--means Roving interviews → Use mean--ratios truncation tidycreel package implements estimators proper variance estimation survey package. following decision rules vignette, can ensure catch rate estimates unbiased confidence intervals correct coverage.","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"introduction-1","dir":"Articles","previous_headings":"","what":"Introduction","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"One common questions creel survey analysis : “use ratio--means mean--ratios estimate catch rate?” vignette answers question : Decision rules based survey design type Simulation demonstrations showing estimator performance Practical guidance variance estimation Clear examples using tidycreel","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"quick-answer-decision-tree-1","dir":"Articles","previous_headings":"","what":"Quick Answer: Decision Tree","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"","code":"┌─────────────────────────────────────────────┐ │   What type of interviews do you have?      │ └─────────────────┬───────────────────────────┘                   │         ┌─────────┴─────────┐         │                   │     ┌───▼──────┐          ┌───▼────────┐     │ ACCESS   │          │ ROVING     │     │(Complete │          │(Incomplete │     │ trips)   │          │  trips)    │     └───┬──────┘          └───┬────────┘         │                     │         │                     │     ┌───▼─────────────────┐   │     │ Use RATIO-OF-MEANS  │   │     │  R₁ = Σcatch/Σeffort│   │     │                     │   │     │ Why? Each angler    │   │     │ has equal sampling  │   │     │ probability.        │   │     │                     │   │     │ ✓ Unbiased          │   │     │ ✓ Finite variance   │   │     └─────────────────────┘   │                               │                   ┌───────────▼────────────────┐                   │ Use MEAN-OF-RATIOS         │                   │  R₂ = (1/n)Σ(catch/effort) │                   │                            │                   │ IMPORTANT: Truncate short  │                   │ trips (< 20-30 minutes)    │                   │                            │                   │ Why? Sampling probability  │                   │ ∝ trip length. R₁ would    │                   │ give biased estimate.      │                   │                            │                   │ ⚠ Avoid if bag limits      │                   │   are low & easily obtained│                   └────────────────────────────┘"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"theoretical-background-1","dir":"Articles","previous_headings":"","what":"Theoretical Background","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Sampling Design: Interviews conducted anglers complete trips anglers equal probability interviewed P(interviewed) = constant, regardless trip length Appropriate Estimator: Ratio--Means (R₁) [_1 = ] (C_j^) = total catch completed trip (L_j^) = total trip length completion. Expected Value: [E(_1) ] ✓ want total catch estimation! Sampling Design: Interviews conducted fishing trips Sampling probability ∝ trip length Longer trips likely encountered Appropriate Estimator: Mean--Ratios (R₂) Truncation [2 = {j=1}^{n} ] (C_j) = catch time interview (L_j) = elapsed time interview. truncation: include interviews (L_j > L_{min}) (typically 20-30 minutes). Expected Value: [E(_2) ] ✓ Correct roving interviews! use R₁ roving? ratio--means roving interviews : [E(_1^{roving}) ] weighted average weights = (trip length)², estimate population catch rate! matters: Real creel surveys often produce mix completed (access-point) incomplete (roving/intercept) interviews. Estimator choice must follow inclusion probability, just trip status, avoid bias. inclusion probability differs design (equal-probability access points vs. length-biased roving), pooling interviews applying single estimator can introduce bias. Treat designs according sampling properties. Treat complete incomplete interviews two strata, combine effort weighting: Complete trips (access point): use Ratio--Means (R₁ = ΣC / ΣE). Incomplete trips (roving): use Mean--Ratios (R₂ = (1/n) Σ(C/E)) truncation short trips (e.g., < 20–30 min). Effort-weighted combination: R̂combined=R1Ecomplete+R2EincompleteEcomplete+Eincomplete \\hat{R}_{\\text{combined}} = \\frac{R_1 E_{\\text{complete}} + R_2 E_{\\text{incomplete}}}{E_{\\text{complete}} + E_{\\text{incomplete}}} can estimate selection/inclusion probabilities (e.g., model trip completeness roving intercept likelihood), use weighted ratio: R̂weighted=∑iwiCi∑iwiEi,wi=1/P(selecti). \\hat{R}_{\\text{weighted}} = \\frac{\\sum_i w_i C_i}{\\sum_i w_i E_i}, \\quad w_i = 1 / P(\\text{select}_i). useful hybrid designs sampling varies predictably across modes, times, sites. Compute: () R₁ complete , (b) R₂ incomplete (truncation), (c) combined estimator. differences small (e.g., < 5–10%), pooling assumptions may reasonable; document . apply R₁ unfiltered roving data — biased high due length-biased sampling. apply R₂ complete trips — bias direction depends effort variability. Always truncate short incomplete trips stabilize R₂ reduce small-denominator issues. bag limits frequently hit, cautious R₂ (ceiling effects can distort ratios). Estimate SEs stratum appropriate formula (delta-method R₁; sample variance ratios R₂), combine via delta-method using effort-weight combination .","code":"complete <- data %>% dplyr::filter(trip_complete == TRUE) incomplete <- data %>% dplyr::filter(trip_complete == FALSE, trip_length >= 0.5)  # 0.5 h = 30 min  r1 <- sum(complete$catch) / sum(complete$effort) r2 <- mean(incomplete$catch / incomplete$effort)  E1 <- sum(complete$effort) E2 <- sum(incomplete$effort)  R_combined <- (r1 * E1 + r2 * E2) / (E1 + E2)"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"access-point-complete-trip-interviews-1","dir":"Articles","previous_headings":"","what":"Access Point (Complete Trip) Interviews","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Sampling Design: Interviews conducted anglers complete trips anglers equal probability interviewed P(interviewed) = constant, regardless trip length Appropriate Estimator: Ratio--Means (R₁) [_1 = ] (C_j^) = total catch completed trip (L_j^) = total trip length completion. Expected Value: [E(_1) ] ✓ want total catch estimation!","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"roving-incomplete-trip-interviews-1","dir":"Articles","previous_headings":"","what":"Roving (Incomplete Trip) Interviews","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Sampling Design: Interviews conducted fishing trips Sampling probability ∝ trip length Longer trips likely encountered Appropriate Estimator: Mean--Ratios (R₂) Truncation [2 = {j=1}^{n} ] (C_j) = catch time interview (L_j) = elapsed time interview. truncation: include interviews (L_j > L_{min}) (typically 20-30 minutes). Expected Value: [E(_2) ] ✓ Correct roving interviews! use R₁ roving? ratio--means roving interviews : [E(_1^{roving}) ] weighted average weights = (trip length)², estimate population catch rate!","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"handling-mixed-complete-and-incomplete-trips-8","dir":"Articles","previous_headings":"","what":"Handling Mixed Complete and Incomplete Trips","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"matters: Real creel surveys often produce mix completed (access-point) incomplete (roving/intercept) interviews. Estimator choice must follow inclusion probability, just trip status, avoid bias. inclusion probability differs design (equal-probability access points vs. length-biased roving), pooling interviews applying single estimator can introduce bias. Treat designs according sampling properties. Treat complete incomplete interviews two strata, combine effort weighting: Complete trips (access point): use Ratio--Means (R₁ = ΣC / ΣE). Incomplete trips (roving): use Mean--Ratios (R₂ = (1/n) Σ(C/E)) truncation short trips (e.g., < 20–30 min). Effort-weighted combination: R̂combined=R1Ecomplete+R2EincompleteEcomplete+Eincomplete \\hat{R}_{\\text{combined}} = \\frac{R_1 E_{\\text{complete}} + R_2 E_{\\text{incomplete}}}{E_{\\text{complete}} + E_{\\text{incomplete}}} can estimate selection/inclusion probabilities (e.g., model trip completeness roving intercept likelihood), use weighted ratio: R̂weighted=∑iwiCi∑iwiEi,wi=1/P(selecti). \\hat{R}_{\\text{weighted}} = \\frac{\\sum_i w_i C_i}{\\sum_i w_i E_i}, \\quad w_i = 1 / P(\\text{select}_i). useful hybrid designs sampling varies predictably across modes, times, sites. Compute: () R₁ complete , (b) R₂ incomplete (truncation), (c) combined estimator. differences small (e.g., < 5–10%), pooling assumptions may reasonable; document . apply R₁ unfiltered roving data — biased high due length-biased sampling. apply R₂ complete trips — bias direction depends effort variability. Always truncate short incomplete trips stabilize R₂ reduce small-denominator issues. bag limits frequently hit, cautious R₂ (ceiling effects can distort ratios). Estimate SEs stratum appropriate formula (delta-method R₁; sample variance ratios R₂), combine via delta-method using effort-weight combination .","code":"complete <- data %>% dplyr::filter(trip_complete == TRUE) incomplete <- data %>% dplyr::filter(trip_complete == FALSE, trip_length >= 0.5)  # 0.5 h = 30 min  r1 <- sum(complete$catch) / sum(complete$effort) r2 <- mean(incomplete$catch / incomplete$effort)  E1 <- sum(complete$effort) E2 <- sum(incomplete$effort)  R_combined <- (r1 * E1 + r2 * E2) / (E1 + E2)"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"simulation-study-1","dir":"Articles","previous_headings":"","what":"Simulation Study","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"theoretical results show estimator choice matters. large bias practice? truncation really help? Let’s demonstrate principles simulation, following approach Rasmussen et al. (1998) Pollock et al. (1997). ’ll simulate realistic fishing scenario compare estimator performance. Simulate traditional access point creel interview anglers finish. Now simulate roving interviews anglers intercepted trips. Run 1000 replications assess bias precision. Access Point Design: Estimator Performance Key Finding: access interviews, estimators approximately unbiased, ratio--means (R₁) typically slightly lower variance.  Access Point Design: Distribution Estimates. estimators center true value (dashed line), demonstrating unbiasedness. ratio--means (R₁) shows slightly tighter clustering, indicating lower variance. Roving Design: Estimator Performance Key Findings: R₁ (ratio--means) BIASED roving interviews - estimate population catch rate R₂ (mean--ratios) without truncation approximately unbiased high variance (unstable) R₂ truncation approximately unbiased lower variance ✓ RECOMMENDED  Roving Design: Effect Truncation. R₁ (ratio--means) biased roving surveys regardless truncation. R₂ (mean--ratios) unbiased high variance without truncation; truncation reduces variance maintaining unbiasedness.","code":"#' Simulate a day of fishing with known parameters #' #' @param n_anglers Number of anglers fishing during the day #' @param mean_trip_hours Mean trip length (hours) #' @param mean_catch_rate Mean catch per hour (Poisson rate parameter) #' @param day_length_hours Length of fishing day #' @return List with population parameters and individual angler data simulate_fishing_day <- function(n_anglers = 100,                                  mean_trip_hours = 4,                                  mean_catch_rate = 2,                                  day_length_hours = 12) {    # Each angler's true catch rate (gamma-distributed for heterogeneity)   # Shape = 1, rate = 1/mean gives exponential with specified mean   # This creates variation in angler skill/success   alpha <- 1   beta <- 1 / mean_catch_rate   catch_rates <- rgamma(n_anglers, shape = alpha, rate = beta)    # Trip lengths (gamma-distributed)   shape_trip <- 4  # Controls variability   rate_trip <- shape_trip / mean_trip_hours   trip_lengths <- rgamma(n_anglers, shape = shape_trip, rate = rate_trip)   trip_lengths <- pmin(trip_lengths, day_length_hours)  # Can't exceed day length    # Generate catches for each angler (Poisson process)   # Expected catch = catch_rate * trip_length   completed_catch <- rpois(n_anglers, lambda = catch_rates * trip_lengths)    # True population parameters   total_effort <- sum(trip_lengths)   total_catch <- sum(completed_catch)   true_catch_rate <- total_catch / total_effort    # Return angler-level data   tibble(     angler_id = 1:n_anglers,     catch_rate_true = catch_rates,     trip_length = trip_lengths,     completed_catch = completed_catch,     true_population_rate = true_catch_rate,     total_effort = total_effort,     total_catch = total_catch   ) }  # Example fishing_day <- simulate_fishing_day(n_anglers = 100) head(fishing_day) # A tibble: 6 × 7   angler_id catch_rate_true trip_length completed_catch true_population_rate       <int>           <dbl>       <dbl>           <int>                <dbl> 1         1           2.00         4.78               7                 2.15 2         2           2.26         1.56               5                 2.15 3         3           0.851        4.74               4                 2.15 4         4           1.03         6.06               5                 2.15 5         5           6.96         4.52              35                 2.15 6         6           0.627        5.59               3                 2.15 # ℹ 2 more variables: total_effort <dbl>, total_catch <int> # Summary of true population parameters cat(\"True Population Parameters:\\n\") True Population Parameters: cat(\"  Total anglers:\", nrow(fishing_day), \"\\n\") Total anglers: 100 cat(\"  Total effort:\", round(fishing_day$total_effort[1], 1), \"hours\\n\") Total effort: 391.8 hours cat(\"  Total catch:\", fishing_day$total_catch[1], \"fish\\n\") Total catch: 844 fish cat(\"  True catch rate:\", round(fishing_day$true_population_rate[1], 3), \"fish/hour\\n\") True catch rate: 2.154 fish/hour #' Simulate access point interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Number of interviews to conduct #' @return Tibble with interview data sample_access_interviews <- function(fishing_day, n_interviews = 30) {   # Simple random sample (equal probability)   sampled <- fishing_day %>%     sample_n(size = min(n_interviews, nrow(fishing_day)), replace = FALSE) %>%     select(angler_id, completed_catch, trip_length, true_population_rate)    sampled }  # Single realization access_sample <- sample_access_interviews(fishing_day, n_interviews = 30) head(access_sample) # A tibble: 6 × 4   angler_id completed_catch trip_length true_population_rate       <int>           <int>       <dbl>                <dbl> 1         1               7        4.78                 2.15 2        69               4        5.05                 2.15 3        79              14        6.27                 2.15 4        19               5        6.75                 2.15 5        12               1        4.72                 2.15 6        64               0        5.88                 2.15 # Calculate both estimators calculate_estimates <- function(interviews, truncate_minutes = NULL) {    # Apply truncation if specified (for roving surveys)   if (!is.null(truncate_minutes)) {     interviews <- interviews %>%       filter(trip_length >= truncate_minutes / 60)   }    n <- nrow(interviews)    # Ratio-of-means   r1 <- sum(interviews$completed_catch) / sum(interviews$trip_length)    # Mean-of-ratios   r2 <- mean(interviews$completed_catch / interviews$trip_length)    # Variance estimates (simplified)   # For R1: use delta method (Taylor series approximation)   # Var(R₁) ≈ (1/n·E̅²) · Var(C - R₁·E)   # where residual = catch - estimated_rate × effort   r <- interviews$completed_catch   e <- interviews$trip_length   r_bar <- mean(r)   e_bar <- mean(e)   var_r1 <- (1 / (n * e_bar^2)) * var(r - r1 * e)   se_r1 <- sqrt(var_r1)    # For R2: simple variance of the ratios   ratios <- interviews$completed_catch / interviews$trip_length   var_r2 <- var(ratios) / n   se_r2 <- sqrt(var_r2)    tibble(     n = n,     ratio_of_means = r1,     mean_of_ratios = r2,     se_r1 = se_r1,     se_r2 = se_r2,     true_rate = interviews$true_population_rate[1]   ) }  access_results <- calculate_estimates(access_sample) access_results # A tibble: 1 × 6       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> 1    30           2.04           2.41 0.401 0.463      2.15 #' Simulate roving interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Target number of interviews #' @return Tibble with incomplete trip interview data sample_roving_interviews <- function(fishing_day, n_interviews = 30) {    # Length-biased sampling: probability of encounter ∝ trip duration   # P(interview angler i) = L_i / Σ L_j (normalized by total effort)   # Longer trips have higher chance of being encountered during roving   prob_intercept <- fishing_day$trip_length / sum(fishing_day$trip_length)    # Sample with probability proportional to size   sampled_indices <- sample(     1:nrow(fishing_day),     size = min(n_interviews, nrow(fishing_day)),     replace = FALSE,     prob = prob_intercept   )    sampled <- fishing_day[sampled_indices, ]    # For each intercepted angler, determine interview time   # Uniform on [0, trip_length] (on average, intercepted at midpoint)   sampled <- sampled %>%     mutate(       # Time fished when interviewed (uniform on [0, trip_length])       # On average, anglers are intercepted at midpoint of their trip       time_at_interview = runif(n(), min = 0, max = trip_length),        # Catch at interview time (incomplete trip)       # Poisson process: E[catch | time_t] = λ × t       # where λ = angler's true catch rate, t = time fished so far       catch_at_interview = rpois(n(), lambda = catch_rate_true * time_at_interview)     ) %>%     select(angler_id, catch_at_interview, time_at_interview,            completed_catch, trip_length, true_population_rate)    sampled }  roving_sample <- sample_roving_interviews(fishing_day, n_interviews = 30) head(roving_sample) # A tibble: 6 × 6   angler_id catch_at_interview time_at_interview completed_catch trip_length       <int>              <int>             <dbl>           <int>       <dbl> 1        27                  1             2.57                2        5.27 2        37                  4             1.46               13        2.99 3        81                  0             0.326               3        3.86 4        32                  1             2.30                8        5.76 5        97                  6             3.54               10        4.81 6        28                  4             2.58                5        2.72 # ℹ 1 more variable: true_population_rate <dbl> # For roving, use incomplete data # Note: calculate_estimates() expects columns named 'completed_catch' and 'trip_length' roving_data <- roving_sample %>%   select(angler_id,          completed_catch = catch_at_interview,          trip_length = time_at_interview,          true_population_rate)  # No truncation roving_no_trunc <- calculate_estimates(roving_data, truncate_minutes = NULL)  # With truncation (30 minutes) roving_with_trunc <- calculate_estimates(roving_data, truncate_minutes = 30)  bind_rows(   roving_no_trunc %>% mutate(truncation = \"None\"),   roving_with_trunc %>% mutate(truncation = \"30 min\") ) # A tibble: 2 × 7       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate truncation   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> <chr> 1    30           1.98           1.77 0.329 0.289      2.15 None 2    27           1.97           1.67 0.334 0.281      2.15 30 min run_simulation <- function(n_reps = 1000,                            n_anglers = 100,                            n_interviews = 30,                            interview_type = c(\"access\", \"roving\")) {    interview_type <- match.arg(interview_type)    results <- map_dfr(1:n_reps, function(rep) {     # Generate population     day <- simulate_fishing_day(n_anglers = n_anglers)     true_rate <- day$true_population_rate[1]      # Sample based on design     if (interview_type == \"access\") {       sample_data <- sample_access_interviews(day, n_interviews)       sample_data <- sample_data %>%         rename(catch = completed_catch, effort = trip_length)     } else {       sample_data <- sample_roving_interviews(day, n_interviews) %>%         rename(catch = catch_at_interview, effort = time_at_interview)     }      # Calculate estimators     # No truncation     r1_no <- sum(sample_data$catch) / sum(sample_data$effort)     r2_no <- mean(sample_data$catch / sample_data$effort)      # With truncation (30 min = 0.5 hr)     trunc_data <- sample_data %>% filter(effort >= 0.5)     if (nrow(trunc_data) > 0) {       r1_trunc <- sum(trunc_data$catch) / sum(trunc_data$effort)       r2_trunc <- mean(trunc_data$catch / trunc_data$effort)     } else {       r1_trunc <- NA       r2_trunc <- NA     }      tibble(       rep = rep,       true_rate = true_rate,       r1_no_trunc = r1_no,       r2_no_trunc = r2_no,       r1_with_trunc = r1_trunc,       r2_with_trunc = r2_trunc,       n_interviews = n_interviews,       n_after_trunc = nrow(trunc_data)     )   })    results %>%     mutate(design = interview_type) }  # Run simulations access_mc <- run_simulation(n_reps = 1000, interview_type = \"access\") roving_mc <- run_simulation(n_reps = 1000, interview_type = \"roving\") # Summary statistics access_summary <- access_mc %>%   summarise(     true_rate = mean(true_rate),      # Ratio of means (R1)     r1_mean = mean(r1_no_trunc),     r1_bias = mean(r1_no_trunc - true_rate),     r1_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate),     r1_rmse = sqrt(mean((r1_no_trunc - true_rate)^2)),     r1_se = sd(r1_no_trunc),      # Mean of ratios (R2)     r2_mean = mean(r2_no_trunc),     r2_bias = mean(r2_no_trunc - true_rate),     r2_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate),     r2_rmse = sqrt(mean((r2_no_trunc - true_rate)^2)),     r2_se = sd(r2_no_trunc)   )  access_summary %>%   pivot_longer(cols = -true_rate, names_to = c(\"estimator\", \"metric\"), names_sep = \"_\", values_to = \"value\", names_repair = \"minimal\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   select(estimator, mean, bias, pct, se, rmse) %>%   rename(pct_bias = pct) %>%   knitr::kable(digits = 4, caption = \"Access Point Design: Estimator Performance\") access_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc) %>%   pivot_longer(cols = c(r1_no_trunc, r2_no_trunc),                names_to = \"estimator\",                values_to = \"estimate\") %>%   mutate(estimator = recode(estimator,                             r1_no_trunc = \"Ratio of Means (R₁)\",                             r2_no_trunc = \"Mean of Ratios (R₂)\")) %>%   ggplot(aes(x = estimate, fill = estimator)) +   geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +   geom_vline(aes(xintercept = mean(true_rate)), linetype = \"dashed\", size = 1) +   facet_wrap(~estimator, ncol = 1) +   labs(title = \"Access Point Design: Sampling Distribution\",        subtitle = \"Dashed line = true population catch rate\",        x = \"Estimated Catch Rate (fish/hour)\",        y = \"Frequency\") +   theme_minimal() +   theme(legend.position = \"none\") # Summary statistics roving_summary <- roving_mc %>%   summarise(     true_rate = mean(true_rate),      # R1 no truncation     r1_no_mean = mean(r1_no_trunc, na.rm = TRUE),     r1_no_bias = mean(r1_no_trunc - true_rate, na.rm = TRUE),     r1_no_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_no_rmse = sqrt(mean((r1_no_trunc - true_rate)^2, na.rm = TRUE)),      # R2 no truncation     r2_no_mean = mean(r2_no_trunc, na.rm = TRUE),     r2_no_bias = mean(r2_no_trunc - true_rate, na.rm = TRUE),     r2_no_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_no_rmse = sqrt(mean((r2_no_trunc - true_rate)^2, na.rm = TRUE)),      # R1 with truncation     r1_trunc_mean = mean(r1_with_trunc, na.rm = TRUE),     r1_trunc_bias = mean(r1_with_trunc - true_rate, na.rm = TRUE),     r1_trunc_pct_bias = 100 * mean((r1_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_trunc_rmse = sqrt(mean((r1_with_trunc - true_rate)^2, na.rm = TRUE)),      # R2 with truncation     r2_trunc_mean = mean(r2_with_trunc, na.rm = TRUE),     r2_trunc_bias = mean(r2_with_trunc - true_rate, na.rm = TRUE),     r2_trunc_pct_bias = 100 * mean((r2_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_trunc_rmse = sqrt(mean((r2_with_trunc - true_rate)^2, na.rm = TRUE))   )  roving_summary %>%   pivot_longer(cols = -true_rate,                names_to = c(\"estimator\", \"truncation\", \"metric\"),                names_pattern = \"([^_]+)_([^_]+)_(.*)\",                values_to = \"value\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   mutate(estimator = recode(estimator, r1 = \"Ratio of Means\", r2 = \"Mean of Ratios\"),          truncation = recode(truncation, no = \"No truncation\", trunc = \"30-min truncation\")) %>%   select(estimator, truncation, mean, bias, pct_bias, rmse) %>%   knitr::kable(digits = 4, caption = \"Roving Design: Estimator Performance\") roving_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc, r1_with_trunc, r2_with_trunc) %>%   pivot_longer(cols = -c(rep, true_rate),                names_to = \"estimator\",                values_to = \"estimate\") %>%   filter(!is.na(estimate)) %>%   mutate(     estimator_type = ifelse(grepl(\"r1\", estimator), \"Ratio of Means (R₁)\", \"Mean of Ratios (R₂)\"),     truncation = ifelse(grepl(\"no_trunc\", estimator), \"No Truncation\", \"30-Min Truncation\")   ) %>%   ggplot(aes(x = estimate, fill = truncation)) +   geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +   geom_vline(aes(xintercept = mean(true_rate)), linetype = \"dashed\", size = 1) +   facet_grid(estimator_type ~ truncation, scales = \"free_y\") +   labs(title = \"Roving Design: Impact of Estimator Choice and Truncation\",        subtitle = \"Dashed line = true population catch rate\",        x = \"Estimated Catch Rate (fish/hour)\",        y = \"Frequency\",        fill = \"Truncation\") +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"simulation-setup-1","dir":"Articles","previous_headings":"","what":"Simulation Setup","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"’ll simulate realistic fishing scenario compare estimator performance.","code":"#' Simulate a day of fishing with known parameters #' #' @param n_anglers Number of anglers fishing during the day #' @param mean_trip_hours Mean trip length (hours) #' @param mean_catch_rate Mean catch per hour (Poisson rate parameter) #' @param day_length_hours Length of fishing day #' @return List with population parameters and individual angler data simulate_fishing_day <- function(n_anglers = 100,                                  mean_trip_hours = 4,                                  mean_catch_rate = 2,                                  day_length_hours = 12) {    # Each angler's true catch rate (gamma-distributed for heterogeneity)   # Shape = 1, rate = 1/mean gives exponential with specified mean   # This creates variation in angler skill/success   alpha <- 1   beta <- 1 / mean_catch_rate   catch_rates <- rgamma(n_anglers, shape = alpha, rate = beta)    # Trip lengths (gamma-distributed)   shape_trip <- 4  # Controls variability   rate_trip <- shape_trip / mean_trip_hours   trip_lengths <- rgamma(n_anglers, shape = shape_trip, rate = rate_trip)   trip_lengths <- pmin(trip_lengths, day_length_hours)  # Can't exceed day length    # Generate catches for each angler (Poisson process)   # Expected catch = catch_rate * trip_length   completed_catch <- rpois(n_anglers, lambda = catch_rates * trip_lengths)    # True population parameters   total_effort <- sum(trip_lengths)   total_catch <- sum(completed_catch)   true_catch_rate <- total_catch / total_effort    # Return angler-level data   tibble(     angler_id = 1:n_anglers,     catch_rate_true = catch_rates,     trip_length = trip_lengths,     completed_catch = completed_catch,     true_population_rate = true_catch_rate,     total_effort = total_effort,     total_catch = total_catch   ) }  # Example fishing_day <- simulate_fishing_day(n_anglers = 100) head(fishing_day) # A tibble: 6 × 7   angler_id catch_rate_true trip_length completed_catch true_population_rate       <int>           <dbl>       <dbl>           <int>                <dbl> 1         1           2.00         4.78               7                 2.15 2         2           2.26         1.56               5                 2.15 3         3           0.851        4.74               4                 2.15 4         4           1.03         6.06               5                 2.15 5         5           6.96         4.52              35                 2.15 6         6           0.627        5.59               3                 2.15 # ℹ 2 more variables: total_effort <dbl>, total_catch <int> # Summary of true population parameters cat(\"True Population Parameters:\\n\") True Population Parameters: cat(\"  Total anglers:\", nrow(fishing_day), \"\\n\") Total anglers: 100 cat(\"  Total effort:\", round(fishing_day$total_effort[1], 1), \"hours\\n\") Total effort: 391.8 hours cat(\"  Total catch:\", fishing_day$total_catch[1], \"fish\\n\") Total catch: 844 fish cat(\"  True catch rate:\", round(fishing_day$true_population_rate[1], 3), \"fish/hour\\n\") True catch rate: 2.154 fish/hour"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"scenario-1-access-point-interviews-complete-trips-1","dir":"Articles","previous_headings":"","what":"Scenario 1: Access Point Interviews (Complete Trips)","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Simulate traditional access point creel interview anglers finish.","code":"#' Simulate access point interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Number of interviews to conduct #' @return Tibble with interview data sample_access_interviews <- function(fishing_day, n_interviews = 30) {   # Simple random sample (equal probability)   sampled <- fishing_day %>%     sample_n(size = min(n_interviews, nrow(fishing_day)), replace = FALSE) %>%     select(angler_id, completed_catch, trip_length, true_population_rate)    sampled }  # Single realization access_sample <- sample_access_interviews(fishing_day, n_interviews = 30) head(access_sample) # A tibble: 6 × 4   angler_id completed_catch trip_length true_population_rate       <int>           <int>       <dbl>                <dbl> 1         1               7        4.78                 2.15 2        69               4        5.05                 2.15 3        79              14        6.27                 2.15 4        19               5        6.75                 2.15 5        12               1        4.72                 2.15 6        64               0        5.88                 2.15 # Calculate both estimators calculate_estimates <- function(interviews, truncate_minutes = NULL) {    # Apply truncation if specified (for roving surveys)   if (!is.null(truncate_minutes)) {     interviews <- interviews %>%       filter(trip_length >= truncate_minutes / 60)   }    n <- nrow(interviews)    # Ratio-of-means   r1 <- sum(interviews$completed_catch) / sum(interviews$trip_length)    # Mean-of-ratios   r2 <- mean(interviews$completed_catch / interviews$trip_length)    # Variance estimates (simplified)   # For R1: use delta method (Taylor series approximation)   # Var(R₁) ≈ (1/n·E̅²) · Var(C - R₁·E)   # where residual = catch - estimated_rate × effort   r <- interviews$completed_catch   e <- interviews$trip_length   r_bar <- mean(r)   e_bar <- mean(e)   var_r1 <- (1 / (n * e_bar^2)) * var(r - r1 * e)   se_r1 <- sqrt(var_r1)    # For R2: simple variance of the ratios   ratios <- interviews$completed_catch / interviews$trip_length   var_r2 <- var(ratios) / n   se_r2 <- sqrt(var_r2)    tibble(     n = n,     ratio_of_means = r1,     mean_of_ratios = r2,     se_r1 = se_r1,     se_r2 = se_r2,     true_rate = interviews$true_population_rate[1]   ) }  access_results <- calculate_estimates(access_sample) access_results # A tibble: 1 × 6       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> 1    30           2.04           2.41 0.401 0.463      2.15"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"scenario-2-roving-interviews-incomplete-trips-1","dir":"Articles","previous_headings":"","what":"Scenario 2: Roving Interviews (Incomplete Trips)","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Now simulate roving interviews anglers intercepted trips.","code":"#' Simulate roving interviews #' #' @param fishing_day Tibble from simulate_fishing_day() #' @param n_interviews Target number of interviews #' @return Tibble with incomplete trip interview data sample_roving_interviews <- function(fishing_day, n_interviews = 30) {    # Length-biased sampling: probability of encounter ∝ trip duration   # P(interview angler i) = L_i / Σ L_j (normalized by total effort)   # Longer trips have higher chance of being encountered during roving   prob_intercept <- fishing_day$trip_length / sum(fishing_day$trip_length)    # Sample with probability proportional to size   sampled_indices <- sample(     1:nrow(fishing_day),     size = min(n_interviews, nrow(fishing_day)),     replace = FALSE,     prob = prob_intercept   )    sampled <- fishing_day[sampled_indices, ]    # For each intercepted angler, determine interview time   # Uniform on [0, trip_length] (on average, intercepted at midpoint)   sampled <- sampled %>%     mutate(       # Time fished when interviewed (uniform on [0, trip_length])       # On average, anglers are intercepted at midpoint of their trip       time_at_interview = runif(n(), min = 0, max = trip_length),        # Catch at interview time (incomplete trip)       # Poisson process: E[catch | time_t] = λ × t       # where λ = angler's true catch rate, t = time fished so far       catch_at_interview = rpois(n(), lambda = catch_rate_true * time_at_interview)     ) %>%     select(angler_id, catch_at_interview, time_at_interview,            completed_catch, trip_length, true_population_rate)    sampled }  roving_sample <- sample_roving_interviews(fishing_day, n_interviews = 30) head(roving_sample) # A tibble: 6 × 6   angler_id catch_at_interview time_at_interview completed_catch trip_length       <int>              <int>             <dbl>           <int>       <dbl> 1        27                  1             2.57                2        5.27 2        37                  4             1.46               13        2.99 3        81                  0             0.326               3        3.86 4        32                  1             2.30                8        5.76 5        97                  6             3.54               10        4.81 6        28                  4             2.58                5        2.72 # ℹ 1 more variable: true_population_rate <dbl> # For roving, use incomplete data # Note: calculate_estimates() expects columns named 'completed_catch' and 'trip_length' roving_data <- roving_sample %>%   select(angler_id,          completed_catch = catch_at_interview,          trip_length = time_at_interview,          true_population_rate)  # No truncation roving_no_trunc <- calculate_estimates(roving_data, truncate_minutes = NULL)  # With truncation (30 minutes) roving_with_trunc <- calculate_estimates(roving_data, truncate_minutes = 30)  bind_rows(   roving_no_trunc %>% mutate(truncation = \"None\"),   roving_with_trunc %>% mutate(truncation = \"30 min\") ) # A tibble: 2 × 7       n ratio_of_means mean_of_ratios se_r1 se_r2 true_rate truncation   <int>          <dbl>          <dbl> <dbl> <dbl>     <dbl> <chr> 1    30           1.98           1.77 0.329 0.289      2.15 None 2    27           1.97           1.67 0.334 0.281      2.15 30 min"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"monte-carlo-simulation-1","dir":"Articles","previous_headings":"","what":"Monte Carlo Simulation","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Run 1000 replications assess bias precision.","code":"run_simulation <- function(n_reps = 1000,                            n_anglers = 100,                            n_interviews = 30,                            interview_type = c(\"access\", \"roving\")) {    interview_type <- match.arg(interview_type)    results <- map_dfr(1:n_reps, function(rep) {     # Generate population     day <- simulate_fishing_day(n_anglers = n_anglers)     true_rate <- day$true_population_rate[1]      # Sample based on design     if (interview_type == \"access\") {       sample_data <- sample_access_interviews(day, n_interviews)       sample_data <- sample_data %>%         rename(catch = completed_catch, effort = trip_length)     } else {       sample_data <- sample_roving_interviews(day, n_interviews) %>%         rename(catch = catch_at_interview, effort = time_at_interview)     }      # Calculate estimators     # No truncation     r1_no <- sum(sample_data$catch) / sum(sample_data$effort)     r2_no <- mean(sample_data$catch / sample_data$effort)      # With truncation (30 min = 0.5 hr)     trunc_data <- sample_data %>% filter(effort >= 0.5)     if (nrow(trunc_data) > 0) {       r1_trunc <- sum(trunc_data$catch) / sum(trunc_data$effort)       r2_trunc <- mean(trunc_data$catch / trunc_data$effort)     } else {       r1_trunc <- NA       r2_trunc <- NA     }      tibble(       rep = rep,       true_rate = true_rate,       r1_no_trunc = r1_no,       r2_no_trunc = r2_no,       r1_with_trunc = r1_trunc,       r2_with_trunc = r2_trunc,       n_interviews = n_interviews,       n_after_trunc = nrow(trunc_data)     )   })    results %>%     mutate(design = interview_type) }  # Run simulations access_mc <- run_simulation(n_reps = 1000, interview_type = \"access\") roving_mc <- run_simulation(n_reps = 1000, interview_type = \"roving\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"results-access-point-design-1","dir":"Articles","previous_headings":"","what":"Results: Access Point Design","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Access Point Design: Estimator Performance Key Finding: access interviews, estimators approximately unbiased, ratio--means (R₁) typically slightly lower variance.  Access Point Design: Distribution Estimates. estimators center true value (dashed line), demonstrating unbiasedness. ratio--means (R₁) shows slightly tighter clustering, indicating lower variance.","code":"# Summary statistics access_summary <- access_mc %>%   summarise(     true_rate = mean(true_rate),      # Ratio of means (R1)     r1_mean = mean(r1_no_trunc),     r1_bias = mean(r1_no_trunc - true_rate),     r1_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate),     r1_rmse = sqrt(mean((r1_no_trunc - true_rate)^2)),     r1_se = sd(r1_no_trunc),      # Mean of ratios (R2)     r2_mean = mean(r2_no_trunc),     r2_bias = mean(r2_no_trunc - true_rate),     r2_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate),     r2_rmse = sqrt(mean((r2_no_trunc - true_rate)^2)),     r2_se = sd(r2_no_trunc)   )  access_summary %>%   pivot_longer(cols = -true_rate, names_to = c(\"estimator\", \"metric\"), names_sep = \"_\", values_to = \"value\", names_repair = \"minimal\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   select(estimator, mean, bias, pct, se, rmse) %>%   rename(pct_bias = pct) %>%   knitr::kable(digits = 4, caption = \"Access Point Design: Estimator Performance\") access_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc) %>%   pivot_longer(cols = c(r1_no_trunc, r2_no_trunc),                names_to = \"estimator\",                values_to = \"estimate\") %>%   mutate(estimator = recode(estimator,                             r1_no_trunc = \"Ratio of Means (R₁)\",                             r2_no_trunc = \"Mean of Ratios (R₂)\")) %>%   ggplot(aes(x = estimate, fill = estimator)) +   geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +   geom_vline(aes(xintercept = mean(true_rate)), linetype = \"dashed\", size = 1) +   facet_wrap(~estimator, ncol = 1) +   labs(title = \"Access Point Design: Sampling Distribution\",        subtitle = \"Dashed line = true population catch rate\",        x = \"Estimated Catch Rate (fish/hour)\",        y = \"Frequency\") +   theme_minimal() +   theme(legend.position = \"none\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"results-roving-design-1","dir":"Articles","previous_headings":"","what":"Results: Roving Design","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Roving Design: Estimator Performance Key Findings: R₁ (ratio--means) BIASED roving interviews - estimate population catch rate R₂ (mean--ratios) without truncation approximately unbiased high variance (unstable) R₂ truncation approximately unbiased lower variance ✓ RECOMMENDED  Roving Design: Effect Truncation. R₁ (ratio--means) biased roving surveys regardless truncation. R₂ (mean--ratios) unbiased high variance without truncation; truncation reduces variance maintaining unbiasedness.","code":"# Summary statistics roving_summary <- roving_mc %>%   summarise(     true_rate = mean(true_rate),      # R1 no truncation     r1_no_mean = mean(r1_no_trunc, na.rm = TRUE),     r1_no_bias = mean(r1_no_trunc - true_rate, na.rm = TRUE),     r1_no_pct_bias = 100 * mean((r1_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_no_rmse = sqrt(mean((r1_no_trunc - true_rate)^2, na.rm = TRUE)),      # R2 no truncation     r2_no_mean = mean(r2_no_trunc, na.rm = TRUE),     r2_no_bias = mean(r2_no_trunc - true_rate, na.rm = TRUE),     r2_no_pct_bias = 100 * mean((r2_no_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_no_rmse = sqrt(mean((r2_no_trunc - true_rate)^2, na.rm = TRUE)),      # R1 with truncation     r1_trunc_mean = mean(r1_with_trunc, na.rm = TRUE),     r1_trunc_bias = mean(r1_with_trunc - true_rate, na.rm = TRUE),     r1_trunc_pct_bias = 100 * mean((r1_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r1_trunc_rmse = sqrt(mean((r1_with_trunc - true_rate)^2, na.rm = TRUE)),      # R2 with truncation     r2_trunc_mean = mean(r2_with_trunc, na.rm = TRUE),     r2_trunc_bias = mean(r2_with_trunc - true_rate, na.rm = TRUE),     r2_trunc_pct_bias = 100 * mean((r2_with_trunc - true_rate) / true_rate, na.rm = TRUE),     r2_trunc_rmse = sqrt(mean((r2_with_trunc - true_rate)^2, na.rm = TRUE))   )  roving_summary %>%   pivot_longer(cols = -true_rate,                names_to = c(\"estimator\", \"truncation\", \"metric\"),                names_pattern = \"([^_]+)_([^_]+)_(.*)\",                values_to = \"value\") %>%   pivot_wider(names_from = metric, values_from = value) %>%   mutate(estimator = recode(estimator, r1 = \"Ratio of Means\", r2 = \"Mean of Ratios\"),          truncation = recode(truncation, no = \"No truncation\", trunc = \"30-min truncation\")) %>%   select(estimator, truncation, mean, bias, pct_bias, rmse) %>%   knitr::kable(digits = 4, caption = \"Roving Design: Estimator Performance\") roving_mc %>%   select(rep, true_rate, r1_no_trunc, r2_no_trunc, r1_with_trunc, r2_with_trunc) %>%   pivot_longer(cols = -c(rep, true_rate),                names_to = \"estimator\",                values_to = \"estimate\") %>%   filter(!is.na(estimate)) %>%   mutate(     estimator_type = ifelse(grepl(\"r1\", estimator), \"Ratio of Means (R₁)\", \"Mean of Ratios (R₂)\"),     truncation = ifelse(grepl(\"no_trunc\", estimator), \"No Truncation\", \"30-Min Truncation\")   ) %>%   ggplot(aes(x = estimate, fill = truncation)) +   geom_histogram(bins = 50, alpha = 0.6, position = \"identity\") +   geom_vline(aes(xintercept = mean(true_rate)), linetype = \"dashed\", size = 1) +   facet_grid(estimator_type ~ truncation, scales = \"free_y\") +   labs(title = \"Roving Design: Impact of Estimator Choice and Truncation\",        subtitle = \"Dashed line = true population catch rate\",        x = \"Estimated Catch Rate (fish/hour)\",        y = \"Frequency\",        fill = \"Truncation\") +   theme_minimal() +   theme(legend.position = \"bottom\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"practical-implementation-with-tidycreel-1","dir":"Articles","previous_headings":"","what":"Practical Implementation with tidycreel","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"","code":"# Assuming you have complete-trip interview data interviews_complete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 8),   hours_fished = rgamma(100, shape = 4, rate = 1),   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # Create survey design svy_interviews <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_complete )  # Use RATIO-OF-MEANS (default and recommended) cpue_access <- est_cpue(   design = svy_interviews,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"ratio_of_means\"  # ✓ Correct for access interviews )  cpue_access # Assuming you have incomplete-trip interview data interviews_incomplete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 4),  # Catch so far   hours_fished = runif(100, min = 0.2, max = 6),  # Time so far   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # IMPORTANT: Truncate short trips before analysis interviews_truncated <- interviews_incomplete %>%   filter(hours_fished >= 0.5)  # Remove trips < 30 minutes  # Create survey design svy_roving <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_truncated )  # Use MEAN-OF-RATIOS for roving interviews cpue_roving <- est_cpue(   design = svy_roving,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"mean_of_ratios\"  # ✓ Correct for roving interviews )  cpue_roving"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"access-point-survey-example-1","dir":"Articles","previous_headings":"","what":"Access Point Survey Example","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"","code":"# Assuming you have complete-trip interview data interviews_complete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 8),   hours_fished = rgamma(100, shape = 4, rate = 1),   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # Create survey design svy_interviews <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_complete )  # Use RATIO-OF-MEANS (default and recommended) cpue_access <- est_cpue(   design = svy_interviews,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"ratio_of_means\"  # ✓ Correct for access interviews )  cpue_access"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"roving-survey-example-1","dir":"Articles","previous_headings":"","what":"Roving Survey Example","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"","code":"# Assuming you have incomplete-trip interview data interviews_incomplete <- tibble(   angler_id = 1:100,   date = rep(as.Date(\"2024-01-01\") + 0:9, each = 10),   catch_total = rpois(100, lambda = 4),  # Catch so far   hours_fished = runif(100, min = 0.2, max = 6),  # Time so far   day_type = rep(c(\"weekday\", \"weekend\"), length.out = 100) )  # IMPORTANT: Truncate short trips before analysis interviews_truncated <- interviews_incomplete %>%   filter(hours_fished >= 0.5)  # Remove trips < 30 minutes  # Create survey design svy_roving <- survey::svydesign(   ids = ~1,   strata = ~day_type,   data = interviews_truncated )  # Use MEAN-OF-RATIOS for roving interviews cpue_roving <- est_cpue(   design = svy_roving,   by = NULL,   response = \"catch_total\",   effort_col = \"hours_fished\",   mode = \"mean_of_ratios\"  # ✓ Correct for roving interviews )  cpue_roving"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"variance-estimation-1","dir":"Articles","previous_headings":"","what":"Variance Estimation","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"ratio--means survey weights, survey package automatically uses delta method: Note: variance formulas assume sampling infinite (large) population. sample size substantial relative total number anglers (n/N > 5%), may want apply finite population correction (FPC): multiply variance (1 - n/N). However, creel surveys population potential anglers large, correction negligible. [(_1) (C - _1 E)] (C) = catch, (E) = effort. mean--ratios, variance straightforward: [(_2) = ()]","code":"# survey::svyratio() provides proper variance cpue_result <- est_cpue(design = svy_interviews, mode = \"ratio_of_means\")  # Standard error is included cpue_result$se  # 95% confidence interval cpue_result$ci_low cpue_result$ci_high # survey::svymean() on the ratio variable cpue_roving <- est_cpue(design = svy_roving, mode = \"mean_of_ratios\")  # Standard error and CIs included cpue_roving$se cpue_roving$ci_low cpue_roving$ci_high"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"access-point-ratio-of-means-1","dir":"Articles","previous_headings":"","what":"Access Point (Ratio-of-Means)","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"ratio--means survey weights, survey package automatically uses delta method: Note: variance formulas assume sampling infinite (large) population. sample size substantial relative total number anglers (n/N > 5%), may want apply finite population correction (FPC): multiply variance (1 - n/N). However, creel surveys population potential anglers large, correction negligible. [(_1) (C - _1 E)] (C) = catch, (E) = effort.","code":"# survey::svyratio() provides proper variance cpue_result <- est_cpue(design = svy_interviews, mode = \"ratio_of_means\")  # Standard error is included cpue_result$se  # 95% confidence interval cpue_result$ci_low cpue_result$ci_high"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"roving-mean-of-ratios-with-truncation-1","dir":"Articles","previous_headings":"","what":"Roving (Mean-of-Ratios with Truncation)","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"mean--ratios, variance straightforward: [(_2) = ()]","code":"# survey::svymean() on the ratio variable cpue_roving <- est_cpue(design = svy_roving, mode = \"mean_of_ratios\")  # Standard error and CIs included cpue_roving$se cpue_roving$ci_low cpue_roving$ci_high"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"special-considerations-1","dir":"Articles","previous_headings":"","what":"Special Considerations","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"⚠️ CRITICAL WARNING: Roving surveys can produce severe negative bias (underestimation 20-50%+) bag limits low (≤5 fish) anglers comply leaving immediately upon reaching limit. Problem: anglers leave immediately catching limit, roving clerk encounter unsuccessful anglers, leading severe underestimation. Example simulation (bag limit = 2 fish): Roving Bias Different Bag Limits Recommendation: bag limits low (≤5 fish) compliance high, use access point interviews instead roving. catch rates change systematically trips (e.g., learning curve, time--day effects), roving interviews may biased. Check : Comparing incomplete-trip catch rates complete-trip catch rates Looking patterns catch rate vs. time--day nonstationary: Consider access point interviews model time-varying catch rate.","code":"simulate_with_bag_limit <- function(n_reps = 500, bag_limit = 2) {   map_dfr(1:n_reps, function(rep) {     # Simulate fishing day     day <- simulate_fishing_day(n_anglers = 100)     true_rate <- day$true_population_rate[1]      # Apply bag limit: anglers stop when limit reached     day_limited <- day %>%       mutate(         # Time to reach bag limit (exponential waiting time)         time_to_limit = ifelse(catch_rate_true > 0,                                bag_limit / catch_rate_true,                                Inf),         # Actual trip length (stop at limit or planned end, whichever comes first)         actual_trip_length = pmin(trip_length, time_to_limit),         # Actual catch (capped at bag limit)         actual_catch = pmin(completed_catch, bag_limit),         # Did angler reach bag limit before planned trip end?         reached_limit = (time_to_limit < trip_length)       )      # Roving interviews can only encounter anglers still on-site     # Those who reached bag limit before their planned trip end have already left     # Only those who haven't reached the limit OR reached it at/after planned end are available     still_fishing <- day_limited %>%       filter(!reached_limit)      if (nrow(still_fishing) > 10) {       # Sample from those still fishing       sample_data <- sample_roving_interviews(still_fishing, n_interviews = 30) %>%         rename(catch = catch_at_interview, effort = time_at_interview) %>%         filter(effort >= 0.5)        if (nrow(sample_data) > 0) {         r2 <- mean(sample_data$catch / sample_data$effort)         return(tibble(rep = rep, true_rate = true_rate, estimated_rate = r2,                      bag_limit = bag_limit))       }     }      tibble(rep = rep, true_rate = true_rate, estimated_rate = NA, bag_limit = bag_limit)   }) }  bag_limit_results <- bind_rows(   simulate_with_bag_limit(bag_limit = 2),   simulate_with_bag_limit(bag_limit = 5),   simulate_with_bag_limit(bag_limit = 10) )  bag_limit_summary <- bag_limit_results %>%   filter(!is.na(estimated_rate)) %>%   group_by(bag_limit) %>%   summarise(     true_rate = mean(true_rate),     mean_estimate = mean(estimated_rate),     bias = mean(estimated_rate - true_rate),     pct_bias = 100 * mean((estimated_rate - true_rate) / true_rate)   )  bag_limit_summary %>%   knitr::kable(digits = 3, caption = \"Roving Bias Under Different Bag Limits\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"bag-limits-1","dir":"Articles","previous_headings":"","what":"Bag Limits","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"⚠️ CRITICAL WARNING: Roving surveys can produce severe negative bias (underestimation 20-50%+) bag limits low (≤5 fish) anglers comply leaving immediately upon reaching limit. Problem: anglers leave immediately catching limit, roving clerk encounter unsuccessful anglers, leading severe underestimation. Example simulation (bag limit = 2 fish): Roving Bias Different Bag Limits Recommendation: bag limits low (≤5 fish) compliance high, use access point interviews instead roving.","code":"simulate_with_bag_limit <- function(n_reps = 500, bag_limit = 2) {   map_dfr(1:n_reps, function(rep) {     # Simulate fishing day     day <- simulate_fishing_day(n_anglers = 100)     true_rate <- day$true_population_rate[1]      # Apply bag limit: anglers stop when limit reached     day_limited <- day %>%       mutate(         # Time to reach bag limit (exponential waiting time)         time_to_limit = ifelse(catch_rate_true > 0,                                bag_limit / catch_rate_true,                                Inf),         # Actual trip length (stop at limit or planned end, whichever comes first)         actual_trip_length = pmin(trip_length, time_to_limit),         # Actual catch (capped at bag limit)         actual_catch = pmin(completed_catch, bag_limit),         # Did angler reach bag limit before planned trip end?         reached_limit = (time_to_limit < trip_length)       )      # Roving interviews can only encounter anglers still on-site     # Those who reached bag limit before their planned trip end have already left     # Only those who haven't reached the limit OR reached it at/after planned end are available     still_fishing <- day_limited %>%       filter(!reached_limit)      if (nrow(still_fishing) > 10) {       # Sample from those still fishing       sample_data <- sample_roving_interviews(still_fishing, n_interviews = 30) %>%         rename(catch = catch_at_interview, effort = time_at_interview) %>%         filter(effort >= 0.5)        if (nrow(sample_data) > 0) {         r2 <- mean(sample_data$catch / sample_data$effort)         return(tibble(rep = rep, true_rate = true_rate, estimated_rate = r2,                      bag_limit = bag_limit))       }     }      tibble(rep = rep, true_rate = true_rate, estimated_rate = NA, bag_limit = bag_limit)   }) }  bag_limit_results <- bind_rows(   simulate_with_bag_limit(bag_limit = 2),   simulate_with_bag_limit(bag_limit = 5),   simulate_with_bag_limit(bag_limit = 10) )  bag_limit_summary <- bag_limit_results %>%   filter(!is.na(estimated_rate)) %>%   group_by(bag_limit) %>%   summarise(     true_rate = mean(true_rate),     mean_estimate = mean(estimated_rate),     bias = mean(estimated_rate - true_rate),     pct_bias = 100 * mean((estimated_rate - true_rate) / true_rate)   )  bag_limit_summary %>%   knitr::kable(digits = 3, caption = \"Roving Bias Under Different Bag Limits\")"},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"nonstationary-catch-rates-1","dir":"Articles","previous_headings":"","what":"Nonstationary Catch Rates","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"catch rates change systematically trips (e.g., learning curve, time--day effects), roving interviews may biased. Check : Comparing incomplete-trip catch rates complete-trip catch rates Looking patterns catch rate vs. time--day nonstationary: Consider access point interviews model time-varying catch rate.","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"summary-practical-guidelines-1","dir":"Articles","previous_headings":"","what":"Summary: Practical Guidelines","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"surveys: Check missing data catch effort Verify effort > 0 interviews Check outliers (data entry errors) ROVING surveys specifically: Truncate short trips (< 20-30 minutes) Check bag limit compliance (may cause bias) Verify catch rate stationarity (possible) Use proper survey weights svydesign() Include stratification variables Use svyratio() ratio--means Use svymean() catch/effort ratio mean--ratios Report standard errors confidence intervals","code":""},{"path":[]},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"pre-processing-checklist-1","dir":"Articles","previous_headings":"","what":"Pre-processing Checklist","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"surveys: Check missing data catch effort Verify effort > 0 interviews Check outliers (data entry errors) ROVING surveys specifically: Truncate short trips (< 20-30 minutes) Check bag limit compliance (may cause bias) Verify catch rate stationarity (possible)","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"variance-estimation-checklist-1","dir":"Articles","previous_headings":"","what":"Variance Estimation Checklist","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Use proper survey weights svydesign() Include stratification variables Use svyratio() ratio--means Use svymean() catch/effort ratio mean--ratios Report standard errors confidence intervals","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"references-1","dir":"Articles","previous_headings":"","what":"References","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"Pollock, K.H., Hoenig, J.M., Jones, C.M., Robson, D.S., & Greene, C.J. (1997). Catch rate estimation roving access point surveys. North American Journal Fisheries Management, 17(1), 11-19. Rasmussen, P.W., Staggs, M.D., Beard, T.D., & Newman, S.P. (1998). Bias confidence interval coverage creel survey estimators evaluated simulation. Transactions American Fisheries Society, 127(3), 469-480. Jones, C.M., Robson, D.S., Lakkis, H.D., & Kressel, J. (1995). Properties catch rates used analysis angler surveys. Transactions American Fisheries Society, 124(6), 911-928. Lumley, T. (2004). Analysis complex survey samples. Journal Statistical Software, 9(1), 1-19.","code":""},{"path":"/articles/ratio-estimators-guide_full_with_hybrid.html","id":"conclusion-1","dir":"Articles","previous_headings":"","what":"Conclusion","title":"Ratio Estimators: When to Use Ratio-of-Means vs Mean-of-Ratios","text":"choice ratio--means mean--ratios depends fundamentally survey design: Access point interviews → Use ratio--means Roving interviews → Use mean--ratios truncation tidycreel package implements estimators proper variance estimation survey package. following decision rules vignette, can ensure catch rate estimates unbiased confidence intervals correct coverage.","code":""},{"path":"/articles/replicate_designs_creel.html","id":"when-to-use-replicate-designs","dir":"Articles","previous_headings":"","what":"When to use replicate designs","title":"Replicate Designs for Creel Inference","text":"Taylor linearization (analytic SE) often sufficient creel totals ratios. Replicate designs (bootstrap, jackknife, BRR) useful : Variance structure complex (e.g., HT contributions variable inclusion probabilities), combine multiple non-linear steps (e.g., effort × CPUE), need small-sample robustness checks. tidycreel, recommend building replicate designs day-PSU svydesign created as_day_svydesign().","code":""},{"path":"/articles/replicate_designs_creel.html","id":"build-a-replicate-design-from-day-psus","dir":"Articles","previous_headings":"","what":"Build a replicate design from day PSUs","title":"Replicate Designs for Creel Inference","text":"Notes: - .svrepdesign() derives replicate weights day design (preferred custom resampling). - Use type = \"JK1\" jackknife type = \"BRR\" design fits BRR assumptions.","code":"library(tidycreel) library(survey) library(dplyr)  # Toy calendar of sampled days a <- tibble::tibble(   date = as.Date(c(\"2025-08-20\",\"2025-08-21\",\"2025-08-22\")),   day_type = c(\"weekday\",\"weekday\",\"weekend\"),   month = c(\"Aug\",\"Aug\",\"Aug\"),   target_sample = c(4,4,4),   actual_sample = c(2,2,1) ) svy_day <- as_day_svydesign(a, day_id = \"date\", strata_vars = c(\"day_type\",\"month\"))  # Convert to replicate-weight design (bootstrap with 50 reps) svy_rep <- survey::as.svrepdesign(svy_day, type = \"bootstrap\", replicates = 50, mse = TRUE) svy_rep"},{"path":"/articles/replicate_designs_creel.html","id":"use-replicate-design-in-estimators","dir":"Articles","previous_headings":"","what":"Use replicate design in estimators","title":"Replicate Designs for Creel Inference","text":"svy_rep carries replicate weights, estimator computes totals SE using replicate variance automatically.","code":"# Instantaneous counts example (very small synthetic data) counts <- tibble::tibble(   date = rep(a$date, each = 2),   location = rep(c(\"A\",\"B\"), times = 3),   count = c(10, 12, 8, 11, 9, 14),   interval_minutes = 60,   total_day_minutes = 600 )  est_effort(   design = svy_rep,   counts = counts,   method = \"instantaneous\",   by = \"location\" )"},{"path":"/articles/replicate_designs_creel.html","id":"tips-and-caveats","dir":"Articles","previous_headings":"","what":"Tips and caveats","title":"Replicate Designs for Creel Inference","text":"Keep replicate counts modest examples vignettes (e.g., 50–200) avoid slow builds; increase production analysis. Ensure PSUs truly represent days; need sub-day PSUs (rare), document assumptions. Horvitz–Thompson contributions (e.g., bus-route), compute day×group totals first, let day replicate design handle SE.","code":""},{"path":"/articles/replicate_designs_creel.html","id":"references","dir":"Articles","previous_headings":"","what":"References","title":"Replicate Designs for Creel Inference","text":"survey package: .svrepdesign, svrepdesign, variance vignette. creel methodology references creel_chapter.md context.","code":"sessionInfo()"},{"path":"/articles/survey_creel_terms.html","id":"why-this-guide","dir":"Articles","previous_headings":"","what":"Why this guide","title":"Survey Package to Creel: A Translator","text":"Many creel practitioners know field methods estimators less familiar survey package vocabulary. guide “translates” survey’s core concepts creel terms shows tidycreel applies survey-first workflow. See also creel_chapter.md background references.","code":""},{"path":"/articles/survey_creel_terms.html","id":"core-translation-concepts-and-terms","dir":"Articles","previous_headings":"","what":"Core translation: concepts and terms","title":"Survey Package to Creel: A Translator","text":"PSUs (Primary Sampling Units): sampled days; sometimes day×stratum needed. SSUs: count passes interviews within day; typically aggregated day totals. Strata: calendar groupings (e.g., weekday/weekend, month, season, area). target_sample vs actual_sample: planned vs realized number sampled PSUs stratum. Day weights (w): expansion sampled target days; often w = target_sample / actual_sample within stratum. Inclusion probability (π): probability unit observed. bus-route HT, per-observation π enters directly. Totals (svytotal): sum day totals across sampled days design-based variance. Means (svymean): average PSUs; less common creel totals. Ratios (svyratio): CPUE catch/effort design-based variance. Replicate designs (svrepdesign): bootstrap/jackknife/BRR Taylor SE complex.","code":""},{"path":"/articles/survey_creel_terms.html","id":"survey-first-workflow-in-tidycreel","dir":"Articles","previous_headings":"","what":"Survey-first workflow in tidycreel","title":"Survey Package to Creel: A Translator","text":"Build day-PSU survey design calendar. Aggregate raw counts day×group totals (vectorized, tidy). Use survey get totals SEs group (svytotal/svyby). Prefer replicate-weight designs complex cases.","code":""},{"path":"/articles/survey_creel_terms.html","id":"day-psu-design","dir":"Articles","previous_headings":"Survey-first workflow in tidycreel","what":"1) Day-PSU design","title":"Survey Package to Creel: A Translator","text":"means creel terms: sampled day represents target_sample / actual_sample similar days within stratum. survey carries weight variance estimation.","code":"library(tidycreel) library(dplyr)  # Minimal, toy calendar: two sampled days, both intended 4 samples/stratum calendar <- tibble::tibble(   date = as.Date(c(\"2025-08-20\", \"2025-08-21\")),   day_type = c(\"weekday\", \"weekday\"),   month = c(\"Aug\", \"Aug\"),   target_sample = c(4, 4),   actual_sample = c(2, 2) )  svy_day <- as_day_svydesign(calendar, day_id = \"date\", strata_vars = c(\"day_type\", \"month\")) svy_day"},{"path":"/articles/survey_creel_terms.html","id":"instantaneous-effort-from-counts","dir":"Articles","previous_headings":"Survey-first workflow in tidycreel","what":"2) Instantaneous effort from counts","title":"Survey Package to Creel: A Translator","text":"Interpretation: per day×location, effort_day = mean(count) × total_day_minutes / 60; totals SEs come day design.","code":"# Toy snapshot counts for two locations over two days (minutes per snapshot) counts_inst <- tibble::tibble(   date = rep(calendar$date, each = 2),   location = rep(c(\"A\", \"B\"), times = 2),   count = c(10, 12, 9, 15),   interval_minutes = 60,   total_day_minutes = 600  # e.g., 10-hour day window )  est_effort(   design = svy_day,   counts = counts_inst,   method = \"instantaneous\",   by = \"location\" )"},{"path":"/articles/survey_creel_terms.html","id":"progressive-roving-effort","dir":"Articles","previous_headings":"Survey-first workflow in tidycreel","what":"3) Progressive (roving) effort","title":"Survey Package to Creel: A Translator","text":"Interpretation: per day×location, sum(count × route_minutes)/60 across passes, design-based totals.","code":"# Toy progressive (roving) pass counts with per-pass route minutes counts_prog <- tibble::tibble(   date = rep(calendar$date, each = 3),   location = rep(c(\"A\", \"A\", \"B\"), times = 2),   pass_id = rep(1:3, times = 2),   count = c(4, 6, 8, 5, 7, 9),   route_minutes = c(45, 45, 45, 45, 45, 45) )  est_effort(   design = svy_day,   counts = counts_prog,   method = \"progressive\",   by = \"location\" )"},{"path":"/articles/survey_creel_terms.html","id":"aerial-effort-and-visibility","dir":"Articles","previous_headings":"Survey-first workflow in tidycreel","what":"4) Aerial effort and visibility","title":"Survey Package to Creel: A Translator","text":"Interpretation: adjust counts visibility, compute day totals, use day design totals/SEs.","code":"# Aerial snapshots with a simple visibility factor (0-1) counts_air <- tibble::tibble(   date = rep(calendar$date, each = 2),   location = rep(c(\"A\", \"B\"), times = 2),   count = c(10, 8, 12, 15),   interval_minutes = 60,   total_day_minutes = 600,   visibility = c(0.8, 0.9, 0.7, 1.0) )  est_effort.aerial(   counts = counts_air,   by = \"location\",   minutes_col = \"interval_minutes\",   total_minutes_col = \"total_day_minutes\",   visibility_col = \"visibility\",   svy = svy_day )"},{"path":"/articles/survey_creel_terms.html","id":"cpue-and-harvest-in-brief","dir":"Articles","previous_headings":"","what":"CPUE and Harvest (in brief)","title":"Survey Package to Creel: A Translator","text":"CPUE: ratio estimator (svyratio) catch effort. creel terms, means combining interview-derived catch associated effort, respecting day-PSU design. survey-first estimate_cpue() aligned tidy outputs planned. Harvest/Catch totals: use svytotal interview-level kept/total catch expanded day weights, combined estimator multiplies effort CPUE appropriate (delta/replicate methods).","code":""},{"path":"/articles/survey_creel_terms.html","id":"jargon-quick-map","dir":"Articles","previous_headings":"","what":"Jargon quick map","title":"Survey Package to Creel: A Translator","text":"PSU (Primary Sampling Unit): sampled day (primary “draw”). Strata: calendar groups (weekday/weekend, month, season, region). Weight: expansion factor sampled days target days stratum. Inclusion probability (π): chance observation appears (e.g., bus-route pass); enters HT contributions. HT (Horvitz–Thompson) contribution: observed contribution divided π. Taylor SE: analytic variance survey; Replicate SE: via bootstrap/jackknife/BRR svrepdesign.","code":""},{"path":"/articles/survey_creel_terms.html","id":"references-and-further-reading","dir":"Articles","previous_headings":"","what":"References and further reading","title":"Survey Package to Creel: A Translator","text":"tidycreel design/estimation vignettes function docs. survey package documentation svydesign, svytotal, svyratio, svyby, svrepdesign. creel_chapter.md creel_foundations.md repo statistical background.","code":"sessionInfo()"},{"path":"/authors.html","id":null,"dir":"","previous_headings":"","what":"Authors","title":"Authors and Citation","text":"Christopher Chizinski. Author, maintainer.","code":""},{"path":"/authors.html","id":"citation","dir":"","previous_headings":"","what":"Citation","title":"Authors and Citation","text":"Chizinski C (2025). tidycreel: Tidy Interface Creel Survey Design Analysis. R package version 0.0.0.9000, https://github.com/chrischizinski/tidycreel.","code":"@Manual{,   title = {tidycreel: Tidy Interface for Creel Survey Design and Analysis},   author = {Christopher Chizinski},   year = {2025},   note = {R package version 0.0.0.9000},   url = {https://github.com/chrischizinski/tidycreel}, }"},{"path":"/index.html","id":"tidycreel","dir":"","previous_headings":"","what":"Tidy Interface for Creel Survey Design and Analysis","title":"Tidy Interface for Creel Survey Design and Analysis","text":"[![Lifecycle: experimental] (https://img.shields.io/badge/lifecycle-experimental-orange.svg)] (https://lifecycle.r-lib.org/articles/stages.html#experimental) [![R CMD Check] (https://github.com/chrischizinski/tidycreel/actions/workflows/r-check.yml/badge.svg)] (https://github.com/chrischizinski/tidycreel/actions/workflows/r-check.yml) [![lintr] (https://github.com/chrischizinski/tidycreel/actions/workflows/lintr.yaml/badge.svg)] (https://github.com/chrischizinski/tidycreel/actions/workflows/lintr.yaml) goal tidycreel provide survey-first, tidy interface creel survey design analysis. Estimators built survey/svrepdesign framework vectorized, tidyverse data workflows, delivering defensible estimates effort, CPUE, catch, harvest.","code":""},{"path":"/index.html","id":"installation","dir":"","previous_headings":"","what":"Installation","title":"Tidy Interface for Creel Survey Design and Analysis","text":"tidycreel distributed via GitHub (submitted CRAN). Install latest version :","code":"# install.packages(\"pak\") pak::pak(\"chrischizinski/tidycreel\")  # Or using devtools/remotes # install.packages(\"devtools\") devtools::install_github(\"chrischizinski/tidycreel\")"},{"path":"/index.html","id":"example","dir":"","previous_headings":"","what":"Example","title":"Tidy Interface for Creel Survey Design and Analysis","text":"Survey-first estimators using bundled toy data:","code":"library(tidycreel)  # Load example data interviews <- readr::read_csv(   system.file(\"extdata/toy_interviews.csv\", package = \"tidycreel\") ) counts <- readr::read_csv(   system.file(\"extdata/toy_counts.csv\", package = \"tidycreel\") ) calendar <- readr::read_csv(   system.file(\"extdata/toy_calendar.csv\", package = \"tidycreel\") )  # Create day-PSU design from calendar svy_day <- as_day_svydesign(   calendar,   day_id = \"date\",   strata_vars = c(\"day_type\", \"month\") )  # Estimate effort from instantaneous counts est_effort(svy_day, counts, method = \"instantaneous\", by = c(\"location\"))  # Estimate CPUE and catch from interview data svy_int <- survey::svydesign(ids = ~1, weights = ~1, data = interviews) est_cpue(svy_int, by = c(\"target_species\"), response = \"catch_total\") est_catch(svy_int, by = c(\"target_species\"), response = \"catch_kept\")"},{"path":"/index.html","id":"effort-overview-survey-first","dir":"","previous_headings":"","what":"Effort Overview (Survey-First)","title":"Tidy Interface for Creel Survey Design and Analysis","text":"Instantaneous Progressive (roving) estimators aggregate day × group totals use day-PSU design inference. See vignette: Aerial snapshot counts covariates, post-stratification, calibration covered : Tip: replicate variance, convert day design survey::.svrepdesign() pass estimators.","code":"vignette(\"effort_survey_first\", package = \"tidycreel\") vignette(\"aerial\", package = \"tidycreel\")"},{"path":"/index.html","id":"guides-and-vignettes","dir":"","previous_headings":"","what":"Guides and Vignettes","title":"Tidy Interface for Creel Survey Design and Analysis","text":"Survey terms creel context: translator Replicate designs (bootstrap/jackknife/BRR) creel inference","code":"vignette(\"survey_creel_terms\", package = \"tidycreel\") vignette(\"replicate_designs_creel\", package = \"tidycreel\")"},{"path":"/reference/acres_to_hectares.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert acres to hectares — acres_to_hectares","title":"Convert acres to hectares — acres_to_hectares","text":"Convert acres hectares","code":""},{"path":"/reference/acres_to_hectares.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert acres to hectares — acres_to_hectares","text":"","code":"acres_to_hectares(x)"},{"path":"/reference/acres_to_hectares.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert acres to hectares — acres_to_hectares","text":"x numeric vector (acres)","code":""},{"path":"/reference/acres_to_hectares.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert acres to hectares — acres_to_hectares","text":"numeric vector (hectares)","code":""},{"path":"/reference/as_day_svydesign.html","id":null,"dir":"Reference","previous_headings":"","what":"Construct a day-level survey design for aerial estimation — as_day_svydesign","title":"Construct a day-level survey design for aerial estimation — as_day_svydesign","text":"Builds survey::svydesign sampled days (PSUs) using calendar information. Weights per sampled day computed target vs actual sample counts within strata (target_sample / actual_sample).","code":""},{"path":"/reference/as_day_svydesign.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Construct a day-level survey design for aerial estimation — as_day_svydesign","text":"","code":"as_day_svydesign(   calendar,   day_id = \"date\",   strata_vars = c(\"day_type\", \"month\", \"season\", \"weekend\") )"},{"path":"/reference/as_day_svydesign.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Construct a day-level survey design for aerial estimation — as_day_svydesign","text":"calendar Tibble/data.frame day-level sampling plan, including day_id, target_sample, actual_sample, strata variables. day_id Column name identifying day PSU (default date). strata_vars Character vector calendar columns defining strata (e.g., c(\"day_type\",\"month\")). Missing columns ignored warning.","code":""},{"path":"/reference/as_day_svydesign.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Construct a day-level survey design for aerial estimation — as_day_svydesign","text":"survey::svydesign object one row per sampled day.","code":""},{"path":"/reference/as_day_svydesign.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Construct a day-level survey design for aerial estimation — as_day_svydesign","text":"","code":"cal <- tibble::tibble(   date = as.Date(c(\"2025-08-20\",\"2025-08-21\")),   day_type = c(\"weekday\",\"weekday\"),   month = c(\"August\",\"August\"),   target_sample = c(4,4),   actual_sample = c(2,2) ) svy_day <- as_day_svydesign(cal, day_id = \"date\", strata_vars = c(\"day_type\",\"month\"))"},{"path":"/reference/as_survey_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract survey design object from a creel_design — as_survey_design","title":"Extract survey design object from a creel_design — as_survey_design","text":"helper bridges tidycreel design objects survey package. returns embedded survey::svydesign survey::svrepdesign object downstream analysis.","code":""},{"path":"/reference/as_survey_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract survey design object from a creel_design — as_survey_design","text":"","code":"as_survey_design(design)"},{"path":"/reference/as_survey_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract survey design object from a creel_design — as_survey_design","text":"design creel_design object (subclass)","code":""},{"path":"/reference/as_survey_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract survey design object from a creel_design — as_survey_design","text":"survey::svydesign survey::svrepdesign object","code":""},{"path":"/reference/as_survey_design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract survey design object from a creel_design — as_survey_design","text":"function provides clear, pipe-friendly way access underlying survey design object created tidycreel constructors. Use analysis survey srvyr functions. access-point, roving, bus route designs, returns survey::svydesign. replicate weights designs, returns survey::svrepdesign. Raises error embedded survey design found.","code":""},{"path":"/reference/as_survey_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract survey design object from a creel_design — as_survey_design","text":"","code":"if (FALSE) { # \\dontrun{ access_design <- design_access(   interviews = utils::read.csv(system.file(\"extdata\", \"toy_interviews.csv\",     package = \"tidycreel\"   )),   calendar = utils::read.csv(system.file(\"extdata\", \"toy_calendar.csv\",     package = \"tidycreel\"   )) ) svy <- as_survey_design(access_design) summary(svy) } # }"},{"path":"/reference/as_svrep_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Extract replicate weights survey design from a repweights_design — as_svrep_design","title":"Extract replicate weights survey design from a repweights_design — as_svrep_design","text":"Returns embedded survey::svrepdesign object bootstrap/jackknife/BRR designs.","code":""},{"path":"/reference/as_svrep_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Extract replicate weights survey design from a repweights_design — as_svrep_design","text":"","code":"as_svrep_design(design)"},{"path":"/reference/as_svrep_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Extract replicate weights survey design from a repweights_design — as_svrep_design","text":"design repweights_design object","code":""},{"path":"/reference/as_svrep_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Extract replicate weights survey design from a repweights_design — as_svrep_design","text":"survey::svrepdesign object","code":""},{"path":"/reference/as_svrep_design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Extract replicate weights survey design from a repweights_design — as_svrep_design","text":"Use helper advanced variance estimation resampling-based inference. Raises error embedded svrepdesign found.","code":""},{"path":"/reference/as_svrep_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Extract replicate weights survey design from a repweights_design — as_svrep_design","text":"","code":"if (FALSE) { # \\dontrun{ # Create a replicate weights design first # (design_repweights is an internal function) access_design <- design_access(interviews, calendar) # Then extract the survey design for advanced use # svyrep <- as_svrep_design(rep_design) } # }"},{"path":"/reference/auxiliary_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Auxiliary Data Schema — auxiliary_schema","title":"Auxiliary Data Schema — auxiliary_schema","text":"Defines expected structure auxiliary data (sunrise/sunset, holidays).","code":""},{"path":"/reference/auxiliary_schema.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Auxiliary Data Schema — auxiliary_schema","text":"tibble following columns: date Date, date auxiliary data sunrise POSIXct, sunrise time sunset POSIXct, sunset time holiday Character, holiday name ()","code":""},{"path":"/reference/calendar_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Sampling Calendar Schema — calendar_schema","title":"Sampling Calendar Schema — calendar_schema","text":"Defines expected structure sampling calendar data including temporal strata definitions.","code":""},{"path":"/reference/calendar_schema.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Sampling Calendar Schema — calendar_schema","text":"tibble following columns: date Date, sampling date stratum_id Character, unique stratum identifier day_type Character, type day (weekday, weekend, holiday) season Character, season identifier month Character, month identifier weekend Logical, TRUE weekend holiday Logical, TRUE holiday shift_block Character, shift identifier (morning, afternoon, evening) target_sample Integer, target sample size stratum actual_sample Integer, actual sample size achieved","code":""},{"path":"/reference/capwords.html","id":null,"dir":"Reference","previous_headings":"","what":"Capitalize words — capwords","title":"Capitalize words — capwords","text":"Capitalize words","code":""},{"path":"/reference/capwords.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Capitalize words — capwords","text":"","code":"capwords(x)"},{"path":"/reference/capwords.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Capitalize words — capwords","text":"x character vector","code":""},{"path":"/reference/capwords.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Capitalize words — capwords","text":"character vector","code":""},{"path":"/reference/change_na.html","id":null,"dir":"Reference","previous_headings":"","what":"Change NA or specific values to a target — change_na","title":"Change NA or specific values to a target — change_na","text":"Change NA specific values target","code":""},{"path":"/reference/change_na.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Change NA or specific values to a target — change_na","text":"","code":"change_na(x, from = NA, to = 0)"},{"path":"/reference/change_na.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Change NA or specific values to a target — change_na","text":"x vector values treat missing (default NA) replacement value (default 0)","code":""},{"path":"/reference/change_na.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Change NA or specific values to a target — change_na","text":"vector replacements","code":""},{"path":"/reference/convertToLogical.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert to logical (compat) — convertToLogical","title":"Convert to logical (compat) — convertToLogical","text":"Convert logical (compat)","code":""},{"path":"/reference/convertToLogical.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert to logical (compat) — convertToLogical","text":"","code":"convertToLogical(x)"},{"path":"/reference/convertToLogical.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert to logical (compat) — convertToLogical","text":"x ","code":""},{"path":"/reference/convertToLogical.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert to logical (compat) — convertToLogical","text":"logical","code":""},{"path":"/reference/count_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Instantaneous Count Schema — count_schema","title":"Instantaneous Count Schema — count_schema","text":"Defines expected structure instantaneous count data.","code":""},{"path":"/reference/count_schema.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Instantaneous Count Schema — count_schema","text":"tibble following columns: count_id Character, unique count identifier date Date, count date time POSIXct, count time location Character, sampling location mode Character, fishing mode anglers_count Integer, number anglers observed parties_count Integer, number fishing parties observed weather_code Character, weather condition code temperature Numeric, temperature Celsius wind_speed Numeric, wind speed visibility Character, visibility conditions count_duration Numeric, duration count minutes","code":""},{"path":"/reference/design-constructors.html","id":null,"dir":"Reference","previous_headings":"","what":"Survey Design Constructors for Access-Point Creel Surveys — design-constructors","title":"Survey Design Constructors for Access-Point Creel Surveys — design-constructors","text":"functions create survey design objects different types access-point creel surveys, including standard access designs, roving designs, designs replicate weights.","code":""},{"path":"/reference/design_access.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Access-Point Survey Design (lean container) — design_access","title":"Create Access-Point Survey Design (lean container) — design_access","text":"Constructs lean container access-point creel surveys. validates stores inputs plus descriptive metadata. Estimation uses survey-first estimators day-PSU designs built via as_day_svydesign(). ad-hoc weighting embedded svydesign created .","code":""},{"path":"/reference/design_access.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Access-Point Survey Design (lean container) — design_access","text":"","code":"design_access(   interviews,   calendar,   locations = NULL,   strata_vars = c(\"date\", \"shift_block\", \"location\"),   weight_method = c(\"equal\", \"standard\") )"},{"path":"/reference/design_access.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Access-Point Survey Design (lean container) — design_access","text":"interviews Tibble interview data validated validate_interviews(). calendar Tibble sampling calendar validated validate_calendar(). locations Optional character vector sampling locations; defaults unique locations interviews. strata_vars Character vector variables describing stratification (e.g., c(\"date\",\"shift_block\",\"location\")). Missing columns ignored.","code":""},{"path":"/reference/design_access.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Access-Point Survey Design (lean container) — design_access","text":"list class c(\"access_design\",\"creel_design\",\"list\") containing design_type, interviews, calendar, locations, strata_vars, metadata.","code":""},{"path":"/reference/design_busroute.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Bus Route Survey Design — design_busroute","title":"Create Bus Route Survey Design — design_busroute","text":"Constructs lean design container bus-route creel surveys. design holds validated inputs metadata; estimation performed survey-first estimators (e.g., est_effort.busroute_design()) rely day-PSU survey design as_day_svydesign(). ad-hoc weighting performed .","code":""},{"path":"/reference/design_busroute.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Bus Route Survey Design — design_busroute","text":"","code":"design_busroute(   interviews,   counts,   calendar,   route_schedule,   strata_vars = c(\"date\", \"location\") )"},{"path":"/reference/design_busroute.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Bus Route Survey Design — design_busroute","text":"interviews Tibble interview data validated validate_interviews(). counts Tibble count/observation data validated validate_counts(). HT-style effort estimation, counts include inclusion probabilities (e.g., inclusion_prob) sufficient fields derive upstream. calendar Tibble sampling calendar validated validate_calendar(). Used construct day-level svydesign as_day_svydesign(). route_schedule Tibble describing bus-route schedule (e.g., stop, time, planned coverage). Used diagnostics documentation; used compute weights . strata_vars Character vector descriptive stratification metadata (e.g., c(\"date\",\"location\")). Missing columns ignored.","code":""},{"path":"/reference/design_busroute.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Bus Route Survey Design — design_busroute","text":"list class c(\"busroute_design\",\"creel_design\",\"list\") fields: design_type, interviews, counts, calendar, route_schedule, strata_vars, metadata.","code":""},{"path":"/reference/design_busroute.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Create Bus Route Survey Design — design_busroute","text":"","code":"# design <- design_busroute(interviews, counts, calendar, route_schedule)"},{"path":"/reference/design_roving.html","id":null,"dir":"Reference","previous_headings":"","what":"Create Roving Survey Design (lean container) — design_roving","title":"Create Roving Survey Design (lean container) — design_roving","text":"Constructs lean container roving creel surveys. validates stores inputs plus descriptive metadata. Estimation effort use survey-first estimators counts (instantaneous progressive) coupled day-PSU design as_day_svydesign(). ad-hoc weighting embedded svydesign created .","code":""},{"path":"/reference/design_roving.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Create Roving Survey Design (lean container) — design_roving","text":"","code":"design_roving(   interviews,   counts,   calendar,   locations = NULL,   strata_vars = c(\"date\", \"shift_block\", \"location\"),   effort_method = c(\"ratio\", \"calibrate\"),   coverage_correction = FALSE )"},{"path":"/reference/design_roving.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Create Roving Survey Design (lean container) — design_roving","text":"interviews Tibble validated validate_interviews(). counts Tibble validated validate_counts(). calendar Tibble validated validate_calendar(). locations Optional character vector; defaults union interview count locations. strata_vars Character vector describing stratification (e.g., c(\"date\",\"shift_block\",\"location\")). Missing columns ignored.","code":""},{"path":"/reference/design_roving.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Create Roving Survey Design (lean container) — design_roving","text":"list class c(\"roving_design\",\"creel_design\",\"list\") containing design_type, interviews, counts, calendar, locations, strata_vars, metadata.","code":""},{"path":"/reference/dot-tc_ensure_shift_block.html","id":null,"dir":"Reference","previous_headings":"","what":"Ensure Shift Block — .tc_ensure_shift_block","title":"Ensure Shift Block — .tc_ensure_shift_block","text":"Internal helper function create shift_block missing.","code":""},{"path":"/reference/dot-tc_ensure_shift_block.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Ensure Shift Block — .tc_ensure_shift_block","text":"","code":".tc_ensure_shift_block(data)"},{"path":"/reference/dot-todo.html","id":null,"dir":"Reference","previous_headings":"","what":"Internal TODO stub for compatibility — .todo","title":"Internal TODO stub for compatibility — .todo","text":"Internal TODO stub compatibility","code":""},{"path":"/reference/dot-todo.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Internal TODO stub for compatibility — .todo","text":"","code":".todo(name)"},{"path":"/reference/est_catch.html","id":null,"dir":"Reference","previous_headings":"","what":"Catch/Harvest Total Estimator (survey-first) — est_catch","title":"Catch/Harvest Total Estimator (survey-first) — est_catch","text":"Design-based estimation total catch harvest interview data using survey package. Returns tidy totals groups standard errors Wald confidence intervals.","code":""},{"path":"/reference/est_catch.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Catch/Harvest Total Estimator (survey-first) — est_catch","text":"","code":"est_catch(   design,   by = NULL,   response = c(\"catch_total\", \"catch_kept\", \"weight_total\"),   conf_level = 0.95 )"},{"path":"/reference/est_catch.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Catch/Harvest Total Estimator (survey-first) — est_catch","text":"design svydesign/svrepdesign interviews, creel_design interviews (equal-weight design constructed needed, warning). Character vector grouping variables interview data. response One \"catch_total\", \"catch_kept\", \"weight_total\". Determines total estimated. conf_level Confidence level Wald CIs (default 0.95).","code":""},{"path":"/reference/est_catch.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Catch/Harvest Total Estimator (survey-first) — est_catch","text":"Tibble grouping columns, estimate, se, ci_low, ci_high, n, method, diagnostics list-column.","code":""},{"path":[]},{"path":"/reference/est_cpue.html","id":null,"dir":"Reference","previous_headings":"","what":"CPUE Estimator (survey-first) — est_cpue","title":"CPUE Estimator (survey-first) — est_cpue","text":"Design-based estimation catch per unit effort (CPUE) using survey package. Supports ratio--means (recommended incomplete trips) mean--ratios (complete trips). Returns tidy tibble consistent schema across estimators.","code":""},{"path":"/reference/est_cpue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"CPUE Estimator (survey-first) — est_cpue","text":"","code":"est_cpue(   design,   by = NULL,   response = c(\"catch_total\", \"catch_kept\", \"weight_total\"),   effort_col = \"hours_fished\",   mode = c(\"auto\", \"ratio_of_means\", \"mean_of_ratios\"),   min_trip_hours = 0.5,   conf_level = 0.95 )"},{"path":"/reference/est_cpue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"CPUE Estimator (survey-first) — est_cpue","text":"design svydesign/svrepdesign built interview data, creel_design containing interviews. creel_design supplied, minimal equal-weight design constructed (warns). Character vector grouping variables present interview data (e.g., c(\"target_species\",\"location\")). Missing columns ignored warning. response One \"catch_total\", \"catch_kept\", \"weight_total\". Determines CPUE numerator. effort_col Interview effort column denominator (default \"hours_fished\"). mode Estimation mode: \"auto\" (default; automatically selects based trip_complete field), \"ratio_of_means\" (incomplete trips), \"mean_of_ratios\" (complete trips). min_trip_hours Minimum trip duration hours incomplete trips. Trips shorter truncated avoid unstable ratios. Default 0.5 (30 minutes). used mode=\"auto\" mode=\"ratio_of_means\" incomplete trips. conf_level Confidence level Wald CIs (default 0.95).","code":""},{"path":"/reference/est_cpue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"CPUE Estimator (survey-first) — est_cpue","text":"Tibble grouping columns, estimate, se, ci_low, ci_high, n, method, diagnostics list-column.","code":""},{"path":"/reference/est_cpue.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"CPUE Estimator (survey-first) — est_cpue","text":"Auto mode: Examines trip_complete field determine appropriate estimator. complete trips uses mean--ratios; incomplete uses ratio--means truncation; mixed data combines estimates using effort-weighting. Ratio--means: svyratio(~response, ~effort_col) optionally via svyby(…, =~group, FUN=svyratio). robust trips incomplete. Short trips truncated detected. Mean--ratios: computes trip-level response/effort_col uses svymean/svyby. Prefer complete trips minimal zero-inflation.","code":""},{"path":[]},{"path":"/reference/est_effort.aerial.html","id":null,"dir":"Reference","previous_headings":"","what":"Aerial Effort Estimator — est_effort.aerial","title":"Aerial Effort Estimator — est_effort.aerial","text":"Estimate angler-hours aerial snapshot counts using mean-count expansion within groups, optional visibility calibration adjustments, design-based variance via survey package day-level svydesign provided.","code":""},{"path":"/reference/est_effort.aerial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Aerial Effort Estimator — est_effort.aerial","text":"","code":"est_effort.aerial(   counts,   by = c(\"date\", \"location\"),   minutes_col = c(\"flight_minutes\", \"interval_minutes\", \"count_duration\"),   total_minutes_col = c(\"total_minutes\", \"total_day_minutes\", \"block_total_minutes\"),   day_id = \"date\",   covariates = NULL,   visibility_col = NULL,   calibration_col = NULL,   svy = NULL,   post_strata_var = NULL,   post_strata = NULL,   calibrate_formula = NULL,   calibrate_population = NULL,   calfun = c(\"linear\", \"raking\", \"logit\"),   conf_level = 0.95 )"},{"path":"/reference/est_effort.aerial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Aerial Effort Estimator — est_effort.aerial","text":"counts Data frame/tibble aerial counts least count minutes column (e.g., flight_minutes, interval_minutes, count_duration). Character vector grouping variables present counts (e.g., date, location). Missing columns ignored warning. minutes_col Candidate column names minutes represented count. first present used. total_minutes_col Optional column giving total minutes represented whole day×group (e.g., full day length block coverage). absent, estimator falls back sum per-count minutes within day×group (warns). day_id Day identifier (PSU), typically date, used join survey design. covariates Optional character vector additional grouping variables aerial conditions (e.g., cloud, glare, observer, altitude). visibility_col Optional name column visibility proportion (0–1). Counts divided value (guarded avoid division small numbers). calibration_col Optional name column multiplicative calibration factors apply visibility correction. svy Optional svydesign/svrepdesign encoding day sampling design (must include day_id svy$variables). provided, totals, SEs, CIs computed survey functions. conf_level Confidence level Wald CIs (default 0.95).","code":""},{"path":"/reference/est_effort.aerial.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Aerial Effort Estimator — est_effort.aerial","text":"Tibble grouping columns, estimate, se, ci_low, ci_high, n, method, diagnostics list-column.","code":""},{"path":"/reference/est_effort.aerial.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Aerial Effort Estimator — est_effort.aerial","text":"Effort per day×group = mean(adjusted_count) × total_minutes_represented ÷ 60. Group totals computed survey::svytotal/svyby svy encodes day sampling design.","code":""},{"path":"/reference/est_effort.aerial.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Aerial Effort Estimator — est_effort.aerial","text":"","code":"df <- tibble::tibble(   date = as.Date(rep(\"2025-08-20\", 4)),   location = c(\"A\",\"A\",\"B\",\"B\"),   count = c(10, 12, 8, 15),   interval_minutes = c(60, 60, 60, 60) ) est_effort.aerial(df) #> Warning: ! Aerial: using sum of interval_minutes per day×group as total minutes. #> ℹ Provide `total_minutes_col` for proper expansion. #> # A tibble: 2 × 9 #>   date       location estimate    se ci_low ci_high     n method diagnostics #>   <date>     <chr>       <dbl> <dbl>  <dbl>   <dbl> <int> <chr>  <list>      #> 1 2025-08-20 A              22     2  18.1     25.9     2 aerial <NULL>      #> 2 2025-08-20 B              23     7   9.28    36.7     2 aerial <NULL>"},{"path":"/reference/est_effort.busroute_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Bus-Route Effort Estimation (survey-first HT) — est_effort.busroute_design","title":"Bus-Route Effort Estimation (survey-first HT) — est_effort.busroute_design","text":"Estimate fishing effort bus-route designs using Horvitz–Thompson-style day×group total compute design-based totals variance via survey package. Supports replicate-weight designs.","code":""},{"path":"/reference/est_effort.busroute_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Bus-Route Effort Estimation (survey-first HT) — est_effort.busroute_design","text":"","code":"est_effort.busroute_design(   x,   counts = NULL,   by = c(\"date\", \"location\"),   day_id = \"date\",   inclusion_prob_col = \"inclusion_prob\",   route_minutes_col = \"route_minutes\",   contrib_hours_col = NULL,   covariates = NULL,   svy = NULL,   conf_level = 0.95,   ... )"},{"path":"/reference/est_effort.busroute_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Bus-Route Effort Estimation (survey-first HT) — est_effort.busroute_design","text":"x busroute_design object. counts Optional tibble/data.frame observation data. x contains $counts, used default. Character vector grouping variables retain output (e.g., date, location). Missing columns ignored warning. day_id Day identifier (PSU), typically date. inclusion_prob_col Column name inclusion probability pi observed party/vehicle count segment (default inclusion_prob). route_minutes_col Per-visit route minutes column translate counts time (default route_minutes). Used contrib_hours_col given. contrib_hours_col Optional precomputed contribution hours observed unit (e.g., observed overlap hours). present, HT contribution contrib_hours / pi. Otherwise uses count / pi * route_minutes/60. covariates Optional character vector additional grouping variables. svy Optional svydesign/svrepdesign encoding day-level sampling. absent, day-PSU design constructed x$calendar via as_day_svydesign(). conf_level Confidence level CI (default 0.95). ... Reserved future arguments.","code":""},{"path":"/reference/est_effort.busroute_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Bus-Route Effort Estimation (survey-first HT) — est_effort.busroute_design","text":"tibble group columns, estimate, se, ci_low, ci_high, n, method, diagnostics list-column.","code":""},{"path":"/reference/est_effort.busroute_design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Bus-Route Effort Estimation (survey-first HT) — est_effort.busroute_design","text":"Computes day × group totals using Horvitz–Thompson contributions uses day-PSU survey design compute totals/variance via survey package. Replicate-weight designs supported passing svrepdesign.","code":""},{"path":"/reference/est_effort.busroute_design.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Bus-Route Effort Estimation (survey-first HT) — est_effort.busroute_design","text":"Malvestuto, S.P. (1996). Sampling creel survey data. : Murphy, B.R. & Willis, D.W. (eds) Fisheries Techniques, 2nd Edition. American Fisheries Society.","code":""},{"path":"/reference/est_effort.busroute_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Bus-Route Effort Estimation (survey-first HT) — est_effort.busroute_design","text":"","code":"if (FALSE) { # \\dontrun{ # Example: Create bus-route design and estimate effort # design <- design_busroute(counts, schedule, calendar) # est_effort(design, by = c(\"date\", \"location\")) } # }"},{"path":"/reference/est_effort.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Fishing Effort (survey-first wrapper) — est_effort","title":"Estimate Fishing Effort (survey-first wrapper) — est_effort","text":"High-level convenience wrapper delegates survey-first instantaneous progressive estimators. ensures valid day-level survey design available passes appropriate estimator.","code":""},{"path":"/reference/est_effort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Fishing Effort (survey-first wrapper) — est_effort","text":"","code":"est_effort(   design,   counts,   method = c(\"instantaneous\", \"progressive\"),   by = NULL,   day_id = \"date\",   covariates = NULL,   conf_level = 0.95,   ... )"},{"path":"/reference/est_effort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Fishing Effort (survey-first wrapper) — est_effort","text":"design day-level svydesign/svrepdesign creel_design contains calendar constructing day PSU design. counts Data frame/tibble counts appropriate chosen method. method One \"instantaneous\" (snapshot counts) \"progressive\" (roving/pass-based counts). Character vector grouping variables present counts. NULL, best-effort default used (e.g., location, stratum, shift_block available). day_id Day identifier (PSU) present counts survey design (default \"date\"). covariates Optional character vector additional grouping variables present counts. conf_level Confidence level CIs (default 0.95). ... Forwarded specific estimator.","code":""},{"path":"/reference/est_effort.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Fishing Effort (survey-first wrapper) — est_effort","text":"tibble group columns, estimate, se, ci_low, ci_high, n, method, diagnostics list-column.","code":""},{"path":"/reference/est_effort.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Estimate Fishing Effort (survey-first wrapper) — est_effort","text":"Effort computed day × group totals combined using survey::svytotal/survey::svyby, variance survey design (including replicate-weight designs via svrepdesign).","code":""},{"path":[]},{"path":"/reference/est_effort.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Fishing Effort (survey-first wrapper) — est_effort","text":"","code":"if (FALSE) { # \\dontrun{ # Build a day-level design from a calendar svy_day <- as_day_svydesign(calendar, day_id = \"date\",   strata_vars = c(\"day_type\",\"month\"))  # Instantaneous effort by location est_effort(svy_day, counts_inst, method = \"instantaneous\", by = \"location\")  # Progressive effort by location est_effort(svy_day, counts_roving, method = \"progressive\", by = \"location\") } # }"},{"path":"/reference/est_effort.instantaneous.html","id":null,"dir":"Reference","previous_headings":"","what":"Instantaneous Effort Estimator (survey-first) — est_effort.instantaneous","title":"Instantaneous Effort Estimator (survey-first) — est_effort.instantaneous","text":"Estimate angler-hours instantaneous (snapshot) counts using mean-count expansion per day × group, compute design-based totals variance via survey package day-level design supplied.","code":""},{"path":"/reference/est_effort.instantaneous.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Instantaneous Effort Estimator (survey-first) — est_effort.instantaneous","text":"","code":"est_effort.instantaneous(   counts,   by = c(\"date\", \"location\"),   minutes_col = c(\"interval_minutes\", \"count_duration\", \"flight_minutes\"),   total_minutes_col = c(\"total_minutes\", \"total_day_minutes\", \"block_total_minutes\"),   day_id = \"date\",   covariates = NULL,   svy = NULL,   conf_level = 0.95 )"},{"path":"/reference/est_effort.instantaneous.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Instantaneous Effort Estimator (survey-first) — est_effort.instantaneous","text":"counts Tibble/data.frame instantaneous counts columns: count, minutes column (one interval_minutes, count_duration, flight_minutes), grouping variables (e.g., date, location), optionally total_day_minutes total_minutes day-level expansion. Character vector grouping variables (e.g., date, location). Missing columns ignored warning. minutes_col Candidate name(s) per-count minutes. first present used. total_minutes_col Candidate name(s) day×group total minutes. absent, falls back sum per-count minutes within day×group (warns). day_id Day identifier (PSU), typically date, used join survey design. covariates Optional character vector additional grouping variables (e.g., shift_block, day_type). svy Optional svydesign/svrepdesign day-level sampling design. conf_level Confidence level Wald CIs (default 0.95).","code":""},{"path":"/reference/est_effort.instantaneous.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Instantaneous Effort Estimator (survey-first) — est_effort.instantaneous","text":"Tibble grouping columns, estimate, se, ci_low, ci_high, n, method, diagnostics list-column.","code":""},{"path":"/reference/est_effort.instantaneous.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Instantaneous Effort Estimator (survey-first) — est_effort.instantaneous","text":"Effort per day×group = mean(count) × total_minutes ÷ 60. Aggregates per-count observations day × group totals uses day-PSU survey design compute totals/variance via survey package. svy provided, non-design fallback uses within-group variability approximate SE/CI; prefer valid survey design defensible inference.","code":""},{"path":[]},{"path":"/reference/est_effort.progressive.html","id":null,"dir":"Reference","previous_headings":"","what":"Progressive (Roving) Effort Estimator (survey-first) — est_effort.progressive","title":"Progressive (Roving) Effort Estimator (survey-first) — est_effort.progressive","text":"Estimate angler-hours progressive (roving) counts summing pass-level counts × route_minutes per day × group, compute design-based totals variance via survey package day-level design supplied.","code":""},{"path":"/reference/est_effort.progressive.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Progressive (Roving) Effort Estimator (survey-first) — est_effort.progressive","text":"","code":"est_effort.progressive(   counts,   by = c(\"date\", \"location\"),   route_minutes_col = c(\"route_minutes\", \"circuit_minutes\"),   pass_id = c(\"pass_id\", \"circuit_id\"),   day_id = \"date\",   covariates = NULL,   svy = NULL,   conf_level = 0.95 )"},{"path":"/reference/est_effort.progressive.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Progressive (Roving) Effort Estimator (survey-first) — est_effort.progressive","text":"counts Tibble/data.frame progressive counts columns: count, route_minutes (candidate), grouping variables (e.g., date, location), optional pass_id/circuit_id. Character vector grouping variables (e.g., date, location). Missing columns ignored warning. route_minutes_col Name(s) per-pass route minutes column; first present used. pass_id Optional column name identifying passes. absent, rows treated pass records summed within day × group. day_id Day identifier (PSU), typically date, used join survey design. covariates Optional character vector additional grouping variables. svy Optional svydesign/svrepdesign day-level sampling design. conf_level Confidence level Wald CIs (default 0.95).","code":""},{"path":"/reference/est_effort.progressive.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Progressive (Roving) Effort Estimator (survey-first) — est_effort.progressive","text":"Tibble grouping columns, estimate, se, ci_low, ci_high, n, method, diagnostics list-column.","code":""},{"path":"/reference/est_effort.progressive.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Progressive (Roving) Effort Estimator (survey-first) — est_effort.progressive","text":"Effort per day×group = sum_over_passes(count_pass × route_minutes) ÷ 60. Sums pass-level contributions day × group totals uses day-PSU survey design compute totals variance via survey package.","code":""},{"path":[]},{"path":"/reference/est_effort_aerial.html","id":null,"dir":"Reference","previous_headings":"","what":"Back-compat alias for aerial estimator — est_effort_aerial","title":"Back-compat alias for aerial estimator — est_effort_aerial","text":"Accepts either creel_design x embedded counts counts data frame directly. Prefer est_effort.aerial() counts.","code":""},{"path":"/reference/est_effort_aerial.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Back-compat alias for aerial estimator — est_effort_aerial","text":"","code":"est_effort_aerial(   x = NULL,   counts = NULL,   by = c(\"date\", \"location\"),   minutes_col = c(\"flight_minutes\", \"interval_minutes\", \"count_duration\"),   total_minutes_col = c(\"total_minutes\", \"total_day_minutes\", \"block_total_minutes\"),   day_id = \"date\",   covariates = NULL,   visibility_col = NULL,   calibration_col = NULL,   svy = NULL,   conf_level = 0.95,   ... )"},{"path":"/reference/est_effort_aerial.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Back-compat alias for aerial estimator — est_effort_aerial","text":"x Optional creel_design containing $counts component. counts Data frame/tibble aerial counts least count minutes column (e.g., flight_minutes, interval_minutes, count_duration). Character vector grouping variables present counts (e.g., date, location). Missing columns ignored warning. minutes_col Candidate column names minutes represented count. first present used. total_minutes_col Optional column giving total minutes represented whole day×group (e.g., full day length block coverage). absent, estimator falls back sum per-count minutes within day×group (warns). day_id Day identifier (PSU), typically date, used join survey design. covariates Optional character vector additional grouping variables aerial conditions (e.g., cloud, glare, observer, altitude). visibility_col Optional name column visibility proportion (0–1). Counts divided value (guarded avoid division small numbers). calibration_col Optional name column multiplicative calibration factors apply visibility correction. svy Optional svydesign/svrepdesign encoding day sampling design (must include day_id svy$variables). provided, totals, SEs, CIs computed survey functions. conf_level Confidence level Wald CIs (default 0.95).","code":""},{"path":"/reference/estimate_cpue.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Catch Per Unit Effort (CPUE) — estimate_cpue","title":"Estimate Catch Per Unit Effort (CPUE) — estimate_cpue","text":"Estimates catch per unit effort species, mode, grouping variables. Supports number-based (fish per hour) weight-based (kg per hour) CPUE.","code":""},{"path":"/reference/estimate_cpue.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Catch Per Unit Effort (CPUE) — estimate_cpue","text":"","code":"estimate_cpue(   design,   by = NULL,   species = NULL,   type = c(\"number\", \"weight\"),   level = 0.95 )"},{"path":"/reference/estimate_cpue.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Catch Per Unit Effort (CPUE) — estimate_cpue","text":"design creel design object created design_access, design_roving, design_repweights. Character vector variables group estimates . Default estimate overall CPUE. species Character vector species include. NULL, includes species data. type Character, either \"number\" (fish per hour) \"weight\" (kg per hour). Default \"number\". level Confidence level confidence intervals. Default 0.95.","code":""},{"path":"/reference/estimate_cpue.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Catch Per Unit Effort (CPUE) — estimate_cpue","text":"tibble columns: group_vars Grouping variables list column n Number interviews group cpue_estimate Estimated CPUE cpue_se Standard error CPUE estimate cpue_lower Lower confidence limit cpue_upper Upper confidence limit species Species included estimate type Type CPUE (number weight) design_type Type survey design used","code":""},{"path":"/reference/estimate_cpue.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Catch Per Unit Effort (CPUE) — estimate_cpue","text":"","code":"if (FALSE) { # \\dontrun{ # Estimate CPUE by species cpue_by_species <- estimate_cpue(design, by = \"target_species\")  # Estimate weight-based CPUE for bass bass_cpue_weight <- estimate_cpue(design, species = \"bass\", type = \"weight\") } # }"},{"path":"/reference/estimate_effort.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Fishing Effort — estimate_effort","title":"Estimate Fishing Effort — estimate_effort","text":"Estimates total fishing effort (angler-hours party-hours) strata overall, using survey design weights. Supports access-point roving survey designs.","code":""},{"path":"/reference/estimate_effort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Fishing Effort — estimate_effort","text":"","code":"estimate_effort(design, by = NULL, total = TRUE, level = 0.95)"},{"path":"/reference/estimate_effort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Fishing Effort — estimate_effort","text":"design creel design object created design_access, design_roving, design_repweights. Character vector variables group estimates . Default strata variables defined design. total Logical, whether include overall total estimate addition grouped estimates. Default TRUE. level Confidence level confidence intervals. Default 0.95.","code":""},{"path":"/reference/estimate_effort.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Fishing Effort — estimate_effort","text":"tibble columns: group_vars Grouping variables list column n Number interviews group effort_estimate Estimated total effort effort_se Standard error effort estimate effort_lower Lower confidence limit effort_upper Upper confidence limit design_type Type survey design used estimation_method Method used estimation","code":""},{"path":"/reference/estimate_effort.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Fishing Effort — estimate_effort","text":"","code":"if (FALSE) { # \\dontrun{ # Create design interviews <- readr::read_csv(system.file(\"extdata/toy_interviews.csv\",   package = \"tidycreel\" )) calendar <- readr::read_csv(system.file(\"extdata/toy_calendar.csv\",   package = \"tidycreel\" ))  design <- design_access(interviews = interviews, calendar = calendar)  # Estimate effort by date effort_by_date <- estimate_effort(design, by = \"date\")  # Estimate effort by location and mode effort_by_location_mode <- estimate_effort(design, by = c(\"location\", \"mode\")) } # }"},{"path":"/reference/estimate_harvest.html","id":null,"dir":"Reference","previous_headings":"","what":"Estimate Total Harvest — estimate_harvest","title":"Estimate Total Harvest — estimate_harvest","text":"Estimates total harvest (catch kept) species, mode, grouping variables. Supports number-based (count) weight-based (kg) harvest.","code":""},{"path":"/reference/estimate_harvest.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Estimate Total Harvest — estimate_harvest","text":"","code":"estimate_harvest(   design,   by = NULL,   species = NULL,   type = c(\"number\", \"weight\"),   level = 0.95 )"},{"path":"/reference/estimate_harvest.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Estimate Total Harvest — estimate_harvest","text":"design creel design object created design_access, design_roving, design_repweights. Character vector variables group estimates . Default estimate overall harvest. species Character vector species include. NULL, includes species data. type Character, either \"number\" (count) \"weight\" (kg). Default \"number\". level Confidence level confidence intervals. Default 0.95.","code":""},{"path":"/reference/estimate_harvest.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Estimate Total Harvest — estimate_harvest","text":"tibble columns: group_vars Grouping variables list column n Number interviews group harvest_estimate Estimated total harvest harvest_se Standard error harvest estimate harvest_lower Lower confidence limit harvest_upper Upper confidence limit species Species included estimate type Type harvest (number weight) design_type Type survey design used","code":""},{"path":"/reference/estimate_harvest.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Estimate Total Harvest — estimate_harvest","text":"","code":"if (FALSE) { # \\dontrun{ # Estimate harvest by species harvest_by_species <- estimate_harvest(design, by = \"target_species\")  # Estimate weight-based harvest for walleye walleye_harvest_weight <- estimate_harvest(design, species = \"walleye\", type = \"weight\") } # }"},{"path":"/reference/estimators.html","id":null,"dir":"Reference","previous_headings":"","what":"Core Estimators for Creel Survey Analysis — estimators","title":"Core Estimators for Creel Survey Analysis — estimators","text":"functions provide design-based estimation fishing effort, catch per unit effort (CPUE), harvest totals creel surveys. estimators integrate survey design objects created design constructors.","code":""},{"path":"/reference/hectares_to_acres.html","id":null,"dir":"Reference","previous_headings":"","what":"Convert hectares to acres — hectares_to_acres","title":"Convert hectares to acres — hectares_to_acres","text":"Convert hectares acres","code":""},{"path":"/reference/hectares_to_acres.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Convert hectares to acres — hectares_to_acres","text":"","code":"hectares_to_acres(x)"},{"path":"/reference/hectares_to_acres.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Convert hectares to acres — hectares_to_acres","text":"x numeric vector (hectares)","code":""},{"path":"/reference/hectares_to_acres.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Convert hectares to acres — hectares_to_acres","text":"numeric vector (acres)","code":""},{"path":"/reference/interval_minutes.html","id":null,"dir":"Reference","previous_headings":"","what":"Calculate interval in minutes between two time columns — interval_minutes","title":"Calculate interval in minutes between two time columns — interval_minutes","text":"Uses lubridate compute difference minutes two POSIXct vectors.","code":""},{"path":"/reference/interval_minutes.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Calculate interval in minutes between two time columns — interval_minutes","text":"","code":"interval_minutes(start, end)"},{"path":"/reference/interval_minutes.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Calculate interval in minutes between two time columns — interval_minutes","text":"start POSIXct vector end POSIXct vector","code":""},{"path":"/reference/interval_minutes.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Calculate interval in minutes between two time columns — interval_minutes","text":"Numeric vector interval lengths minutes","code":""},{"path":"/reference/interval_minutes.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Calculate interval in minutes between two time columns — interval_minutes","text":"","code":"start_time <- as.POSIXct(\"2025-01-01 08:00:00\") end_time <- as.POSIXct(\"2025-01-01 12:30:00\") interval_minutes(start_time, end_time) #> [1] 270"},{"path":"/reference/interview_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Interview Data Schema — interview_schema","title":"Interview Data Schema — interview_schema","text":"Defines expected structure angler interview data.","code":""},{"path":"/reference/interview_schema.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Interview Data Schema — interview_schema","text":"tibble following columns: interview_id Character, unique interview identifier date Date, interview date time_start POSIXct, interview start time time_end POSIXct, interview end time location Character, sampling location mode Character, fishing mode (bank, boat, ice, etc.) party_size Integer, number anglers party hours_fished Numeric, hours fished party target_species Character, primary target species catch_total Integer, total fish caught catch_kept Integer, fish kept catch_released Integer, fish released weight_total Numeric, total weight catch (kg) trip_complete Logical, TRUE trip complete interview effort_expansion Numeric, expansion factor effort estimation","code":""},{"path":"/reference/is.even.html","id":null,"dir":"Reference","previous_headings":"","what":"Even-number predicate — is.even","title":"Even-number predicate — is.even","text":"Even-number predicate","code":""},{"path":"/reference/is.even.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Even-number predicate — is.even","text":"","code":"is.even(x)"},{"path":"/reference/is.even.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Even-number predicate — is.even","text":"x integer/numeric vector","code":""},{"path":"/reference/is.even.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Even-number predicate — is.even","text":"logical","code":""},{"path":"/reference/na.return.html","id":null,"dir":"Reference","previous_headings":"","what":"Replace NAs with a value (compat) — na.return","title":"Replace NAs with a value (compat) — na.return","text":"Replace NAs value (compat)","code":""},{"path":"/reference/na.return.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Replace NAs with a value (compat) — na.return","text":"","code":"na.return(x, value = NA)"},{"path":"/reference/na.return.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Replace NAs with a value (compat) — na.return","text":"x vector value replacement value (default NA)","code":""},{"path":"/reference/na.return.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Replace NAs with a value (compat) — na.return","text":"vector NAs replaced","code":""},{"path":"/reference/parse_time_column.html","id":null,"dir":"Reference","previous_headings":"","what":"Parse time columns using lubridate — parse_time_column","title":"Parse time columns using lubridate — parse_time_column","text":"Attempts parse vector time strings POSIXct using lubridate. Returns parsed times original already POSIXct.","code":""},{"path":"/reference/parse_time_column.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Parse time columns using lubridate — parse_time_column","text":"","code":"parse_time_column(x)"},{"path":"/reference/parse_time_column.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Parse time columns using lubridate — parse_time_column","text":"x Character vector POSIXct","code":""},{"path":"/reference/parse_time_column.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Parse time columns using lubridate — parse_time_column","text":"POSIXct vector","code":""},{"path":"/reference/parse_time_column.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Parse time columns using lubridate — parse_time_column","text":"","code":"parse_time_column(c(\"2025-08-20 08:00:00\", \"2025-08-20 12:00:00\")) #> [1] \"2025-08-20 08:00:00 UTC\" \"2025-08-20 12:00:00 UTC\""},{"path":"/reference/plot_design.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot survey design structure — plot_design","title":"Plot survey design structure — plot_design","text":"Visualize survey design date, shift, location, stratum, grouping variables. Supports bar plots, faceted plots, interactive plots (via plotly available).","code":""},{"path":"/reference/plot_design.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot survey design structure — plot_design","text":"","code":"plot_design(   design,   by = c(\"date\", \"shift_block\", \"location\", \"stratum\"),   type = c(\"bar\", \"facet\", \"interactive\"),   ... )"},{"path":"/reference/plot_design.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot survey design structure — plot_design","text":"design creel_design object data frame survey structure. Character vector grouping variables (e.g., date, shift_block, location, stratum). type Plot type: \"bar\", \"facet\", \"interactive\". ... Additional arguments passed ggplot2 plotly.","code":""},{"path":"/reference/plot_design.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot survey design structure — plot_design","text":"ggplot plotly object.","code":""},{"path":"/reference/plot_design.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot survey design structure — plot_design","text":"Visualizes survey design structure effort estimates. Supports bar, facet, interactive plots. See vignettes usage examples.","code":""},{"path":"/reference/plot_design.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot survey design structure — plot_design","text":"Wickham, H. (2016). ggplot2: Elegant Graphics Data Analysis. Springer-Verlag New York.","code":""},{"path":"/reference/plot_design.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot survey design structure — plot_design","text":"","code":"if (FALSE) { # \\dontrun{ # Create a design first design <- design_access(interviews, calendar)  # Plot survey design structure plot_design(design, by = c(\"date\", \"shift_block\"), type = \"bar\") } # }"},{"path":"/reference/plot_effort.html","id":null,"dir":"Reference","previous_headings":"","what":"Plot effort estimates — plot_effort","title":"Plot effort estimates — plot_effort","text":"Visualize effort estimates stratum, date, location, grouping variables. Supports line, bar, interactive plots.","code":""},{"path":"/reference/plot_effort.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Plot effort estimates — plot_effort","text":"","code":"plot_effort(   effort_df,   by = c(\"date\", \"location\", \"stratum\"),   type = c(\"line\", \"bar\", \"interactive\"),   ... )"},{"path":"/reference/plot_effort.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Plot effort estimates — plot_effort","text":"effort_df Data frame/tibble effort estimates (output est_effort similar). Character vector grouping variables. type Plot type: \"line\", \"bar\", \"interactive\". ... Additional arguments passed ggplot2 plotly.","code":""},{"path":"/reference/plot_effort.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Plot effort estimates — plot_effort","text":"ggplot plotly object.","code":""},{"path":"/reference/plot_effort.html","id":"details","dir":"Reference","previous_headings":"","what":"Details","title":"Plot effort estimates — plot_effort","text":"Visualizes effort estimates stratum, date, location, grouping variables. Supports line, bar, interactive plots. See vignettes usage examples.","code":""},{"path":"/reference/plot_effort.html","id":"references","dir":"Reference","previous_headings":"","what":"References","title":"Plot effort estimates — plot_effort","text":"Wickham, H. (2016). ggplot2: Elegant Graphics Data Analysis. Springer-Verlag New York.","code":""},{"path":"/reference/plot_effort.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Plot effort estimates — plot_effort","text":"","code":"if (FALSE) { # \\dontrun{ # First estimate effort effort_est <- est_effort(design, counts, by = c(\"date\", \"location\"))  # Plot effort estimates plot_effort(effort_est, by = c(\"date\", \"location\"), type = \"line\") } # }"},{"path":"/reference/reference_schema.html","id":null,"dir":"Reference","previous_headings":"","what":"Reference Table Schema — reference_schema","title":"Reference Table Schema — reference_schema","text":"Defines expected structure reference tables (species, waterbody, etc.).","code":""},{"path":"/reference/reference_schema.html","id":"format","dir":"Reference","previous_headings":"","what":"Format","title":"Reference Table Schema — reference_schema","text":"tibble following columns: code Character, unique code description Character, code description","code":""},{"path":"/reference/report_dropped_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Report dropped rows — report_dropped_rows","title":"Report dropped rows — report_dropped_rows","text":"Returns summary rows dropped due missing invalid data.","code":""},{"path":"/reference/report_dropped_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Report dropped rows — report_dropped_rows","text":"","code":"report_dropped_rows(original, filtered)"},{"path":"/reference/report_dropped_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Report dropped rows — report_dropped_rows","text":"original Original data.frame filtered Filtered data.frame","code":""},{"path":"/reference/report_dropped_rows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Report dropped rows — report_dropped_rows","text":"List n_dropped dropped_rows","code":""},{"path":"/reference/report_dropped_rows.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Report dropped rows — report_dropped_rows","text":"","code":"df_original <- data.frame(id = 1:3, value = c(10, NA, 30)) df_cleaned <- data.frame(id = c(1, 3), value = c(10, 30)) report_dropped_rows(df_original, df_cleaned) #> $n_dropped #> [1] 1 #>  #> $dropped_rows #>   id value #> 1  2    NA #>"},{"path":"/reference/schema_test_runner.html","id":null,"dir":"Reference","previous_headings":"","what":"Run All Schema Validation Functions — schema_test_runner","title":"Run All Schema Validation Functions — schema_test_runner","text":"function runs available schema validation functions named list tibbles. returns list results (invisible pass, errors fail).","code":""},{"path":"/reference/schema_test_runner.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Run All Schema Validation Functions — schema_test_runner","text":"","code":"schema_test_runner(data_list, strict = TRUE)"},{"path":"/reference/schema_test_runner.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Run All Schema Validation Functions — schema_test_runner","text":"data_list Named list tibbles: names must match schema types (calendar, interviews, counts, auxiliary, reference) strict Logical, TRUE throws error validation failure","code":""},{"path":"/reference/schema_test_runner.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Run All Schema Validation Functions — schema_test_runner","text":"Invisibly returns validated data, errors invalid","code":""},{"path":"/reference/schema_test_runner.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Run All Schema Validation Functions — schema_test_runner","text":"","code":"schema_test_runner(list(   calendar = calendar_tbl,   interviews = interviews_tbl,   counts = counts_tbl,   auxiliary = auxiliary_tbl,   reference = reference_tbl )) #> Error: object 'calendar_tbl' not found"},{"path":"/reference/standardize_time_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Standardize time column names using stringr — standardize_time_columns","title":"Standardize time column names using stringr — standardize_time_columns","text":"Renames columns data.frame standard time column names common variants found.","code":""},{"path":"/reference/standardize_time_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Standardize time column names using stringr — standardize_time_columns","text":"","code":"standardize_time_columns(df)"},{"path":"/reference/standardize_time_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Standardize time column names using stringr — standardize_time_columns","text":"df Data.frame","code":""},{"path":"/reference/standardize_time_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Standardize time column names using stringr — standardize_time_columns","text":"Data.frame standardized time column names","code":""},{"path":"/reference/standardize_time_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Standardize time column names using stringr — standardize_time_columns","text":"","code":"df <- data.frame(timestamp = \"2025-01-01 08:00\", value = 1) standardize_time_columns(df) #>               time value #> 1 2025-01-01 08:00     1"},{"path":"/reference/tc_abort_missing_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Abort with a standardized message for missing columns (cli) — tc_abort_missing_cols","title":"Abort with a standardized message for missing columns (cli) — tc_abort_missing_cols","text":"Abort standardized message missing columns (cli)","code":""},{"path":"/reference/tc_abort_missing_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Abort with a standardized message for missing columns (cli) — tc_abort_missing_cols","text":"","code":"tc_abort_missing_cols(df, cols, context = \"\")"},{"path":"/reference/tc_abort_missing_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Abort with a standardized message for missing columns (cli) — tc_abort_missing_cols","text":"df Data frame check cols Required columns context Context string error message","code":""},{"path":"/reference/tc_as_time.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility: Parse to POSIXct — tc_as_time","title":"Utility: Parse to POSIXct — tc_as_time","text":"Parses vector POSIXct using lubridate available, else base R.","code":""},{"path":"/reference/tc_as_time.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility: Parse to POSIXct — tc_as_time","text":"","code":"tc_as_time(x)"},{"path":"/reference/tc_as_time.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility: Parse to POSIXct — tc_as_time","text":"x Character numeric vector","code":""},{"path":"/reference/tc_as_time.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility: Parse to POSIXct — tc_as_time","text":"POSIXct vector","code":""},{"path":"/reference/tc_clamp01.html","id":null,"dir":"Reference","previous_headings":"","what":"Clamp probabilities to (0,1] with a warning — tc_clamp01","title":"Clamp probabilities to (0,1] with a warning — tc_clamp01","text":"Clamp probabilities (0,1] warning","code":""},{"path":"/reference/tc_clamp01.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Clamp probabilities to (0,1] with a warning — tc_clamp01","text":"","code":"tc_clamp01(x, name = \"probability\")"},{"path":"/reference/tc_clamp01.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Clamp probabilities to (0,1] with a warning — tc_clamp01","text":"x numeric vector probabilities name optional name messaging","code":""},{"path":"/reference/tc_clamp01.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Clamp probabilities to (0,1] with a warning — tc_clamp01","text":"clamped numeric vector","code":""},{"path":"/reference/tc_confint.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility: Confidence Interval Helper — tc_confint","title":"Utility: Confidence Interval Helper — tc_confint","text":"Computes normal t-based confidence interval.","code":""},{"path":"/reference/tc_confint.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility: Confidence Interval Helper — tc_confint","text":"","code":"tc_confint(mean, se, level = 0.95, df = NULL)"},{"path":"/reference/tc_confint.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility: Confidence Interval Helper — tc_confint","text":"mean Numeric mean se Standard error level Confidence level df Degrees freedom (optional)","code":""},{"path":"/reference/tc_confint.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility: Confidence Interval Helper — tc_confint","text":"Numeric vector: lower, upper","code":""},{"path":"/reference/tc_diag_drop.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility: Diagnostics for Dropped Rows — tc_diag_drop","title":"Utility: Diagnostics for Dropped Rows — tc_diag_drop","text":"Builds diagnostics tibble dropped rows.","code":""},{"path":"/reference/tc_diag_drop.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility: Diagnostics for Dropped Rows — tc_diag_drop","text":"","code":"tc_diag_drop(df_before, df_after, reason)"},{"path":"/reference/tc_diag_drop.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility: Diagnostics for Dropped Rows — tc_diag_drop","text":"df_before Data frame dropping df_after Data frame dropping reason Reason drop","code":""},{"path":"/reference/tc_diag_drop.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility: Diagnostics for Dropped Rows — tc_diag_drop","text":"Tibble diagnostics","code":""},{"path":"/reference/tc_drop_na_rows.html","id":null,"dir":"Reference","previous_headings":"","what":"Drop rows with missing values in required columns; return diagnostics — tc_drop_na_rows","title":"Drop rows with missing values in required columns; return diagnostics — tc_drop_na_rows","text":"Drop rows missing values required columns; return diagnostics","code":""},{"path":"/reference/tc_drop_na_rows.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Drop rows with missing values in required columns; return diagnostics — tc_drop_na_rows","text":"","code":"tc_drop_na_rows(df, required_cols, reason = \"missing required fields\")"},{"path":"/reference/tc_drop_na_rows.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Drop rows with missing values in required columns; return diagnostics — tc_drop_na_rows","text":"df data.frame required_cols character vector column names reason text reason diagnostics","code":""},{"path":"/reference/tc_drop_na_rows.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Drop rows with missing values in required columns; return diagnostics — tc_drop_na_rows","text":"list(df = filtered_df, diagnostics = tibble)","code":""},{"path":"/reference/tc_group_warn.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility: Group Warn — tc_group_warn","title":"Utility: Group Warn — tc_group_warn","text":"Drops absent grouping columns warning.","code":""},{"path":"/reference/tc_group_warn.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility: Group Warn — tc_group_warn","text":"","code":"tc_group_warn(by, df_names)"},{"path":"/reference/tc_group_warn.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility: Group Warn — tc_group_warn","text":"Character vector grouping columns df_names Names data frame","code":""},{"path":"/reference/tc_group_warn.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility: Group Warn — tc_group_warn","text":"Filtered grouping columns","code":""},{"path":"/reference/tc_guess_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility: Guess Columns — tc_guess_cols","title":"Utility: Guess Columns — tc_guess_cols","text":"Maps synonyms standard column names present.","code":""},{"path":"/reference/tc_guess_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility: Guess Columns — tc_guess_cols","text":"","code":"tc_guess_cols(df, synonyms)"},{"path":"/reference/tc_guess_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility: Guess Columns — tc_guess_cols","text":"df Data frame synonyms Named character vector (names = standard, values = synonyms)","code":""},{"path":"/reference/tc_guess_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility: Guess Columns — tc_guess_cols","text":"Data frame columns renamed","code":""},{"path":"/reference/tc_require_cols.html","id":null,"dir":"Reference","previous_headings":"","what":"Utility: Require Columns — tc_require_cols","title":"Utility: Require Columns — tc_require_cols","text":"Checks required columns present data.frame. Throws error listing missing columns.","code":""},{"path":"/reference/tc_require_cols.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Utility: Require Columns — tc_require_cols","text":"","code":"tc_require_cols(df, cols, context = \"\")"},{"path":"/reference/tc_require_cols.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Utility: Require Columns — tc_require_cols","text":"df Data frame check cols Character vector required column names context Optional string describing context (error message)","code":""},{"path":"/reference/tc_require_cols.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Utility: Require Columns — tc_require_cols","text":"Invisibly returns TRUE columns present","code":""},{"path":"/reference/tc_require_cols.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Utility: Require Columns — tc_require_cols","text":"","code":"tc_require_cols(data.frame(a=1, b=2), c(\"a\", \"b\"))"},{"path":"/reference/tidycreel-compat-stubs.html","id":null,"dir":"Reference","previous_headings":"","what":"Legacy stubs removed; not part of the package — tidycreel-compat-stubs","title":"Legacy stubs removed; not part of the package — tidycreel-compat-stubs","text":"Legacy stubs removed; part package","code":""},{"path":"/reference/tidycreel-package.html","id":null,"dir":"Reference","previous_headings":"","what":"tidycreel: Tools for creel survey design, estimation, and reporting — tidycreel-package","title":"tidycreel: Tools for creel survey design, estimation, and reporting — tidycreel-package","text":"(One-sentence summary goes .)","code":""},{"path":[]},{"path":"/reference/tidycreel-package.html","id":"author","dir":"Reference","previous_headings":"","what":"Author","title":"tidycreel: Tools for creel survey design, estimation, and reporting — tidycreel-package","text":"Maintainer: Christopher Chizinski chris.chizinski@unl.edu (ORCID)","code":""},{"path":"/reference/trim.html","id":null,"dir":"Reference","previous_headings":"","what":"Trim leading and trailing whitespace — trim","title":"Trim leading and trailing whitespace — trim","text":"Trim leading trailing whitespace","code":""},{"path":"/reference/trim.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Trim leading and trailing whitespace — trim","text":"","code":"trim(x)"},{"path":"/reference/trim.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Trim leading and trailing whitespace — trim","text":"x character vector","code":""},{"path":"/reference/trim.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Trim leading and trailing whitespace — trim","text":"character vector","code":""},{"path":"/reference/validate_allowed_values.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate values in a column — validate_allowed_values","title":"Validate values in a column — validate_allowed_values","text":"Checks values column within set allowed values. Returns TRUE valid, otherwise returns vector invalid values.","code":""},{"path":"/reference/validate_allowed_values.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate values in a column — validate_allowed_values","text":"","code":"validate_allowed_values(x, allowed)"},{"path":"/reference/validate_allowed_values.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate values in a column — validate_allowed_values","text":"x Vector values allowed Allowed values","code":""},{"path":"/reference/validate_allowed_values.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate values in a column — validate_allowed_values","text":"TRUE valid, else vector invalid values","code":""},{"path":"/reference/validate_allowed_values.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate values in a column — validate_allowed_values","text":"","code":"shifts <- c(\"AM\", \"PM\", \"AM\") validate_allowed_values(shifts, c(\"AM\", \"PM\", \"EVE\")) #> [1] TRUE"},{"path":"/reference/validate_auxiliary.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate auxiliary data schema — validate_auxiliary","title":"Validate auxiliary data schema — validate_auxiliary","text":"Validate auxiliary data schema","code":""},{"path":"/reference/validate_auxiliary.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate auxiliary data schema — validate_auxiliary","text":"","code":"validate_auxiliary(auxiliary, strict = TRUE)"},{"path":"/reference/validate_auxiliary.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate auxiliary data schema — validate_auxiliary","text":"auxiliary tibble containing auxiliary data strict Logical, TRUE throws error validation failure","code":""},{"path":"/reference/validate_auxiliary.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate auxiliary data schema — validate_auxiliary","text":"Invisibly returns validated data, throws error invalid","code":""},{"path":"/reference/validate_calendar.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Calendar Data — validate_calendar","title":"Validate Calendar Data — validate_calendar","text":"Validates calendar data conforms expected schema.","code":""},{"path":"/reference/validate_calendar.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Calendar Data — validate_calendar","text":"","code":"validate_calendar(calendar, strict = TRUE)"},{"path":"/reference/validate_calendar.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Calendar Data — validate_calendar","text":"calendar tibble containing calendar data strict Logical, TRUE throws error validation failure","code":""},{"path":"/reference/validate_calendar.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Calendar Data — validate_calendar","text":"Invisibly returns validated data, throws error invalid","code":""},{"path":"/reference/validate_calendar.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate Calendar Data — validate_calendar","text":"","code":"if (FALSE) { # \\dontrun{ calendar <- tibble::tibble(   date = as.Date(\"2024-01-01\"),   stratum_id = \"2024-01-01-weekday-morning\",   day_type = \"weekday\",   season = \"winter\",   month = \"January\",   weekend = FALSE,   holiday = FALSE,   shift_block = \"morning\",   target_sample = 10L,   actual_sample = 8L ) validate_calendar(calendar) } # }"},{"path":"/reference/validate_counts.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Count Data — validate_counts","title":"Validate Count Data — validate_counts","text":"Validates instantaneous count data conforms expected schema.","code":""},{"path":"/reference/validate_counts.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Count Data — validate_counts","text":"","code":"validate_counts(counts, strict = TRUE)"},{"path":"/reference/validate_counts.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Count Data — validate_counts","text":"counts tibble containing count data strict Logical, TRUE throws error validation failure","code":""},{"path":"/reference/validate_counts.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Count Data — validate_counts","text":"Invisibly returns validated data, throws error invalid","code":""},{"path":"/reference/validate_counts.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate Count Data — validate_counts","text":"","code":"if (FALSE) { # \\dontrun{ counts <- tibble::tibble(   count_id = \"CNT001\",   date = as.Date(\"2024-01-01\"),   time = as.POSIXct(\"2024-01-01 09:00:00\"),   location = \"Lake_A\",   mode = \"boat\",   anglers_count = 15L,   parties_count = 8L,   weather_code = \"clear\",   temperature = 22.5,   wind_speed = 5.2,   visibility = \"good\",   count_duration = 15 ) validate_counts(counts) } # }"},{"path":"/reference/validate_interviews.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate Interview Data — validate_interviews","title":"Validate Interview Data — validate_interviews","text":"Validates interview data conforms expected schema.","code":""},{"path":"/reference/validate_interviews.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate Interview Data — validate_interviews","text":"","code":"validate_interviews(interviews, strict = TRUE)"},{"path":"/reference/validate_interviews.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate Interview Data — validate_interviews","text":"interviews tibble containing interview data strict Logical, TRUE throws error validation failure","code":""},{"path":"/reference/validate_interviews.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate Interview Data — validate_interviews","text":"Invisibly returns validated data, throws error invalid","code":""},{"path":"/reference/validate_interviews.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate Interview Data — validate_interviews","text":"","code":"if (FALSE) { # \\dontrun{ interviews <- tibble::tibble(   interview_id = \"INT001\",   date = as.Date(\"2024-01-01\"),   time_start = as.POSIXct(\"2024-01-01 08:00:00\"),   time_end = as.POSIXct(\"2024-01-01 08:15:00\"),   location = \"Lake_A\",   mode = \"boat\",   party_size = 2L,   hours_fished = 4.5,   target_species = \"walleye\",   catch_total = 5L,   catch_kept = 3L,   catch_released = 2L,   weight_total = 2.5,   trip_complete = TRUE,   effort_expansion = 1.0 ) validate_interviews(interviews) } # }"},{"path":"/reference/validate_reference.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate reference table schema — validate_reference","title":"Validate reference table schema — validate_reference","text":"Validate reference table schema","code":""},{"path":"/reference/validate_reference.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate reference table schema — validate_reference","text":"","code":"validate_reference(reference, strict = TRUE)"},{"path":"/reference/validate_reference.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate reference table schema — validate_reference","text":"reference tibble containing reference table data strict Logical, TRUE throws error validation failure","code":""},{"path":"/reference/validate_reference.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate reference table schema — validate_reference","text":"Invisibly returns validated data, throws error invalid","code":""},{"path":"/reference/validate_required_columns.html","id":null,"dir":"Reference","previous_headings":"","what":"Validate required columns in a data.frame — validate_required_columns","title":"Validate required columns in a data.frame — validate_required_columns","text":"Checks required columns present input data.frame tibble. Returns TRUE present, otherwise returns character vector missing columns.","code":""},{"path":"/reference/validate_required_columns.html","id":"ref-usage","dir":"Reference","previous_headings":"","what":"Usage","title":"Validate required columns in a data.frame — validate_required_columns","text":"","code":"validate_required_columns(df, required)"},{"path":"/reference/validate_required_columns.html","id":"arguments","dir":"Reference","previous_headings":"","what":"Arguments","title":"Validate required columns in a data.frame — validate_required_columns","text":"df data.frame tibble required Character vector required column names","code":""},{"path":"/reference/validate_required_columns.html","id":"value","dir":"Reference","previous_headings":"","what":"Value","title":"Validate required columns in a data.frame — validate_required_columns","text":"TRUE present, else character vector missing columns","code":""},{"path":"/reference/validate_required_columns.html","id":"ref-examples","dir":"Reference","previous_headings":"","what":"Examples","title":"Validate required columns in a data.frame — validate_required_columns","text":"","code":"df <- data.frame(date = \"2025-01-01\", count = 5) validate_required_columns(df, c(\"date\", \"count\")) #> [1] TRUE"},{"path":"/news/index.html","id":"tidycreel-0009000-development","dir":"Changelog","previous_headings":"","what":"tidycreel 0.0.0.9000 (development)","title":"tidycreel 0.0.0.9000 (development)","text":"Survey-first refactor: Estimation relies day-PSU designs as_day_svydesign() interview-level svydesign; legacy constructors (design_access, design_roving, design_repweights) removed. New effort estimators (survey-first): est_effort.instantaneous, est_effort.progressive, est_effort.aerial, est_effort.busroute_design design-based variance (supports svydesign svrepdesign). Aerial enhancements: visibility/calibration adjustments; optional post-stratification calibration via survey. estimate_effort(), estimate_cpue(), estimate_harvest() now error guidance new APIs. Replicate-weight helpers removed; use survey::.svrepdesign() day-PSU designs needed. Added “Survey Package Creel: Translator”. Added “Replicate Designs Creel Inference”. Updated “Getting Started”, “Effort (Survey-First)”, aerial examples use as_day_svydesign() new estimators. Docs/DevEx: Updated README, pkgdown navbar, AGENTS.md conventions; modernized CI workflows (R CMD check, lintr, pkgdown).","code":""},{"path":"/news/index.html","id":"tidycreel-0009000-2025-08-22","dir":"Changelog","previous_headings":"","what":"tidycreel 0.0.0.9000 (2025-08-22)","title":"tidycreel 0.0.0.9000 (2025-08-22)","text":"Added survey-first CPUE Catch estimators: est_cpue() (ratio--means default; mean--ratios option) est_catch() (totals via svytotal/svyby). Updated README Getting Started vignette CPUE/Catch examples; exported new functions; added minimal tests.","code":""}]
